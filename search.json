[{"title":"E5 神教装机指南","date":"2024-06-11T10:52:19.000Z","url":"/e5-cpu-computer-machine/","tags":[["Hardware","/tags/Hardware/"],["电脑装机","/tags/%E7%94%B5%E8%84%91%E8%A3%85%E6%9C%BA/"],["E5","/tags/E5/"],["硬件","/tags/%E7%A1%AC%E4%BB%B6/"]],"categories":[["Hardware","/categories/Hardware/"]],"content":"E5 神教装机指南说一下 E5 的特点： V3 的优势在于能鸡血，V4 不能鸡血。鸡血的作用是保持最高主频不是超频，这点别混。鸡血后比 V4 好。不鸡血是肯定没有 V4 好。这就是代价. 主板问题，X99 的通病在于主板供电散热，99% 用不久的主板都是散热没弄好导致的。所以加小风扇很重要。很重要. CPU 问题，玩网游单开选 E3，多开选 E5，游戏吃不下 U 的那么多核心。最直接的后果就是 6 核爆满十几核围观，导致总占用率只有可怜的一点点 功耗问题，鸡血会增加功耗，但是功耗和性能是成正比的。关成 5500 一样的核心按照日常使用也高不了多少 显卡问题，玩游戏显卡占用低 CPU 占用又低的话打开框框看一下是不是个别核心拉满其他核心在摸鱼，如果不是的话那就是内存的锅不是 CPU。东瓜有测试过，在内存保障充足下 2696 玩游戏甚至能拉满 4090 显卡 内存问题，网游除了 U 和显卡就很强调 内存频率，这 3 个配件有木桶效应。5500 的 3600x2 去跟 E5 的 2133x2 比高了几个档次，频率不够那就通道来凑，4 条 2133 的表现跟 2 条 3600 差不多。但价格更低。E5 不上 4 通道 连 1060 显卡都难喂满，帧率必然上不去或者波动特别大 (PS: 科脑 X99 这类盖板是双通道不是四通道。买主板的时候要注意） 参数一览: X99 平台主板品牌: 精粤 华南 (售后好) 科脑 AMD Ryzen 5 5000U 6core 12hyperthread CPU 跑分: 单核 single 476.6 multiple 多核 2502.9 X99 主板: 华南 X99-QD4 Reference"},{"title":"JavaScript 逆向工程小白指南","date":"2024-04-28T16:28:59.000Z","url":"/javascript/javascript-reverse-engineering/","tags":[["JavaScript","/tags/JavaScript/"],["Reverse","/tags/Reverse/"]],"categories":[["JavaScript","/categories/JavaScript/"]],"content":"JavaScript 逆向工程小白指南ReferenceThx the author of the following articles:  前置知识 (Pre-requisite)事件循环 event loop定义: 在 Chrome V8 引擎中, 主线程不断地重复获取执行信息, 再执行. 不断循环的机制称为事件循环. 为什么: JS 是单线程的 再处理异步操作的时候需要事件循环机制 概念: 堆(Heap): 大块非结构化内存区域, 储存对象,数据. 栈(Stack): 调用栈 储存该次循环待主程序执行的任务 队列(Queue): 事件队列, 先进先出被推入调用栈中 原型链 (Prototype Chain) 浏览器储存 (Browser Storage [&#x2F;ˈstɔːrɪdʒ&#x2F;]) Cookie: 存储在客户端的小型数据文件。 每次 HTTP 请求时，浏览器会自动发送 cookie 给服务器。 通常用于存储用户偏好或登录状态。 安全性较低，容易受到 CSRF 等攻击。(篡改 overwriting) 存储大小限制约为 4KB。 默认不支持跨越, 需要配置 nginx 和前端允许传递跨域 cookie. Session: 存储在服务器端的数据结构。 通过在客户端 cookie 中存储唯一的 session ID 来识别用户。set-cookie: sessionID=123456 后端 123456 –&gt; &#123; user: &#39;wf&#39;, age: 18 &#125; 可以存储更多的数据，但会增加服务器的存储压力。 比 cookie 更安全，因为数据不直接暴露在客户端。 Token: 服务端生成的一串加密的字符串，客户端在每次请求时发送给服务器。 不依赖于 cookie，因此可以用于移动应用或跨域请求。 可以包含用户的身份信息和权限数据。 通常用于 实现无状态 的身份验证。 简而言之，cookie 和 session 通常结合使用，通过在客户端存储 session ID 来维持用户状态，而 token 则是一种更灵活的方式，可以支持不同的客户端和跨域请求。 JWT (JSON Web Token): structure: header.payload.signature 传递 header: &#123;Authorization: &#39;token&#39;&#125; 跨域资源共享 Cross-Origin Resource Sharing (CORS) JavaScript 模块化 打包 捆绑器 (Module Bundler[&#x2F;ˈbʌndəl&#x2F;]) Webpack Note: 通常使用 babel 作为 webpack 的 compiler，将 ES6 语法转换为 ES5 语法。 What is AST (Abstract Syntax Tree)Generate by chatGPT: AST 是抽象语法树（Abstract Syntax Tree）的缩写。它是在计算机科学中用于表示 编程语言的语法结构 的一种 数据结构。抽象语法树是源代码在编译或解析过程中的中间表示形式，它捕捉了源代码的结构和语义信息。 在编程过程中，源代码首先会被 解析器或编译器 读入，并生成对应的 抽象语法树。抽象语法树可以看作是源代码的树状表示，其中每个节点代表源代码中的一个语法构造（例如表达式、语句、函数定义等），而节点之间的关系代表了语法结构中的层次关系和依赖关系。 通过使用抽象语法树，编译器、解释器和其他代码分析工具可以对源代码进行静态分析、语法检查、语义分析、优化等操作。抽象语法树在编程语言领域中具有广泛的应用，是理解和处理源代码的重要工具之一。 Function call stack 函数调用栈调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流 的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。 每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。 正在调用栈中执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。 当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。 当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。 stack overflow 调用栈是动态变化的. 在写递归(Recursive)函数时, 一定要注意递归的终止条件, 否则会导致调用栈溢出. Chrome DevTools (Chrome 开发者工具使用)Chrome 开发者工具(Chrome Development Tools)是一套内置于 Google Chrome 浏览器中的 Web 开发和调试工具。 Part: Elements (元素) Console (控制台) Sources (源代码) Network (网络) Performance (性能) Memory (内存) Application (应用) Security (安全) Audits[&#x2F;ˈɔːdɪt&#x2F;] (审计) Keyboard shortcuts: Ctrl + Shift + I 打开开发者工具 Network filter: 网络请求过滤器: Note: 按住 shift 可以查看请求间的 relier 依赖关系 Source panel: 源代码面板 conditional breakpoints: 条件断点 XHR&#x2F;Fetch 网络请求Dom Breakpoints: DOM 断点Global Breakpoints: 全局断点Event[&#x2F;ɪˈvent&#x2F;] Listener Breakpoints: 事件监听器断点 override: 重写一个文件, 代替网络请求. 将网络文件代理到本地. 类似功能的 Chrome 插件有 ReRes 和 Requestly snippet: 代码片段面板 breakpoint debug: 断点调试按钮 resume&#x2F;pause script execution恢复&#x2F;暂停脚本执行 step over next function call跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。 step into next function call跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。 step out of current function跳出当前函数 deactivate breakpoints停用断点 don‘t pause on exceptions不暂停异常捕获 Console: 控制台 output log: 输出日志 抓包工具 (Packet Sniffer)Charles [&#x2F;tʃɑ:lz&#x2F;]: cross-platform 一款抓包工具，可以用来查看手机端和电脑端的网络请求，查看请求头，请求体，响应头，响应体等信息。 TemperMonkey HookTemperMonkey 是一款浏览器插件，可以用来自定义网页的行为，可以用来修改网页的内容，添加新的功能等。 使用 TemperMonkey Hook window.btoa() 函数，将字符串转换为 base64 编码： Check if a function is native, if not, it has been hooked.反 hook 的思路: 判断一个函数是否是 native 函数, 如果不是就证明被 hook 过了. Stop infinite Debugger 阻止无限调试解决恶心你 阻止你进行调试的无限 debugger, 一般用于反爬虫. Solution n. &#x2F; Resolve v.: Deactivate breakpoints: 禁用所有断点 Never pause here: 禁用某处断点 conditional breakpoints: 条件断点 利用中间人工具替换字符串: Replace strings with man-in-the-middle tools fiddler 写 js script 替换 mitmproxy 写 python script 替换 reres or override 替换成本地文件 重写并置空关键函数 出现 debugger 后 置空 Function.prototype.constructor 函数构造器. 刷新后请求的 js 被加入了查询参数, 导致 breakpoint 失效的情况: 通过 reres 扩展与本地文件做一个映射. loading 中快速按 esc 取消 cancel 掉请求. 快速定位关键点 (Quickly Locate Key Points)通过使用常见加密算法的 hook, 快速定位到加密解密的关键点. 不用分析大段代码. 快速定位 – 搜索关键字 (Search Keywords) 中间人的全局搜索 fidder, mitmproxy 开发者工具中的全局搜索. (Global Search In Devtools) 断点调试 (Breakpoint Debugging)XHR&#x2F;DOM&#x2F;Event HookHook 常用的加解码函数: Base64: window.btoa() window.atob() JSON stringify: JSON.stringify() set-cookie: document.cookie eval: eval() evaluate v. 评估 Websocket: WebSocket.prototype.send = ()=&gt;&#123;&#125; Hook 常用方法: copy raw function and override: 复制原函数并重写 Object.defineProperty: 重写属性, getter, setter 原型链 Hook inject script Time: 代码注入时期, 当页面加载完成时 Analysis [&#x2F;əˈnæləsɪs&#x2F;] Elements Event Listeners: 元素事件监听器 Network type initator: 网络请求的发起者 Console log XMLHttpRequest: 控制台输出网络请求 分析流程: 抓包分析哪些参数是加密的. 搜索参数 查看 Network 的 Initiator 发起者 xhr breakpoint 网络断点 hook 逻辑 分析加密 补全加密逻辑 Code obfuscation 代码混淆 代码压缩: 去除空格 换行 代码加密: eval emscripten WebAssembly 代码混淆: 变量 常量 控制流扁平 调试保护 eval(var a = 1; var b = 2; console.log(a + b);) eval 执行里面被混淆的函数, 还原也很简单, 形同虚设. Emscripten: C&#x2F;C++ to JavaScript asm.js 通过 Emscripten 可以将 C&#x2F;C++ 代码编译为 JavaScript 代码, 从而实现在浏览器中运行 C&#x2F;C++ 代码的功能。 WebAssembly: 一种新型的低级 字节码格式，旨在提供一种高效的、可移植的、安全的二进制格式，以用于 Web 平台。resulte: wasm 文件 调用: JS 混淆技术: Obfuscation Techniques 变量混淆 字符串混淆 属性加密: Obj k-v 加密转发 控制流扁平化 僵尸代码注入: 注入一些无用代码, 干扰判断 代码压缩 反调试: infinite debugger | 环境检测 | 置空 console.log 禁用控制台输出 | 格式化后卡死 多态变异: 一旦被调用, 立马变成不同形式的代码, 但保证功能完全一致, 避免代码被动态分析 锁定域名: 降低被模拟风险 反格式化 特殊编码 jsfuck: 通过仅使用六个字符 []()!+ 来编写 JavaScript 代码的一种技术。 javascript-obfuscator: 代码混淆工具 use: 处理混淆后的代码: e.g: emoji 颜文字编码 操作原型链 eval 严重混淆 常见加解密 编码解码 算法 密码学是一个很庞大的分支, 对数学要求很高. Ascii 码ASCII [&#x2F;ˈæskiː&#x2F;](American Standard Code For Information Interchange): 美国标准信息交换代码, 一种将字符编码成二进制的方式. 用于显示现代英语以及其他的一些西欧语言. 在 Pytion 中 使用 ord() 获取字符的 ASCII 码. Base64将二进制数据转换为文本数据, 对于非二进制方式都先转成二进制, 连续使用 6bit 计算十进制的值, 对应检索码表. 特征: 以 == 结尾 引用: 嵌入 base64 格式图片 | 有些厂商非定制特定的码表达到 obfuscation 的目的 MD5 信息指纹MD5 计算做 Hash 校验, 对数据的完整性进行校验. Python Code: MD5 已经不具备抗碰撞性了, 不再是一种安全的散列算法, 真的不安全了吗? 查彩虹表(Hash Table) 有没有这个值. AES (Advanced Encryption Standard) 高级加密标准 对称加密用于替代原来的 DES(Data Encryption Standard) 数据加密标准. AES 是一种对称加密算法, 使用相同的密钥进行加密和解密. (只有一个密钥) Python 加解密库: Pycrpto 非对称加密: RSA(Rivest-Shamir-Adleman): 有公钥私钥两种密钥, 避免了密钥传输过程中的泄露问题. 控制流平坦化 (Control Flow Flattening)通过引入状态机(根据条件的值做出相应的动作)与循环，破坏代码上下文之间的阅读连续性和代码块之间的关联性，将若干个分散的小整体整合成一个巨大的循环体。无法还原成原来具体的函数。 目的 Purpose: 无法以函数为单位的调试方法，大幅度增加调试难度。 降低代码运行效率，提高爬虫运行时执行 js 的资源成本. 可根据 js 运行时检测到的某些因素自由跳转到蜜罐或跳出代码执行. 实现方法: 大量的 switch case 语句 模拟状态机分发代码 大量的 if else 语句 多维数组 数值计算比较 混淆原理 Obfuscation Principle: 通过 AST (Abstract Syntax Tree) 抽象语法树，将代码中的函数、变量、语句等元素转换为树状结构，再通过对树状结构的提取, 重新组合, 实现代码的混淆。 ATSexplorer: AST 可视化工具  应对三部曲: 全局观察:大致观察每一个代码结构，是否有类似于 dom 操作的代码，是否为纯计算型的循环体，是否有 try-catch 异常捕获结构。 整体分析与载入:断点定于 while 开头部分(状态机跳转判断),断点定于 try 代码体第一行, while 循环体整体取出构造原始函数. 构造函数查缺补漏，在运行的过程中通过不断地运行报错，补充缺失的函数或者数据. 通过 AST 增强代码可读性: via AST to enhance code readability. 通过 recast 库将代码转换为 AST 树, 通过 AST 树的遍历, 逐步还原代码, 增强代码可读性. switch case 语句还原, 每个 case 打印每个 case 的代码, 还原每个 case 的执行顺序."},{"title":"程序员常用单词词汇表","date":"2024-04-25T11:37:48.000Z","url":"/coding-english-world/","tags":[["Coding","/tags/Coding/"],["English","/tags/English/"]],"categories":[["Coding","/categories/Coding/"]],"content":"程序员常用词汇表ABCDWwhole - 整个"},{"title":"GIT 安全使用指南","date":"2024-04-03T08:36:23.000Z","url":"/github-security/","tags":[["GitHub","/tags/GitHub/"],["Cybersecurity","/tags/Cybersecurity/"],["OpenSourceSecurity","/tags/OpenSourceSecurity/"],["开源安全","/tags/%E5%BC%80%E6%BA%90%E5%AE%89%E5%85%A8/"],["网络安全","/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"categories":[["Git","/categories/Git/"]],"content":"Git 安全使用指南每时每刻，网络上成千上万的机器人贪婪的检索 GitHub，这包括开源软件 Attacker, Hacker ,甚至于受国家政府支持的 Attacker。 概述开源供应链攻击（Open source supply chain attack）近年来，供应链攻击事件 不断频发。过去一年中，恶意软件包上传到各种公共包管理库的事件数量呈爆炸式增长，这表明攻击者越来越青睐这种初始访问策略。根据软件供应链管理公司 Sonatype 的数据，在各个开源生态系统中检测到的恶意软件包数量同比增长了两倍。 开源软件供应链指的是广泛使用的第三方库、框架、组件等。例如 Python 的 fastapi、flask、requests 等，JavaScript 的 vue3、express、axios、lodash 等，Kubernetes，Docker，等服务工具。这些都是网络基础设施的重要组成部分。 幸运的是，这些网络基础设施都是 Open Source 的，任何人都能对其代码进行 review。但黑客也会利用这一点，用自己的 contributor 身份，抑或是盗取具有 contributor permission 账号的 cookie，巧妙地向开源软件下毒，这种下毒方式短时间内不会立即发现，随着软件依赖库的更新被分发到世界各地的互联网关键设施，黑客就能进出自由的控制政府、企业、个人的网络设备。 例如开发者可以通过修改 Python 的 dependency 的 requirements.txt ，当使用者下载并运行时，攻击开始了。 所以作为开发者，我们需要时刻保持警惕，不要随意下载未知的依赖库，尽可能使用官方源进行下载。有条件就进行 code review，或者使用一些安全工具进行扫描。 开源隐私泄露（Open source privacy leak）每天数以百万计的机器人在 GitHub 上检索代码，匹配代码中的敏感信息，各种 Key&#x2F;Session&#x2F;Token&#x2F;password&#x2F;数据库密码&#x2F;CardID&#x2F;CreditCard 等。很多开发者贪图方便，开发时将这些敏感信息硬编码在代码中，这样一来，如果开源到 GitHub 上，就自我开盒了。 有证据表明，中国政府会重点关注敏感项目(如FQ、Politics等)的 contributor 甚至 star ，尝试通过 profile、commit、issue、email、social media 精准定位墙内信息，精准喝茶。 解决方法也很简单： 打开 GitHub 的 Code security and analysis（代码安全和分析）-&gt; Push protection for yourself (保护自己的推送)，这样就可以 Block commits that contain supported secrets across all public repositories on GitHub. （阻止包含支持的秘密的提交） 不要偷懒，将敏感信息存储在环境变量中，或者使用专门的配置文件进行管理。并加入到 .gitignore 文件中，不要上传到 GitHub 上。 敏感的 repository 设置为 private，不要公开。 使用 GitHub 提供的 Keep my email addresses private (保持我的邮箱私密)，透过私密邮箱进行 commit。 GitHub 开启 Two-Factor Authentication(2FA 双因素验证)，增加账号安全性。 Action 行动Initiation [&#x2F;ɪˌnɪʃ.iˈeɪ.ʃən&#x2F;] 初始化配置全局用户名和邮箱 ssh-keygen 使用 RSA算法 生成 SSH key ，并将公钥添加到 GitHub 上。可以选择输入 passphrase 更加安全。位置：公钥 ~/.ssh/id_rsa.pub 私钥 ~/.ssh/id_rsa妥善保管上面两个文件，一同放在 KeePass 中。 创建 repository Git Proxy由于高墙的存在, 需要使用代理进行访问. I know this because it’s necessary for Chinese guys, lol. 解决了一个迷思: 为什么 HTTP 代理能够代理很多非 HTTP 协议的请求? ref: stackoverflow: why-are-http-proxies-able-to-support-protocols-like-irc-and-ftp Q: Why are HTTP proxies able to support protocols like socks and FTP? A: HTTP proxy is able to support high level protocols other than HTTP,Because it supports CONNECT method,HTTP 代理能够支持除了HTTP以外很多高级别的协议, 因为它支持 CONNECT 方法. The CONNECT method is a way to tunnel any kind of connection through an HTTP proxy. By default, the proxy establishes a TCP connection to the specified server, responds with an HTTP 200 (Connection Established) response, and then shovels packets back and forth between the client and the server, without understanding or interpreting the tunnelled trafficCONNECT 方法是一种通过HTTP代理隧道化任何连接的方法. 代理默认建立一个到指定服务器的TCP连接, 响应一个HTTP 200 (Connection Established) 响应, 然后在客户端和服务器之间来回传输数据包, 而不理解或解释隧道流量. 简单理解, HTTP 代理通过 CONNECT 方法将 TCP 的数据打包转发给目标服务器, 然后将数据包原封不动的返回给客户端, 从而实现了对非 HTTP 协议的支持. HTTP 代理支持所有基于 TCP 的协议, 但是不支持 UDP 协议. Use SSH over HTTPS protUse SSH over HTTPS prot: 通过 443 端口使用 SSH 协议，避免被 Firewall 阻挡。 Verify commit signature使用 GPG 验证并签名你的提交，您可以在本地签名提交。这些标签或提交在 GitHub 上标记为 已验证的绿色小勾 Verified，因此其他人可以确信更改来自 可信来源。有关 PGP 的使用见下一 part。 然后，在 Github 的 SSH and GPG keys 中，新增一个 GPG key，内容即是上述命令的输出结果。 再次提醒，GPG 密钥中个人信息的邮箱部分，必须使用在 Github 中验证过的邮箱，否则添加 GPG key 会提示未经验证。 配置 Private email： 利用 GPG 私钥对 Git commit 进行签名: 信任 GitHub 的 GPG 密钥：虽然所有的 commit 在 Github 中查看都是 Verified，但是有一些比较特殊：在 Github 网页端进行的操作，比如创建仓库。这些 commit 并没有用我们之前生成的密钥进行签名，而是由 Github 代为签名了。这样的结果就是，我们本地无法确认这些签名的真实性。 这时候，每一次 commit 都要输入 passphrase，可以使用 gpg-agent 来缓存密码，避免重复输入。 ~/.gnupg/gpg-agent.conf: Commit message 提交规范使用 angular commit message 规范，这是一个非常流行的 commit message 规范. feat 增加新功能 fix 修复问题&#x2F;BUG style 代码风格相关无影响运行结果的 perf 优化&#x2F;性能提升 refactor 重构 revert 撤销修改 test 测试相关 docs 文档&#x2F;注释 chore 依赖更新&#x2F;脚手架配置修改等 workflow 工作流改进 ci 持续集成 types 类型定义文件更改 wip 开发中 PGP 使用 世界上有两种密码:一种是防止你的小妹妹偷看你的文件;另一种是防止当局阅读你的文件.—— Bruce Schneier《应用密码学》 GNU Privacy Guard（GnuPG 或 GPG）是一个密码学软件，用于加密、签名通信内容及管理 非对称 密码学的密钥。 非对称密码大家应该接触过，这项技术在许多领域都有适用。这种算法需要两个 钥匙，一个是可以公开的 公钥 ，对应的另一个就是应保管好的 私钥 。用公钥加密的内容只能使用私钥解开，而使用私钥加密的内容也只能使用公钥解开。 目前计算机难以高效地进行质因数分解，比如我们将 2147483647 乘以 998244353 利用计算机很容易得到结果 2143713423777595391 ，但是反过来就扔给你一个 2143713423777595391 很难反推出原来两个质数。 利用这个特性，加上一个合适的流程，我们就得到了一个加密手段。 如果假象我们在使用一个去中心化通讯平台，每个人有唯一的一个账号（公钥）和密码（私钥），我要私聊一个朋友，内容肯定不想让别人知道，但是在去中心化网络中难以避免经过别人转手，这时候我就可以拿那位朋友的账号（公钥）加密，这样只有那位朋友使用自己的私钥才能解开这些内容；同样的，他怎么确定信息是我发出的而不是别人伪造我的身份发出的呢？那我在用他的公钥加密后再使用自己的私钥加密（也叫 Signature），他使用我的公钥发现能解开，那就必是我发出的无疑了。（但是你的私钥泄露了就……） PGP能保证 一条信息是你相信的人发的，除了你俩之外别人无法解密， 而且这条消息在传送时中间没有经过任何哪怕是一个标点一个字节的修改。 名词解释： 生成密钥PGP 的密钥分为两种：主密钥 和 子密钥，主密钥用于签名和认证，子密钥用于加密。只需要主密钥的公钥就行，包含了子密钥的信息。 生成主密钥： 生成子密钥：你日常使用应该使用子密钥，主密钥除了签发新的子密钥 不要使用。建议为不同环境，不同用途都单独生成子密钥，互不干扰。 生成撤销证书 revoke certification 假如你忘了主密钥的密码，或者丢失了对主密钥的控制权（丢失，被夺取），如果没有 撤销凭证 的话， 除了一个个通知你的朋友们没有任何办法 证明你不再使用这个密钥，这简直是灾难。 生成的 revoke.pgp 就是撤销凭证， 有了这个撤销凭证，你可以在没有密码的情况下 使一个公钥失效，所以一定要妥善保存，而且最好比主密钥多一份。 由于 PGP 没有提供任何 将吊销信息通知其他用户的方式，他不能保证没人会使用撤销了的已经变得不安全的密钥。 你丢失的私钥仍然可以被攻击者使用，并用来解密那些没有更新你的公钥的人发送的加密消息。 revoke 子密钥并更新公钥后，若有人用老的公钥加密信息，虽然你仍然可以解密，但是攻击者同样可以，这时候是极度不安全的。 例如：如果A的私人密钥被盗，她将发出一个 密钥撤销证书（key revocation certificate），但是由于这个密钥的分发是非正式的且将费大量的时间和口舌，故不能保证密钥环中每一个有 A 公开密钥的用户都能收到。 所以在你将密钥撤销后，请将发布到你一贯公布公钥的地方， 并尽可能通知其他人。 撤销主密钥： 撤销子密钥： 由于吊销前进行加密的内容仍需被吊销的密钥进行解密，所以被吊销的密钥也不应丢弃。 此外，若将 PGP 用于 SSH 认证，由于SSH的私钥认证并不通过主密钥来认证，所以即使吊销私钥，也可以进行访问，所以吊销后应当修改使用该密钥的SSH服务端来避免非法访问。 管理密钥 备份密钥 backup certification 删除 delete备份完后，要将本机的密钥清除干净，首先删除： 导入 import key certification 签名和验证 sign and verify 文件加解密： GPG Editer Reference 参考 thehackernews: hackers-hijack-github-accounts-in GitHub Authentication "},{"title":"德生 PL-330 收音机彩蛋","date":"2024-03-07T10:27:35.000Z","url":"/amateurradio/tecsun-pl330-radio-bonus/","tags":[["Radio","/tags/Radio/"],["业余无线电","/tags/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5/"],["短波","/tags/%E7%9F%AD%E6%B3%A2/"],["收音机","/tags/%E6%94%B6%E9%9F%B3%E6%9C%BA/"],["AmateurRadio","/tags/AmateurRadio/"]],"categories":[["Radio","/categories/Radio/"]],"content":"德生 PL-330 收音机彩蛋笔者使用的 PL330 收音机固件版本为 3306 以下彩蛋验证有效： 显示固件版本号：在关机的状态下，长按 VF&#x2F;VM 按键，直至屏幕上呈现全显。在屏幕显示复归正常前，右上角会显示固件版本号。 SSB 拍频设置：校准上边带或下边带。在开机的状态下，首先，调到一个调幅强台（即中波或短波强台都可以——译者注）。其次，长按 SSB 按键。再次，微调频率，直至实现零拍（零拍的标准为：除了声音的音调降低之外，没有呜呜声或其他声音失真现象——译者注）。最后，长按 LSB 按键，直至屏幕开始闪烁。 接收天线切换：在中波磁棒天线&#x2F;拉杆天线与外接天线插口之间切换，在开机的状态下，进入长波或中波波段。长按数字键 3，屏幕上显示 CH-A 时，代表使用机器自带的天线；显示 CH-5 时，代表使用外接天线。当选择外接天线这种模式的时候，屏幕上会同时显示 SW MW 的字眼。 调制频偏设置：在开机状态下，进入调频波段。长按数字按键 4，就能实现 75HZ（适用于美国）和 50HZ（适用于欧洲）之间的切换。 最大音量：打开收音机，切换到任意波段。首先，长按数字键 7。其次，调节音量旋钮。再次，长按数字键 7 保存。最后，每个波段都能进行单独的设置，默认值为 58。 时间显示秒：关闭收音机，长按数字按键 8 能够让时间显示读秒或关闭读秒。 设置静噪：在 PL990 收音机上，长按数字键 9 能够启用静音门槛设置，然而在 PL330 上却没有生效。具体操作流程是：开启收音机，进入任何波段都可以。首先，长按数字键 9，其次，旋转快步进飞梭。再次，改变屏幕左上角的数值，第四，长按 ENTER 按键保存。每个波段都可独立进行设置，默认值为 01。（好像在 PL330 上不生效） "},{"title":"CSS 樣式入門","date":"2024-03-03T08:36:23.000Z","url":"/javascript/senior-css/","tags":[["Design","/tags/Design/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["CSS","/tags/CSS/"]],"categories":[["JavaScript","/categories/JavaScript/"]],"content":"CSS 樣式入門Start学了前端那么久，发现 CSS 真是一个 博大精深 的语言，可以简单的实现很多 JS 做不到的效果。故出此专栏，记录一些常用、神奇的 CSS。 Reference： CSS online CSS Playground MDN CSS Tutorial CSS 入门概述 - 学习 Web 开发 | MDN Tailwind CSS Chinese Tailwind CSS w3cschool 后盾人文档,是一个介绍前端技术栈的博主 后盾人文档 CSS Video Tutorial 通过简明的视频动画阐述 CSS 各种概念 BV1Rv4y177rj Selector 选择器 选择器 层叠（cascade）和 优先级（specificity） 类选择器具有高优先级 Function 函数一个例子是 calc() 函数。这个函数允许在 CSS 中进行简单的计算： 另一个例子是 transform （变换角度）的不同取值，如 rotate()。 @ Rule @ 规则CSS 的 @rules（读作“at-rules”）是一些特殊的规则，提供了关于 CSS 应该执行什么或如何表现的指令。有些 @ 规则很简单，只有一个关键词和一个值。例如，@import 将一个样式表导入另一个 CSS 样式表： 一个常见的@规则是 @media，它被用来创建 媒体查询。媒体查询使用条件逻辑来应用 CSS 样式。 简写属性一些属性，如 font、background、padding、border 和 margin 等属性称为 简写属性。它们允许在一行中设置多个属性值，从而节省时间并使代码更整洁。 padding：设置内边距margin: 设置外边距 同样的还有设置 background： Box 盒子模型在 CSS 中，所有的元素都被一个个的“盒子”包围着。 几种类型的盒子，一般分为 区块盒子（block boxes）和 行内盒子（inline boxes）。 类型指的是盒子在页面流中的行为方式以及与页面上其他盒子的关系。盒子有内部显示（inner display type）和 外部显示（outer display type）两种类型。 block 区块盒子 类型：独占一行会换行；高度宽度都起作用；如果不指定宽度，占满一整行。 inline 行内盒子：盒子不会换行；高度宽度都起不作用 盒子模型的各个部分： 内容盒子：显示内容的区域；使用 inline-size 和 block-size 或 width 和 height 等属性确定其大小。 内边距盒子：填充位于内容周围的空白处；使用 padding 和相关属性确定其大小。 边框盒子：边框盒子包住内容和任何填充；使用 border 和相关属性确定其大小。 外边距盒子：外边距是最外层，其包裹内容、内边距和边框，作为该盒子与其他元素之间的空白；使用 margin 和相关属性确定其大小。 Flexbox 弹性布局建立一个 container div，设置 display: flex，div 内子元素会 自动排列，无需手动布局，可以自适应屏幕大小。尤其是在子元素个数和容器尺寸不确定的情况下，非常方便。 容器属性： flex-direction：决定主轴的方向（即子项目的排列方向）。 raw 水平 column 垂直 justify-content：定义了子项目在 主轴 上的对齐方式 center。 justify vt. 证明…有理；为…辩护 这里指的是 v.对齐 align-items：定义子项目在 交叉轴 上如何对齐。 flex-start 默认，交叉轴前对齐 center 交叉轴居中对齐 baseline 文字基线对齐 stretch 拉伸 flex-wrap：定义了子项目在 超出主轴 换行时的行为。 nowrap 不换行 wrap 换行 wrap-reverse 反向换行 align-content：定义了多行项目在交叉轴上的对齐方式，只对 多行项目 有效。 项目属性： order：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 flex-grow：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。 flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。 响应式设计 媒体查询 Flexbox 弹性布局 Grid 网格布局 相对单位 rem、em、vw、vh em：相对于父元素的字体大小 rem：相对于根元素的字体大小 CSS 动画CSS 动画也叫 补间动画（Tweening Animation），确定了元素的起始状态和结束状态，然后计算中间状态，通过过渡动画实现。 @keyframes 动画关键帧，定义动画的开始和结束状态。起点和终点可以使用百分比或关键字（from 和 to）来表示。 贝塞尔曲线（cubic-bezier），可以自定义动画速度曲线。animation 的第三个参数。 linear：匀速运动 ease：慢速开始，然后加速 ease-in：慢速开始 ease-out：慢速结束 ease-in-out：慢速开始和结束 cubic-bezier(n,n,n,n)：自定义速度曲线 steps(n)：分 n 步完成动画,没有平滑过渡 Tailwind CSSTaiwind CSS 无需离开 HTML 通过 类名 快速实现各种样式，支持响应式设计和媒体查询。 InstallRaw HTML edit tailwind.config.js file: add in to tail.css run compiler: Vue3Offial Guides in vue3 也支持使用 TS 进行配置：tailwind.config.ts configuration#using-esm-or-type-script 使用 tailwind ui 组件库： headlessui&#x2F;vue: 无样式组件库 headlessui heroicons&#x2F;vue: 图标库 heroicons PluginsDaisyUI Tailwind CSS 组件库 (as plugins):  Base 基础设计一个卡片： Keywords: p: padding 内边距m: margin 外边距w: width 宽度x: 水平方向y: 垂直方向 通过断点使用媒体查询： p-6 表示设置内边距 (padding) 为 6。max-w-sm 表示设置最大宽度为 small(小屏幕) 的宽度。mx-auto 表示在水平方向上居中对齐。bg-white 表示设置背景颜色为白色。rounded-xl 表示设置圆角为 extra large(特别大)。shadow-md 表示设置阴影效果，阴影大小为 medium(中等)。flex items-center space-x-4 表示使用 Flexbox 布局，子元素水平排列，元素之间的间距为 4。 container 用于创建一个包含内容的容器，通常用于限制内容的最大宽度，使内容在大屏幕上不至于过宽，提高内容的可读性和美观性。 mx-auto: 这个类名用于水平居中元素，将元素的左右外边距设置为 auto，使元素在父容器中水平居中显示。 px-4: 这个类名用于设置元素的水平内边距（padding），px 代表水平方向（左右），4 代表内边距的大小。在这种情况下，px-4 代表水平方向上的内边距为 4 个 CSS 像素。 gap: 这个类名用于设置元素之间的间距，gap-4 代表元素之间的间距为 4 个 CSS 像素。 Flexbox 布局： 同时运用这两个可以使得元素在正中间： items-center 应用于 flex 容器，用于在 主轴方向 上将子元素 垂直居中 。 justify-center 应用于 flex 容器，用于在 主轴方向 上将子元素 水平居中 。 Flex 参数： flex-wrap 类用于控制 Flex 容器中的项目在一行上 是否换行 显示。flex-wrap-reverse：允许项目在需要时换行显示，并且反转换行的方向。flex-nowrap：阻止项目换行，强制所有项目在一行上显示。举个例子，如果你想要一个 Flex 容器中的项目在需要时自动换行 prettier 自动排序 order 正则安全清除所有暗黑模式： Gsap AnimationGSAP 是一个高性能的动画库，可以实现更复杂的动画效果。 ref: GSAP 中文文档 GSAP 中文文档 高度塌陷相对定位 (relative) 和绝对定位 (absolute)ref: CSS相对定位和绝对定位详解_css绝对定位代码-CSDN博客"},{"title":"Vue3 项目上手学习——V3 Admin","date":"2024-02-29T08:43:20.000Z","url":"/javascript/vue3-v3-admin-stady/","categories":[[" ",""]],"content":"Vue3 项目上手学习——V3 AdminStart学了那么久的 Vue3，终于到上手实战项目的时候了。之前一直是看视频教程，没有真正的上手打开 VSC 摸过项目，是时候写代码了。 这次选用的是 V3 Admin 这个项目，毕竟人家使用了主流技术 Vue3 + Pinia + Router + Vite + Element-Plus 。本文是在官网文档的基础上进一步抽丝剥茧分析这个项目，并提炼一些 通用写法。 reference： GitHub v3-admin-vite 项目对应老鸟中文文档：V3 Admin Vite 中文文档 - 掘金 适用于小白的 step by step tutorial V3 Admin Vite - pany 的专栏 - 掘金 Technology Stack 技术栈 Vue3：采用 Vue3 + script setup 最新的 Vue3 组合式 API Element Plus：Element UI 的 Vue3 版本 Pinia: 传说中的 Vuex5 Vite：真的很快，取代 webpack Vue Router：路由路由 TypeScript：JavaScript 语言的超集 PNPM：更快速的，节省磁盘空间的包管理工具 Scss：和 Element Plus 保持一致 CSS 变量：主要控制项目的布局和颜色 ESlint：代码校验 Prettier：代码格式化 Axios：发送网络请求（已封装好） UnoCSS：具有高性能且极具灵活性的即时原子化 CSS 引擎 注释：各个配置项都写有尽可能详细的注释 兼容移动端: 布局兼容移动端页面分辨率 Prepare 准备Install base ModuleProxy first，在 墙国，下个 npm 包前提是一个好用的代理： Install module Install ElementUI-Plus In main.ts 安装按需引入 向 vite.config.ts 添加插件： configure： Configure 配置项Vscode code snippetsvue3 code snippet： vue3 hook code snippet: Code specification 代码规范命名规范Components 组件和 Views 页面命名规范，这样做是为了更好的区分 component 和 view Components 组件：都采用单词大写开头的 大驼峰 命名方式 (PascalCase)：@/components/Index.vue 、@/components/NotifyList.vue Views 页面：页面由 components 组件组成，一律采用 短横线连接 (kebab-case) 的命名方式，比如：- @/views/fetch-select.vue hook 命名：采用 **小驼峰 (camelCase)**，比如：@/hooks/useTheme.ts。 Prop 命名：在声明 prop 的时候，其命名应该始终采用 **小驼峰 (camelCase)**。 代码规范 prop 的定义应该尽量详细，至少需要指定其类型 在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。 避免 v-if 和 v-for 用在一起。 Annotation 注释规范由于项目采用 TS 5.x 进行开发，为了获得更好的 TS 提示，项目采用了大量的 /** xxx */ 注释，它的优点就是鼠标放上去会有注释显示出来。 Code format and verify 代码格式化和校验.tsconfig项目最重要的 ts 配置 .tsconfig ESlint package.json 文件的 devDependencies 中有所需的 ESlint 依赖包。 ESlint 的配置文件是根目录下的 .eslintrc.cjs，它里面定义了很多校验规则 ESlint 的忽略文件是根目录下的 .eslintignore，它里面定义的目录和文件都不会被 ESlint 检查 .eslintrc.cjs .eslintignore： Prettier package.json 文件的 devDependencies 中有所需的 Prettier 依赖包 Prettier 的配置文件是根目录下的 prettier.config.js，它里面定义了很多格式化规则 Prettier 的忽略文件是根目录下的 .prettierignore，它里面定义的目录和文件都不会被 Prettier 格式化 prettier.config.js： .prettierignore vite.config.ts项目 Vite 最重要的配置 vite.config.ts .env环境变量 .env .editorConfigeditorConfig 是一个适用于 多语言，多 IDE 的代码格式化工具。有利于各种项目 形成统一的代码格式风格。建议在所有项目中启动 editorConfig 因为真的很好用。 .editorConfig .npmrcnpm、cnpm 包管理工具的配置项，设置代理之类的。 .npmrc Vscodesettings.json Git commit 规范 feat: 增加新的业务功能 fix: 修复业务问题&#x2F;BUG perf: 优化性能 style: 更改代码风格, 不影响运行结果 refactor: 重构代码 revert: 撤销更改 test: 测试相关, 不涉及业务代码的更改 docs: 文档和注释相关 chore: 更新依赖&#x2F;修改脚手架配置等琐事 workflow: 工作流改进 ci: 持续集成相关 types: 类型定义文件更改 wip: 开发中 完成一件事情，就提交一次 commit。而不是等到你写完一整天的代码后，才在下班前只提交一次。 vue-router 路由CH Document：安装 | Vue Router Install"},{"title":"LightRoom 后期调色学习笔记","date":"2024-02-13T13:19:26.000Z","url":"/lightroom-tutorial/","tags":[["Design","/tags/Design/"],["设计","/tags/%E8%AE%BE%E8%AE%A1/"],["后期","/tags/%E5%90%8E%E6%9C%9F/"]],"categories":[["Design","/categories/Design/"]],"content":"LightRoom 后期调色学习笔记Start最近闲来无事，沉浸于光影的美伦变幻，所以系统学一下后期调色、对比度、饱和度、色相等知识。LightRoom 是一个专业的调色软件，和 PS 配合使用并支持 RAW 模式。 RAW 模式是相机把 CMOS 镜头感应光 的初始数据都保存在里面了，方便后期调色。 Reference： B 站的一个介绍影视后期 UP 主 Genji 真想教会你，通过 90 分钟的视频给你介绍各种后期软件如何使用，真是太方面想要速成的小白白了： 拜托三连了！这绝对是全B站最用心（没有之一）的Lr公开课程，调光调色就靠它！ 专业术语 LUT (LookupTable)：颜色查找表，色卡，一个算法，让每个画面中的像素完成在色彩空间上的向量变化。通俗点就是 滤镜。 RGB（红绿蓝）：xyz 轴标注着红色、绿色、蓝色的空间坐标。 光色理论红橙黄绿青蓝紫 三相色色盘 如果想要画面更蓝，就减少黄色，或者增加与蓝色相邻的过渡色 品红 和 泛蓝 CMYK 显色原理 通透？上面比下面的图片 对比度 更高，更 通透。 "},{"title":"程序设计模式 Program Design Patterns","date":"2024-02-02T09:18:32.000Z","url":"/program-design-patterns/","tags":[["Program","/tags/Program/"],["高级编程","/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"],["Python","/tags/Python/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["DesignPattern","/tags/DesignPattern/"]],"categories":[["Python","/categories/Python/"]],"content":"程序设计模式 Design PatternsStart在写一些复杂度、集成度高的程序时，常常会写很多 class 很多 methods，如何将他们很好的组合起来，后期方便扩展和维护，避免写出 屎山代码，这时候就需要一个约定俗称的 程序设计模式 （Program Design Patterns）。 本文以 Python 和 Typescript 为例子，介绍 22 种设计模式的实现和在实际开发中如何去高效使用。 Reference： Refactoring guru 图解设计模式&#x2F;重构 教程网站：常用设计模式有哪些？ 工厂方法模式 factory method工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。 例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。 开闭原则: 在扩展新的类时，尽量不要修改原有代码。 伪代码: Python： "},{"title":"Vue3 深度理解(由浅及深)","date":"2024-01-13T07:21:31.000Z","url":"/javascript/vue3-deep-understanding/","tags":[["JavaScript","/tags/JavaScript/"],["JS","/tags/JS/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["Vue3","/tags/Vue3/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 深度理解 (由浅及深)写了那么久的 Vue3，理解一下 Vue3 的原理，从浅到深。 Vue3 reactivity system: 双向数据绑定 (Two-way data binding)Vue 是数据双向绑定的框架 (MVVM)，双向绑定由三个重要部分构成: 数据层（Model）：应用的数据及业务逻辑 视图层（View）：应用的展示效果，各类 UI 组件 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来 ViewModel 数据 (Model) 变化后更新视图 (View) 视图 (View) 变化后更新数据 (Model) 它有两个主要部分组成: 监听器（Observer）：对所有数据的属性进行监听 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 实现双向绑定 (Two-way data binding) Note:由于 data 的某个 key 在⼀个视图中可能出现多次 (使用了多次 &#123;&#123; name &#125;&#125;)，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher. 将来 data 中数据⼀旦发生变化，会首先找到对应的 Dep，通知所有 Watcher 执行更新函数. 依赖收集 (Dependency Collection)视图中会用到 data 中某 key，这称为依赖。同⼀个 key 可能出现多次，每次都需要收集出来用⼀个 Watcher 来维护它们，此过程称为依赖收集 (Dependency Collection). 多个相同 Key 的 Watcher 需要⼀个 Dep 来管理，需要更新时由 Dep 统⼀通知. 组件间的通信 (Communication between components)v-bind &#x2F; prop 单向数据流 (One-Way Data Flow)数据从父组件流到子组件, 而子组件不能改变父组件传来的数据. This prevents(v. 预防) child components from accidentally(adv. 意外地) mutating(n. 变化) the parent’s state. v-model 双向数据绑定 (2-way binding)常用于表单数据绑定, 父组件通过 v-model 绑定一个 value. 子组件修改父组件传过来的 value 时通过 emit 一个 update:moduleValue 事件. 父组件接收这个事件后, 修改这个 value. 修改父组件 value 的, 是父组件本身, 子组件只负责发送一个事件给父组件, 父组件收到子组件的 update Event 后自行更改. 本质上不打破单向数据流原则. (The principle of One-Way Data Flow) 不用 v-model 实现的 2-way binding: 使用 v-model 和 defineModel, 子组件的 model 是一个 Ref 保持响应式 (Reactivity). 实现 EventEmitter 事件触发器Observer 观察者模式观察者模式定义了对象间的 一种一对多 的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新. 观察者模式属于行为型模式，行为型模式关注的是 对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯. 被观察者 be observed object: 观察者 observer: used: 发布订阅模式 (Publish-Subscribe)发送者不会将信息直接发送给指定的订阅者, 而是将发布的信息 分为不同的类型, 发布者无需了解存在哪些订阅者. 订阅者会自己接收指定类型的信息. 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在. 发布者 (publisher) 和订阅者 (subscriber) 需要透过一个 broker(中间人, 也叫发布订阅中心) 进行关联, 但 发布者的发布动作和订阅者的订阅动作相互独立, 无需关注对方. 消息派发由发布订阅中心负责. broker(发布订阅中心 PubSub): Publisher 发布者: Subscriber 订阅者: Use: 实现 Simple EventEmitterEventEmitter 本质上就是只有一个 publisher 的 PUB&#x2F;SUB 模型 Node 采用了事件驱动机制，而 EventEmitter 就是 Node 实现事件驱动的基础. 在 EventEmitter 的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作 used: Reference Three ways to expose internal Vue components API - Abdelrahman’s Blog Making the most out of Vue.js Injections - Abdelrahman’s Blog node-deep&#x2F;event&#x2F;深入学习 Node.js EventEmitter.md at master · semlinker&#x2F;node-deep · GitHub "},{"title":"Vue3 + vite + Ts + pinia 全家桶学习","date":"2024-01-13T07:21:31.000Z","url":"/javascript/vue3-guide/","tags":[["JavaScript","/tags/JavaScript/"],["JS","/tags/JS/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["Vue3","/tags/Vue3/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 + vite + Ts + pinia 全家桶学习Reference BiliBili 小满 ZS VUE3 教程：Vue3 + vite + Ts + pinia + 实战 + 源码 + electron 概述 MVVM 架构 Options API and Composition API Vue3 的优化：重写双向数据绑定，基于 ES6 Proxy Computed attribute 计算属性 Watch listener Vue lifespan 生命周期onBeforeMount(挂载前) -&gt; onMounted(挂载后) -&gt; onBeforeUpdate(更新数据之前) -&gt; onUpdated(更新数据之后) -&gt; onBeforeUnmount(卸载之前) -&gt; onUmounted(卸载之后) 在 setup 语法糖模式中没有 beforeCreate 和 created 两个生命周期，用 setup(callback) 来代替。 调试用的两个 hook，onRenderTracked，onRenderTriggered，应该是依赖 effect 依赖收集之类的钩子，具体可以看 Vue3 的响应式 ref reactive 原理。 BEM 架构和 layout 布局和 sass CSS 预处理器BEM 架构： block (块)，element (元素)，modify (修饰)，指的是 namespace 的命名风格，在 element-UI 中，el-button__wrapper 表示一个 block 中的 element。el-button--primary 表示 button 的自定义按钮风格 modify。 Sass.hk 中文网： Sass教程 Sass中文文档 | Sass中文网 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能. 父子组件传参子组件 children 父组件： "},{"title":"Vue3 + vite + Ts + pinia 全家桶学习","date":"2024-01-13T07:21:31.000Z","url":"/javascript/vue3-vite-ts-pinia-electron/","tags":[["JavaScript","/tags/JavaScript/"],["JS","/tags/JS/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["Vue3","/tags/Vue3/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 + vite + Ts + pinia 全家桶学习Reference BiliBili 小满 ZS VUE3 教程：Vue3 + vite + Ts + pinia + 实战 + 源码 + electron 概述 MMVVM 架构 Options API and Composition API Vue3 的优化：重写双向数据绑定，基于 ES6 Proxy Computed attribute 计算属性 Watch listener Vue lifespan 生命周期onBeforeMount(挂载前) -&gt; onMounted(挂载后) -&gt; onBeforeUpdate(更新数据之前) -&gt; onUpdated(更新数据之后) -&gt; onBeforeUnmount(卸载之前) -&gt; onUmounted(卸载之后) 在 setup 语法糖模式中没有 beforeCreate 和 created 两个生命周期，用 setup(callback) 来代替。 调试用的两个 hook，onRenderTracked，onRenderTriggered，应该是依赖 effect 依赖收集之类的钩子，具体可以看 Vue3 的响应式 ref reactive 原理。 BEM 架构和 layout 布局和 sass CSS 预处理器BEM 架构： block (块)，element (元素)，modify (修饰)，指的是 namespace 的命名风格，在 element-UI 中，el-button__wrapper 表示一个 block 中的 element。el-button--primary 表示 button 的自定义按钮风格 modify。 Sass.hk 中文网： Sass教程 Sass中文文档 | Sass中文网 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能. 父子组件传参子组件 children 父组件： "},{"title":"英语不规则动词规律","date":"2023-12-28T09:48:06.000Z","url":"/english/english-bgz-verbs/","tags":[["English","/tags/English/"],["Study","/tags/Study/"]],"categories":[["English","/categories/English/"],["Study","/categories/English/Study/"]],"content":"英语不规则动词规律过去式 &#x3D; 过去分词 &#x3D; 原形 AAA 原形 过去式 过去分词 汉语意思 bet bet bet 打赌 cost cost cost 耗费 (钱) cut cut cut 切，割 hit hit hit 撞，击打 hurt hurt hurt 使…伤痛 let let let 让 put put put 放 read read read 读 spread spread spread 传播 set set set 安排，安置 upset upset upset 不安 beat beat beaten 打击 过去式改字母, 过去分词 &#x3D; 原形 ABA 原形 过去式 过去分词 汉语意思 become became become 成为 come came come 来 run ran run 跑 过去式改字母, 过去分词&#x3D;原形 +en 原形 过去式 过去分词 汉语意思 eat ate eaten 吃 fall fell fallen 落下 forbid forbade forbidden 禁止 forgive forgave forgiven 原谅 give gave given 给 ride rode ridden 骑 see saw seen 看见 write wrote written 写 rise rose risen 升起 see saw seen 看见 shake shook shaken 摇动 take took taken 拿去 throw threw thrown 扔 过去式改字母, 过去分词&#x3D;过去式 +en 原形 过去式 过去分词 汉语意思 break broke broken 打破，折断 drink drank drunken 喝 drive drove driven 开车,驱动 choose chose chosen 选择 forget forgot forgotten 忘记 freeze froze frozen 冻 speak spoke spoken 说 hide hid hidden 躲藏 steal stole stolen 偷 wake woke waken 醒来 write wrote written 写 原形 ow, 过去式 ew, 过去分词 n 原形 过去式 过去分词 汉语意思 blow blew blown 吹 draw drew drawn 画 fly flew flown 飞 grow grew grown 生长 know knew known 知道 原形 i, 过去式 a, 过去分词 u 原形 过去式 过去分词 汉语意思 begin began begun 开始 drink drank drunk 喝 ring rang rung 门铃响，电话铃响 sing sang sung 唱 swim swam swum 游泳 原形, 过去式 ought, 过去分词 ought ABB 原形 过去式 过去分词 汉语意思 bring brought brought 带来 buy bought bought 买 fight fought fought 打架 seek sought sought 寻求 think thought thought 思考 原形, 过去式 aught, 过去分词 aught 原形 过去式 过去分词 汉语意思 catch caught caught 捉,抓 teach taught taught 教 过去式改元音字母, 过去分词&#x3D;过去式 原形 过去式 过去分词 汉语意思 dig dug dug 挖 feed fed fed 喂 find found found 发现 get got got 得到 hold held held 拥有 lead led led 引导 meet met met 遇见 sit sat sat 坐 win won won 赢 sell sold sold 卖 shine shone shone 照耀 过去式改辅音字母, 过去分词&#x3D;过去式 原形 过去式 过去分词 汉语意思 hear heard heard 听见 make made made 制造 lose lost lost 失去 light lit lit 点亮 过去式改字母 + T, 过去分词 &#x3D;过去式 原形 过去式 过去分词 汉语意思 feel felt felt 感到 keep kept kept 保持 leave left left 离开 sleep slept slept 睡 smell smelt smelt 闻 sweep swept swept 扫 build built built 建造 lend lent lent 借出 mean meant meant 意思 send sent sent 寄,送 spend spent spent 花费 spell spelt spelt 拼写 bend bent bent 使弯曲 burn burnt burnt 燃烧 deal dealt dealt 处理 dream dreamt dreamt 梦见 learn learnt learnt 学习 变 aid 原形 过去式 过去分词 汉语意思 lay laid laid 放下 pay paid paid 付费 say said said 说 其他 原形 过去式 过去分词 汉语意思 stand stood stood 站立 tell told told 告诉 wear wore worn 穿 lie lay lain 躺 情态动词can(能够) &#x3D;&gt; couldmay(可能) &#x3D;&gt; mightwill(将会 愿意) &#x3D;&gt; wouldshall(将要 应该) &#x3D;&gt; should"},{"title":"英语零基础学习记录 Record 系列 —— 前言","date":"2023-11-09T09:11:10.000Z","url":"/english/english-from-zero-tutorial-start/","tags":[["English","/tags/English/"],["Study","/tags/Study/"],["GK","/tags/GK/"]],"categories":[["English","/categories/English/"]],"content":"英语零基础学习记录 Record 系列 —— 前言前这是记录我从 0 开始学习英语的过程。 英语有三大块： Pronunciation 发音 Vocabulary 词汇 Grammar 语法 目录"},{"title":"英语零基础学习记录 Record 系列 —— 语法 Grammar","date":"2023-11-09T08:56:48.000Z","url":"/english/english-from-zero-tutorial-grammar/","tags":[["English","/tags/English/"],["Study","/tags/Study/"]],"categories":[["English","/categories/English/"]],"content":"英语零基础学习记录 Record 系列 —— 语法 Grammar前学习完如何记单词的同时，也要系统的学习英语语法，才能准确的把单词连接成句子。 Reference 英语语法精讲合集 (全面, 通俗, 有趣 | 从零打造系统语法体系) 英语兔 BiliBili 比较系统语法教程： 英语语法精讲合集 (全面, 通俗, 有趣 | 从零打造系统语法体系) BV1XY411J7aG 上面的视频可以帮你理清整个英语语法的学习体系，我的笔记也是基于这个视频的内容进行补充和完善。 Clause Element 句子成分什么 + 怎么样 主语 人&#x2F;物 + 谓语 动作 Verbs &#x2F; 发生了什么事 5 种基本句型 Simple Sentences 简单句谓语动词 的变换构成 5 种英语的简单句型，英语语法的核心——动词 verb谓语动词 分为 5 种：1. 不及物动词 2. 单及物动词 3. 双及物动词 4. 复杂及物动词 5. 系动词 可以独立完成的动作 不及物动词主语 + 不及物动词（谓语）Papa Rabbit sleep. 兔老爹睡觉 有 1 个动作的承受者 （动作承受者就是宾语）主语 + 单及物动词 (谓语) + 宾语(动作承受者) 有 2 个动作承受者主语 + 双及物动词 (谓语) + 间接宾语 + 直接宾语 Teaches English，English 是直接宾语，承受 teaches，已经句意完整了，但是如果要准确描述教的对象就要加上 you 称为间接宾语。 只有 1 个动作承受者（但需要补充才能使句意完整）主语 + 复杂及物动词 (谓语) + 宾语 + 宾语补语 (宾补) considers you 认为你，不能构造一个完整的句子，需要加上一个补语 smart 才能构成完整的句子。considers you smart. 非 “动作” （赋值）赋予主语某种状态主语 + 连系动词 (系动词) + (主语) 补语&#x2F;表语She is good. 将 nice 赋值给主语 Rabbit ，中间用 smells 系动词 连接，也可以使用 is ，相当于编程中的赋值符号 =。而赋值给主语的状态词 nice 称作主语补语，补充说明主语，或称 表语。 5 种基本句 总结5 种基本简单句就是他们的 谓语动词 种类的区分的 谓语动词： 可以独立完成的动作，无需承受者：不及物动词 有一个动作的承受者，一个宾语无需补充信息：单及物动词 有两个动作承受者，有两个宾语一个直接一个间接：双及物动词 只有一个动作承受者，有一个宾语但是需要宾补补充信息：复杂及物动词 非“动作”，**用于赋予状态，之前是主语，之后是主语补语 (表语)**：系动词 5 种基本句型： 句子成分 主语 谓语动词 宾语 （谓语动词动作的承受者） 宾语补语 主语补语&#x2F;表语 定语：相当于一个大 形容词，用来修饰和限定 名词或代词 的词或词组，用来描述名词或代词的特征、性质、状态等。定语通常位于被 修饰的名词或代词前。定语前置The red car is mine.She is a talented singer （过去分词做定语）talented adj. 有才华的 状语：相当于一个大 副词，是用来 补充说明动词、形容词、或整个句子的词或词组，用来描述动作的方式、程度、时间、地点等。 状语可以放在句子不同位置He speaks English fluently.I will go to the store tomorrow.quickly 修饰谓语动词 ate。吃的快 同位语：再把主语或宾语说一遍 和 主语同等地位 简单句 VS 复合句 简单句 simple sentences 在英语中没法再拆的句子，5 种基本句型。 复合句 compound sentence 简单句型的叠加，不分主次 复杂句 complex sentence 一个简单句套一个简单句 主句、从句，从属关系 主句 + 从句 总结： 词性 (词类) 名词 (nouns)：表人和物 Papa Rabit is a rabbit. 冠词 (articles) ：说明人和事物 Papa Rabbit is a rabbit. 代词 (pronouns)：代替人和物 I am a rabbit. 形容词 (adjectives)：形容人和物体 I am a supid rabbit. 数词 (numerals)：表数量 I ate tow carrots 副词 (adverbs)：补充说明 动词、形容词 等 I ate carrots quickly. 副词做状语 介词 (prepositions)：表示和其他词关系的词 I ate two carrots with chopsitcks. 叹词 (interjections)：表感叹 Ah,the carrot is tasty. oops! 连词 (conjunctions)：连接词和句 I ate two carrots and a potato,because I was hangry. 动词 (verb)：详见上 谓语动词 (verb) 时态 tense 动作假设、情感等 语法的语气 助动词谓语动词 本身往往不能独立完成本领，谓语动词 独自也无法完成表示否定、可能性、必须性等意思，就需要用的 助动词 帮助 谓语动词 完成其本领。 做 助动词，没有实义，只是帮助谓语动词而已。还可以做 实义动词，表其他词意。 非谓语动词取代几乎所有从句，简化句子。 非谓语动词丧失了谓语动词的本领 总结 动词动词第三人称单数人称： 第一人称：我、我们 第二人称：你、你们 第三人称：它、他、她、他们、事物名称：人名、地名… 第三人称单数：非我，非你、非复数 we -&gt; 第一人称复数she -&gt; 第三人称单数Lily -&gt; 单个人名，第三人称单数they -&gt; 他们，第三人称复数Tom and Mike -&gt; 两个人，第三人称复数I -&gt; 第一人称单数my parents -&gt; 第三人称复数 及物动词和不及物动词及物动词直接加 + 宾语不及物动词不能直接加宾语，构成 主 + 谓 结构，或者，不及物动词 + 介词 + 宾语，I look at you. 我 看 你。 动词分类 动词时态动作的时间 + 动作的状态 动词时间 过去、现在、将来 过去将来：对于过去某一个时间点而言的将来，昨天是前天这个过去的将来，（过去将来和现在没有必然关系）&#x3D;&gt; 一般出现在从句中。 动词状态 一般：没有具体说明，默认的时态 完成：我已经给你点赞了 进行：我正在给你点赞 完成进行：我已经给你点完赞了，以后也正在给你点赞，已完成的但还会继续。 组合总述 各种助动词的变位： 助动词 be 变位：I am | You are | he&#x2F;she&#x2F;it is过去时态 I&#x2F;she&#x2F;he&#x2F;it was | you&#x2F;we&#x2F;they werebe 的过去分词 been 助动词 have 变位：I&#x2F;you&#x2F;we&#x2F;they have | She&#x2F;he&#x2F;it has过去时态统一 had 助动词 will 表将来：将要后跟的 be、have、动词 全部都是原形过去时态 would 助动词 shall 表将来：将要类似 will.过去时态 shall -&gt; should 做情态助动词另一义：应该 can -&gt; could 能够 may -&gt; might 可能 现在一般：人称 + 动词原形（三单）|| I eat carrot. 现在进行：助动词 be 变位 + 动词现在分词 || I am studying 现在完成：助动词 have 变位 + 动词的过去分词 || I have done 我做完了 强调过去对现在的影响 现在完成进行：助动词 have 变位 + been(be 的过去分词) + 动词现在分词 || I have been thinking for you. 对现在而言已经完成但还会继续 过去一般：人称 + 动词的 过去式 (-ed) || I ate a carrot yesterday. 简单的表示发生在过去的动作 过去进行：助动词 be 的过去变位 was&#x2F;were + 动词现在分词 || I was studying English yesterday mornning. 过去完成：had(助动词 hava 的过去变位) + 动词过去分词 || He tried to find me yesterday afternoon,but I had already gone to Foshan. 过去的过去对过去的影响 过去完成进行：had + been + 动词的现在分词 || The rabbit had been eating carrot. 对过去而言已经完成了的但接下来还会继续的状态，到什么时候不得而知 表将来 will shall 将要，会 将来一般：I&#x2F;you&#x2F;she&#x2F;he&#x2F;it&#x2F;they + will(助动词表将来) + 动词原形 单纯表示动作发生在将来 or 助动词 be 的变位 + going to + 动词原型 将来进行：will + be(be 动词原形) + 动词现在分词 || I will be succeeding. 将来完成：will + have + 动词的过去分词 || I will have finished study next year. 强调将来的过去对将来的影响 将来 完成进行 时：will + have + 动词的现在分词 一般不常用： 过去将来·一般时：would(will 的过去式) + 动词原型 过去将来·进行时：would + be + 动词的现在分词 过去将来完成时：would + have + 动词的过去分词 过去将来·完成进行时：would + have + been + 动词的现在分词 组合详解 现在进行时：兔子正在吃萝卜 现在完成时：兔子已经吃完了胡萝卜指过去某个动作对现在的影响 I have done 我已经完成了 have：1. 实义动词 有 2. 助动词，构成时态 I&#x2F;you&#x2F;we&#x2F;they have -&gt; She&#x2F;he&#x2F;it has过去分词 + ed +en 现在完成时 VS 一般过去时现在完成时强调过去的事情对现在的影响一般过去时单独的指出过去曾经的事 现在完成进行时：对现在而言已经完成但还会继续。兔子现在已经吃完了胡萝卜，但还会继续吃。 现在一般时：对现在而言，没有特别指出的状态，陈述事实这兔子吃胡萝卜 表达事实，没有状态和时间的限制，客观实时 表达习惯&#x2F;重复的动作 表示预计发生的事 过去进行时这兔子昨天凌晨三点的时候正在吃胡萝卜。助动词 be 的变位 例句：一般过去时态 VS 过去进行时态一般过去时强调做了没有 -&gt; 图片过去进行时强调过去正在做的事情 -&gt; 视频 过去完成时这兔子昨天凌晨三点的时候已经吃完了胡萝卜过去完成时：过去的过去对过去的影响现在完成时：现在的过去对现在的影响 过去完成进行时：对过去而言已经完成了的但接下来还会继续的状态，到什么时候不得而知组成：例句： 过去一般时：简单的表示发生在过去的动作直接加动词过去式 将来进行时这兔子明天下午三点的时候会正在吃胡萝卜在将来某个时间，某个动作是进行的过程中比一般将来时还笃定组成：例句： 将来完成时这兔子明天下午三点的时候已经吃完了胡萝卜，之前什么时候开始吃不知道，也可能现在就开始吃了 。组成：现在完成时：强调过去对现在的影响将来完成时：强调将来的过去对将来的影响例句： 将来完成进行时这兔子明天下午三点的时候已经吃完了胡萝卜，但还要继续吃构成：例句： 一般将来时，单纯表示动作发生在将来英语中表达将来时态需要助动词 will 来帮忙 will + be&#x2F;have 全部原型特殊表将来的形式：will 形式：一般将来时态通常表达：动词的语气 过去将来 · 进行时例句： 过去将来完成时构成：例句： 过去将来 · 完成进行时构成：例句： 过去将来 · 一般时形式：例句：would 的多义： 时态总结：1. 时·态分离 2. 动词变形 (人称变位) 3. 助动词 4. 与其他语法概念混合 常用时态： 动词语气 Verb Moods 陈述语气（描述现实）祈使语气（命令&#x2F;请求）虚拟语气，基本用于从句中。表示某个描述与现实相反。涉及到动词变位。 表 “ 不可能 “ 的假设： 与现在相反条件句：过去式 如果是 be 就要用 were 无论什么人称 （一般过去）主句：would + 动词原型 （过去将来）If I were you,I would give this video a thumbs-up.如果我是你，我会给这视频点赞。言下之意：我不可能是你 If I am you. 与将来相反条件句：should （shall 过去时）&#x2F;were to + 动词原型 （过去将来）主句：would + 动词原型 （过去将来）If I should see the rabbit tomorrow,I would beat it.如果我 将会（shall 过去时） 明天见到这兔子，我就会打他。言下之意：我不可能明天遇到这兔子 与过去相反条件句：had + 动词过去分词 （过去完成）主句：would have + 动词过去分词 （过去将来完成时）If I had watched this video before,I would have aced my test.我要是之前就看了这视频，那绝对能考个好成绩。言下之意: 我之前没有看这个视频，考不出好成绩。 表达 愿望、请求、建议、命令：（希望每个动作&#x2F;事件 发生） wish v. 希望、祝愿 可能性小hope v. 希望 would rather 宁可，宁愿 + 虚拟语气 demand(要求) suggest(建议) insist (坚持) order (命令) + should + 动词原型 对 现在 的愿望：wish + 动词过去式 be 助动词全部用 wereI wish that I were a cat. I am a cat.我希望我现在是只猫。 对 过去 的愿望：wish + had&#x2F;would have + 动词过去分词I wish that I aced the carrot.我希望我吃了那只胡萝卜。言下之意：我没有吃那个胡萝卜，后悔啊。 对 将来 的愿望I wish that I could eat the carrot.我希望我 能够 吃那只胡萝卜。言下之意： 我多半吃不到那只胡萝卜，伤心啊。 非谓语动词谓语动词 可以表示动作的时间 状态、人称单复数，受主语限制，限定了动作的时态，也可以称为，限定性动词： 谓语动词 是句子的核心。 非谓语动词（非限定动词）：不受主语限制，不被限定的动词，但失去了谓语动词表达时间和人称的本领。 非谓语动词 出现在句子剩下的非核心部分。一个简单句只允许出现一个谓语动词。 动词不定式 infinitive infinite adj. 无限的不定式：不受时间、人称的限制 to + 动词原形 完全不定式 full infinitive不加 to 裸不定式 bare infinitive 动词不定式做主语 It 做形式主语 动词不定式做 宾语(likes 的承受者 to eat)The rabbit likes to eat carrots . it 做 形式宾语： 动词不定式做宾补和 复杂及物动词使用 使役动词：see find watch hava make let 后面用不定式做宾补需要 省略 to (前面的裸不定式)。 谓语动词 后接不定式，省不省略 to 区别不大，都是正确的表达。 不定式做主语主系表 结构 is 表赋值： 不定式做定语 定语后置to eat 做 后置定语，限定宾语，表示这些胡萝卜是要被吃的。 不定式做状语状语：修饰 谓语动词 表达原因、目的、结果 表原因 表目的 表结果 不定式做状语有简化从句的作用 高级不定式（不常考）to + 动词原形（完成 进行 完成进行），中的动词原形增加了 状态，后接助动词的原形。 只是表达了状态，实际还是不受时间（现在 过去 将来 过去将来）限制。 例句： 动名词动词 + ing 将 动词转换为名词 来使用。 名词在句子可以做的成分，动名词同样可以承担。 动名词做主语 动名词做主语补语（表语） 动名词做定语容易和现在分词做定语混淆。 动名词做宾语使役动词不能加不定式 to 做宾语 ，必须变为动名词 + ing 做宾语：介词 to 和 不定式 to 易混淆：介词 + 宾语（非谓语动词 动名词充当宾语，不能使用不定式 to） 动词不定式 to 和 动名词做宾语的区别：forget to do -&gt; 忘记去做forget doing -&gt; 忘记做过 现在分词现在进行时态 &#x3D; be + 现在分词 误区：不能因为是现在分词，而认为是表示现在时间的，非谓语动词没有时间变化。 现在分词 相当于一个 形容词 （用来修饰名词表状态），形容词在句子中可以充当的成分，现在分词 也可以。 现在分词 做 主语补语（表语 形容词）interest v. 使人感兴趣的 -&gt; 现在分词 interesting adj. 有趣的 现在分词做 宾语补足语现在分词做宾补 和 不定式做宾补 的区别： 现在分词 做 状语（表示谓语动词状态）表示 时间、原因、条件、结果、让步、目的、方式、伴随情况 过去分词误区：过去分词是 非谓语动词，他不能自带时间，不能表示过去的时间。 minced 不带时间概念，而只是 表示被姣的状态。 过去分词：动词原形 + -ed （看作形容词） 不规则过去分词： 过去分词 短语做定语，要放到被修饰的名词之后。后置定语 过去分词 和 现在分词 一样，可以做表语（主语补语）现在分词 暗含 主动 关系，即被描述的是 做出动作的人&#x2F;物体过去分词 暗含 被动 关系，即被描述的是 动作的接受者 过去分词 和 现在分词 一样，可以做 宾语补语（宾补）steal v. 偷 -&gt; stolen 过去分词The rabbit found his carrot stolen. 兔子发现他的胡萝卜被偷了。 过去分词 和 现在分词 一样，可以做 状语 （表示谓语动词的状态）现在分词 暗含 主动 关系，即被描述的是 做出动作的人&#x2F;物体过去分词 暗含 被动 关系，即被描述的是 动作的接受者高级用法：让句子中只含有一个谓语动词，其他的变成非谓语动词，用一个简单句写出来。独立主格 非谓语动词总结 过去分词 （被动&#x2F;完成） 现在分词（主动&#x2F;进行） 不定式（将要） 独立主格回顾：现在分词做 状语 独立主格： 独立主格对从句的简化：名词 + being + … 助动词助动词：辅助构成谓语，当自己本身不能单独作谓语动词的词，助动词除情态动词外无实义。 will 助动词帮助构成 将来时： can 是 情态 (助) 动词，辅助谓语动词表能力，也可以算是助动词，但是有实义，表 “ 能够 “ The rabbit can kill a wolf. 兔子能杀死一只狼 基本助动词be、do、have 做助动词时，无意义。做实义动词时：be(存在)、do(做)、have(有)可表时态、被动、强调 应用： be &#x3D;&gt; is&#x2F;am&#x2F;are&#x2F;was&#x2F;were have &#x3D;&gt; has&#x2F;had(过去) do &#x3D;&gt; does(强调&#x2F;否定) 情态助动词情态助动词是有实际含义的，但是不能单独做谓语动词。 can&#x2F;could 有能力做 &#x2F; 表请求或许可 &#x2F; 表可能性 may&#x2F;might 表请求或许可 &#x2F; 表可能性程度比 can 小 也许、可能、大概 &#x2F; 放在句首表祝愿表可能性程度比 can 小 也许、可能、大概放在句首表祝愿 must 表必须 &#x2F; 表禁止 &#x2F; 表推测 一定肯定 表必须： 表禁止： mustn’s 只有禁止的含义 表推测 一定肯定 只能用在肯定句里： will&#x2F;would 构成时态 构成时态： 表示请求、建议：表推测、假设 可能 would 比 will 程度更弱： shall&#x2F;should构成时态：征求意见：Shall we meet at 9AM.我们早上 9 点见面如何。 表警告命令：You shall not steal. 你不可偷盗 表有一定根据的推测：It should rain tomorrow. 明天 应该 会下雨 表 ”竟然“：It’s surprising that he should be late.真的很惊讶，他竟然迟到 构成虚拟语气：If it should rain tomorrow,I wouldn’t go.如果明天万一下雨，我就不去了 ought to 表示应该 need 表需要、有必要 dare 敢、挑战、冒险 used to 习惯做某事表示现在的动作，尤其是重复的动作，强调和现在对比。 半助动词例句： be able to 表能力 be going to 将要 &#x2F; be about to 马上 &#x2F; be to 被命令做某事 had better &#x3D; ‘d better 最好做 系动词系动词 的作用就是 编程中的赋值。 使役动词 使役动词后面要加宾语补语： 使役动词后接裸不定式，动词原形不加 to： 从句 Clause大宾语：宾语从句 复杂句：主句 + 从句（充当某种句子成分） 根据 从句充当的句子成分 给从句分类： 根据 从句充当的词性 给从句分类： 充当名词（名词性从句）： 充当形容词（形容词性从句）定语从句： 充当副词（副词性从句）状语从句： 形容词性从句（定语从句）为了方便下文统一称为 定语从句 对某个人或事物进行描述，具有形容词的性质。 思维方式差别： 中文：形容词（句子）+ 的 中文句子的定语都是 前置的 英文： 英文从句做定语都是后置的： 定语充当一个大形容词，补充、修饰、限定名词。 关系词关系词（引导词）用于引导定语从句： 分成：关系代词、关系副词 关系代词 that vs. which： 先行词是唯一的：that &#x2F; 先行词多选一：which 关系副词关系词是副词：where,why,when 关系副词 &#x3D; 介词 + which 限定性与非限定性定语从句 (形容词从句)非限定，接着补充，作为句子的插入语 非限定性定语从句做插入语，可以直接去掉，不影响句意。 名词性从句 (充当名词) 主语从句 从句改为不确定的信息： Whether,Where,When,How,Who,What 在疑问句中是：疑问代词或者疑问副词 在主语从句中属于连接代词、连接副词： 将主语从句放在句前，会导致主语很长，句子头重脚轻，可以通过形式主语 it 来改写： It is + XXX + that 也涉及到虚拟语气 宾语从句从句在整个复杂句中充当宾语（动作承受者） 确定信息做宾语从句宾语从句中 that 可选 不确定信息做宾语从句 否定加在谓语动词前，而非从句中 宾语从句要和主句的时态保持一致 Be + 形容词 + that 固定句型应该属于 宾语从句，其中的形容词通常表达某种看法或者判断，而 that 引导的从句相当于 看法&#x2F;判断。和动作后加承受者很相似，可以做宾语。 表语从句主 + 系 (be) + 表 (主语补语) 结构 从句充当表语： 表语从句，系动词不是 be 动词的情况： 同位语从句同位语：用不同的方式把同一个概念再说一遍，用逗号隔开。 同位语从句： 这样的从句常在句中修饰抽象的名词，因为抽象，才需要用另一种方式再说一遍。 同位语从句充当 idea 的宾语，是宾语的同位语 宾语补语从句主 + 复杂及物动词 (谓语动词) + 宾语 + 宾语补语 call,make,consider… 副词从句 (状语从句)为了方便，下文统一称 状语从句 状语在句子充当一个大副词的作用，补充说明谓语动词、形容词的各种状态。 做状语，在句子起补充信息的作用，有多种可能。所以副词从句（状语从句）的种类繁多。 时间状语从句 在某一个时间点之前，引导词 before 在某一时间点之中（当时）引导词：when(时间点，“突然”)while(一个时间段)as(同时进行两个动作) 在某个时间点之后，引导词 after 从之前某一个时间点开始算起，引导词 since往往暗示了对之后有影响，在时态一节提到过这样的情况一般要使用 完成时态。 直到之后某一时间点 引导词 until (有点像 since 的对立面)从某一时间点算起，直到之后的某一时间点 一…就… 引导词：as soon as the next time 下次 地点状语从句引导词：where + “ 强调形式 “(wherever,everywhere,anywhere) 与表地点的定语从句区别： 强调形式： wherever 不管哪里、everywhere 强调所有的地方、anywhere 强调任何地方 比较副词从句英语的形容词有所谓的比较级，比如： 上面的句子相当于省略句，实际上都是副词从句，用比较的方式对前面的主句进行补充说明。 条件状语从句 (条件句)条件句，主将从现，主句用将来时，表示这种条件成立，明确在将来会发生的动作，用一般将来时；从句用一般现在时，表示 一般 的状态，和现在没关系，不包含时间信息： 从句总是比主句落后一个时间段 容易与虚拟语气表不可能的假设混淆： 从句总是比主句落后一个时间段： 其他引导词 unless 除非，如果..不 将 if 反着说： provided(如果 假如),as long asI 只要),in case(如果 万一) 让步副词从句 即使&#x2F;就算 … 也 … though&#x2F;even though&#x2F;Although 尽管 虽然 No matter + 疑问句 表未知情况，不管如何： no matter &#x3D; regardless (regard 注意) 方式副词从句方式状语从句主句是事实发生的，而在条件状语从句的虚拟语气中，主句是没有发生的。 就好像： as if you 不表假设，表正在发生的某种形式： 原因&#x2F;目的&#x2F;结果 状语从句共同点在于都是 “表示了某种因果” Because 因为 Sine 既然，不是时间状语从句从某个时间点开始的意思，而是介绍某个原因： as 表原因，不是 …像 区别： 目的状语从句 从句一般用情态助词表目的性： 结果状语从句： 表达结果 so that： 介词 preposition牛津词典统计的最常用英语单词： 目录： 介词定义介词是放在名词、代词，等词之前用来跟他们增添“附加信息”的词。本质是前置词，和后面的信息构成关系。 介词构成形式 简单介词：in on at with 短语介词：（视作介词，不单独表达完整意思） 合成介词 分词介词 介词学习误区不能将介词和中文一一对应，因为介词有很多引申义。 比如 by 就有很多个意思： 介词学习技巧 about: on:in： 介词的含义可能看上去毫不相干，但都是从根源的，有着空间性的含义引申出来的。 某些介词很容易混淆，需要用其空间含义去推导记忆（追本溯源） in、on、at： 引申到时间： 英语常见介词的用法 over 往往特指正上方above 只需要 “高出” 就行 区别： 区别：because of &#x2F; because 介词宾语 被动语态 被动语态构型：be(根据人称时态进行变位) + 过去分词by + 动作执行者 5 种基本句型变被动语态： 过去分词表被动，与被动语态有很大关系： 非谓语动词做表语（主语补语） 也可以改成被动语态： 主语 + 复杂及物 + 宾语 + 宾语补语 动词不定式做宾语补语改被动： 与时态、情态动词等结合的复杂被动语态： 名词分为专有名词和普通名词 单数名词和复数名词 可数名词和不可数名词 名词所有格名词宾格主格格：为了反映某个词在句中的语法功能，“主格”在句子充当主语，“宾格”在句子充当宾语。 Rabbit 充当主语，用主格加 “s”; carrot 充当宾语，用宾格加 “s”. 名词所有格‘s 在有生命的人或动物之后表所有权 所有格，通常表示所有、所属关系而存在的： 表示共有： 表示各自： of 构成所有格，用来描述所修饰名词的性质特征，只是顺序要颠倒一下： 双重所有格a photo of Michael’s. M 拥有的照片中的一张a photo of Michael. M 出镜的照片之一 代词pro(代替)|noun(名词) 替代名词的词 人称代词人称代词的格： 人称代词主格宾格： 常见疑问 物主代词my：形容词性物主代词，充当一个形容词的作用： mine：名词性物主代词，代表 my carrot： 总表： 反身代词 强调代词 相互代词We should help each other. each other：两者之间one another 三者之间&#x2F;三者以上之间 指示代词this these that those： 不定代词 many;much 许多很多many + 可数名词的复数much + 不可数名词 few little some(肯定句) any(否定句) each every 表示每，后接单数each 两个以上的每一个 every 3 个以上的每一个 either 两者中的每一个 neither 两者中的每一个都不谓语用单数形式 both all 都 全部做主语，谓语动词都要用复数 other &#x2F; the other &#x2F; another 另外的，另一个 复合不定代词 疑问代词什么、谁、什么时候… 连接代词引导主语从句、宾语从句、表语从句 who+ever 表示 “任何、一切” 的意思，起强调作用： The rabbit wants to eat whatever he likes.兔子想吃他喜欢的任何东西 关系代词关系代词专用于定语从句（补充说明名词，充当一个大形容词） 副词副词修饰动词(形容词)，起 状语 限定句子谓语动词状态的作用 副词的用法 副词修饰句子： 副词修饰的词性： 冠词a an the 不定冠词 a&#x2F;an看单词开头时候为 元音音素 例如：a university &#x2F; an hour. 泛指用法不定冠词最重要的用法是泛指某一个人或物。 泛指某一类人的情况： 表示数字 1 主谓一致不定冠词还能影响主语的单复数，从而影响句意。 固定表达 定冠词 the有两种发音 特指定冠词的主要用法就是特指，表示某个或某些特定的人或物，也就是，说话者和听话者都知道在讨论啥。 再次提到某个人或物体，即双方都清楚说的是谁或者什么，就要用定冠词 the。 用于在 序数词 和 形容词的最高级 前。序数词 和 最高级 限定了范围，所以也是特指。 在独一无二的专有名词前the sun &#x2F; the moon &#x2F; the earth &#x2F; the Great Fire Wall 西洋古典乐器the 少数情况下表泛指： 西洋古典乐器、 表示一类人在形容词前，the + 形容词，特指表示一类人： 固定表达： 零冠词零冠词是指 名词前不用冠词 的情况，主要作用是泛指： 零冠词复数泛指 不可数名词保持原形，也表示 零冠词复数泛指： 泛指“概念”这里的概念是脑中形成的观念，是一种 抽象意义 的表达，这种概念性的名词前多会使用零冠词： 学科、季节、星期、月份等… 抽象概念 专有名词专有名词前一般都是零冠词： Papa Rabbit ，Python , Hongkonger 固定表达 out of a question 不可能，表否定。out of question 毫无疑问 总结"},{"title":"2024 春季高考小高考语文必背篇目","date":"2023-11-02T11:13:45.000Z","url":"/study/2024-spring-exam-chinese/","tags":[["Chinese","/tags/Chinese/"]],"categories":[["Study","/categories/Study/"]],"content":"2024 春季高考小高考语文必背篇目Capital 逍遥游（北冥有鱼……之二虫又如何） 劝学（学不可以已…..用心躁也） 师说 赤壁赋 氓 《归园田居》 蜀道难 登高 琵琶行 锦瑟 念奴娇 赤壁怀古 声声慢 永遇乐 京口北固亭怀古 园春 长沙 短歌行 梦游天 阿房宫赋 子路。。。 六国论 逍遥游 周庄 先秦北冥有鱼，其名为鲲。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天，而莫之夭阏者，而后乃今将图南。蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！ 劝学 荀子 先秦···君子曰：学不可以已。 青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。 故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。 吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。(君子生 通：性) 南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。 物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蜹聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！ 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。(江海 一作：江河)"},{"title":"英语零基础学习记录 Record 系列 —— 如何记忆单词 How to memorize words","date":"2023-10-29T13:10:04.000Z","url":"/english/english-from-zero-tutorial-memorize-words/","tags":[["English","/tags/English/"],["Study","/tags/Study/"],["GK","/tags/GK/"]],"categories":[["English","/categories/English/"]],"content":"英语零基础学习记录 Record 系列 —— 如何记忆单词 How to memorize words前言日常开发中经常碰到很多纯英文没有翻译的技术文档，使用 Google Translation 又比较 Low，所以需要大量的背单词。 在中国的传统应试教育下，笔者从小学到高中都是死记硬背，即一个个字母的拼写单词，早读也是一个个字母的拼读，这种方式效率低下，而且忘了又记，记了又忘。后面笔者干脆摆烂不记了，英语考试时看阅读题还看着看着睡着了。 学会音标，会根据单词表的音标正确的把单词拼出来。 掌握 词根词缀构词法，使用其背单词。 大量的背单词，推荐 APP：墨墨背单词，用一个笔记本写出单词的词根词缀、变形、联想记忆等 Reference 引用 英语兔 高考 3500 词汇：全网最好的”高考英语3500单词”合集 (附下载链接) 英语兔 英语构词法 背单词加速器：英语构词法 (背单词必备) 求助，怎样高效背单词？ - 注入爱的文章 - 知乎  BiliBili 八哥 词根词缀：&lt;词根词缀&gt; 12大前缀+3大词性后缀_哔哩哔哩_bilibili 音标工具英语词根词缀 源于英语的派生构词法 un | believ | able adj. 难以置信的 前缀 &#x3D;&#x3D;&gt; 词向 （词语的方向 反义、否定等） un 否定 词根 &#x3D;&#x3D;&gt; 词意（词语的意思）believe 相信 后缀 &#x3D;&#x3D;&gt; 词性 （词语的性质 形容词、副词、名词等）able 形容词后缀 欧路词典词根词缀查询 MDX 词典：扩充词库下载 | 欧路软件官网 前缀 （词向） 外&#x2F;出：e/ex/ef &#x3D;&gt;export 出口 内&#x2F;进：in/im &#x3D;&gt;inject 注射 import 进口 前 动态 – 向前 ：pro &#x3D;&gt; progress 进步 promise v. 保证 静态 – 在前&#x2F;预先 ：pre &#x3D;&gt; prepare 准备 premise v.&#x2F;n. 作..前提 present 礼物 回&#x2F;重新&#x2F;再次&#x2F;反向：re &#x3D;&gt;return 返回 reduce 减少 reply 回复 聚集 (一起&#x2F;共同)：co/con/com/col &#x3D;&gt;connect 连接 collect 收集 contact 联系 分散 (分开)：di/dis/dif &#x3D;&gt;distract 分心 divide v. 使分开 dissident 异意分开 se &#x3D;&gt; separate 分开 上&#x2F;超过：super/over/sur &#x3D;&gt;sur·real·ism 超现实主义 surpass 超过 surface 表面 surprise 惊奇 survey 调查 下&#x2F;不足：under/de/sub/sup &#x3D;&gt;decrease 下降 depress v. 使沮丧 detect v. 察觉 subway 地铁 suppose 认为 suppost 支持 转移&#x2F;转变：trans &#x3D;&gt;transfer 转移、转账、换乘 translate 翻译 相互之间：inter &#x3D;&gt;internet 互联网 interview 采访 interest n. 兴趣 a+ 双写辅音字母&#x3D;强调&#x2F;无意义 &#x3D;&gt;accompany v. 伴同 accord n. 一致 否定前缀：un/in/im/dis/ab/il 表示数量：poly/multi - 多 反对相反：anti/opoppose v. 反对 opposite adj. 方面 anti-censorship 反审查 ab,ac,ad,af,ag,al,an,ap,ar,as,at 来自拉丁介词 ad, 表示“朝、向、去，或弱化为强调”。 anti 反对，相反 anti-censorship 反审查 co&#x2F;col&#x2F;com 一起 de 否定，除去，向下 dis 不，除去，分开 ex 外，前任 fore 前，先，预先 in&#x2F;im 不，向里 inter 在…之间 mis 错 out 超过，外 over 过度 post 后 数字类 mono-1 &#x2F; bi、di-2 &#x2F; tri-3 &#x2F; hemi、semi - 半 &#x2F; Poly- 多 &#x2F; multi- 多 后缀（词性）V.动词后缀 -ate 表动词，” 做，造成 “create v. 创造 separate v. 分开 -ise/-ize 动词后缀，一般缀于形容词后。-ise 是英式英语，-ize 是美式英语practise v. 练习 surprise v. 使惊奇 modernize v. 现代化 exercise v. 锻炼 advertise v. 宣传 industialize v. 使工业化realise v. 实现 -fy/-ifybeautify v. 美化 unify v. 统一 magnify v. 放大 夸大 notify v. 通知 signify v. 表示 satisfy v. 使满意的 -ishabolish v. 废止、废除 nurse -&gt; nurish v. 培养 Adj. 形容词后缀 名词转形容词：n. &#x3D;&gt; adj. -ed(过去分词)/-ful(充满)/-ish(类似)/-ly(似的)/-y/-al[kl]/-ial[ʃl]/-ic/-ous[ə] -ed 过去分词做形容词 (表已经完成的状态)pointed adj. 语言尖锐的 satisfy v.使满意的 &#x3D;&gt; satisfied adj. 感到满意的advance n. 发展 -&gt; advanced adj. 高级的 marry v. 结婚 &#x3D;&gt; married adj. 已婚 -ful (充满)useful adj. 有用的 successful adj. 成功的 -al[kl]/-ial[ʃl]practice n. 练习、实习 &#x3D;&gt; practical adj. 实际的history n. 历史 &#x3D;&gt; historical adj. 历史的 person n. 人 &#x3D;&gt; personal adj. 个人的influence n. 影响 &#x3D;&gt; influential adj. 有影响的race n. 种族 &#x3D;&gt; racial adj. 种族的 special adj. 特别的nation n. 国家 &#x3D;&gt; national adj. 国际的 -ous[ə]humor n. 幽默 &#x3D;&gt; humorous adj. 幽默的nerve n. 神经 &#x3D;&gt; nervous adj. 紧张的fame n. 名望 &#x3D;&gt; famous adj. 著名的victor n. 胜利者 &#x3D;&gt; victorious adj. 胜利的obvious adj. 明显的 -less 表无、没有harm n. 伤害 &#x3D;&gt; harmless adj. 无害的helpless adj. 无用的 -ic fantast n. 幻想家 &#x3D;&gt; fantastic adj. 极好的 dramatic adj. 戏剧性的 electric adj. 电的 electronic adj. 电子的 动词转形容词：v. &#x3D;&gt; adj. -ble/-able/-ive 可、能够 -ble/-ableterror n. 恐怖 &#x3D;&gt; terrible adj. 可怕的possible adj. 可能的drinkable adj. 可饮用的 -iveexpend v. 花费 &#x3D;&gt; expensive adj. 昂贵的attract v. 吸引 &#x3D;&gt; attractive adj. 吸引人的relate v. 有关 &#x3D;&gt; relative adj. 相对的&#x2F;亲戚sense v. 意味、意识到 &#x3D;&gt; sensitive adj. 敏感的 表示 ….的 ent/ful/lve/ible/able/ant/ic/ry -entconvention n. 大会 &#x3D;&gt; convenient adj. 方便的appear v. 出现 &#x3D;&gt; appearent adj. 明显的 -antimport nv. 进口 &#x3D;&gt; important adj. 重要的sign n. 标志 &#x3D;&gt; signify v. 表示..的意思 &#x3D;&gt; significant adj. 重要的 Adv. 副词后缀形容词转副词：adj. &#x3D;&gt; adv. 通常加 ly结尾 ic + ally dramatic adj. 戏剧性的 &#x3D;&gt; dramatically辅音 + y ，去 y 为 i +ly happy adj. 高兴的 &#x3D;&gt; happily N. 名词后缀 形容词转名词：adj. &#x3D;&gt; n. -ty/-ity/-lty/-ness -ity/-bility 抽象名词后缀electric adj.电动的 &#x3D;&gt; electricity. n. 电力national adj. 国际的 &#x3D;&gt; nationality n. 国籍real adj. 真实的 &#x3D;&gt; reality n. 现实 &#x3D;&gt; realise v. 实现possibility n. 可能性 visibility n. 能见度honor n. 信用 &#x3D;&gt; honest adj. 诚实的 &#x3D;&gt; honesty n. 诚实 nesshappiness n. 幸福 usefulness n. 有用 carelessness n. 粗心 business n. 生意 商务 liveliness n. 活力 动词转名词：v. &#x3D;&gt; n. -sion/-tion/-ation/-ment satisfy v.使满意的 &#x3D;&gt; satisfaction n. 满意 &#x3D;&gt; satisfied adj. 感到满意的 decide v. 决定 &#x3D;&gt; decision n. 决心 advertise v. 宣传 &#x3D;&gt; advertisemeant n. 广告 lon&#x2F;tion&#x2F;ation&#x2F;ness&#x2F;ity&#x2F;ality&#x2F;meant&#x2F; ence 表状态 &#x2F;ance&#x2F;ism&#x2F; -ice (行为状态) -ice 表行为状态practise v. 练习 &#x3D;&gt; practice n. 实践serve v. 服务 &#x3D;&gt; service n. 服务 -ence 表状态audio adj. 听觉的 &#x3D;&gt; audience n. 听众expert n. 专家 &#x3D;&gt; experience n. 经验influence n.&#x2F;v. 影响 -ure[/ər/]advent n. 来到 &#x3D;&gt; adventure n. 冒险please v. 请 &#x3D;&gt; pleasure n. 快乐pressure n. 压力 &#x3D; stressculture n. 文化 nature n. 自然 treasure n. 财富picture n. 图画 secure n. 安全 temperature n. 温度 signiture n. 签名future n. 未来 feature n. 特点 更多后缀： able（形 能…的 具有…性质的 al（形 具..性质的，属于..的 （名 抽象名词，人 ate（动 做，造成 （名 人 ed（+ 形名词后 有…的 （+ 动后 已…的，被…的 en（动 使变成 ence（名 抽象名词 ful（形 富有…，具有…性质的 fy（动 使变成… ic（形 …的 ion（名 抽象名词 ism（名 …主义，流派，特性 race n. 种族 &#x3D;&gt; racism 种族主义 heroism n. 英雄主义 capital n.首都 &#x3D;&gt; capitalims n. 资本主义 ist（名 人，…家 ….主义 pythonista n. python 爱好者 ive (形 有…性质的&#x2F;作用的 ize(动 …化 less(形 无…的 meant(名 行为的过程或结果，物 ness(名 抽象名词 ship(名 情况，身份，资格 ward(形&#x2F;副 向…的，朝… y(形 多…的，有…的 -age 语言 language n. 语言 -ent 表人 president n. 总统 -um 表场所 museum n. 博物馆 medial adj. 中间的 media n. 媒体 medium n. 媒介 social medium 社交软件 词根（词意） ced&#x2F;cess&#x3D;go 行走 cid&#x2F;cis&#x3D;cut,kill 切，杀 claim&#x3D;cry,shout 喊叫 clud&#x3D;close 关闭 duc&#x2F;duct&#x3D;lead 引导 fer&#x3D;bring,carry 带，拿 ject&#x3D;throw 投掷 migr&#x3D;move 迁移 pend&#x2F;pens&#x3D;hang 悬挂 pay 花费 pos&#x3D;put 放置 rupt&#x3D;break 破 spect&#x3D;look 看 tract&#x3D;draw 拉，拽 vert&#x2F;vers&#x3D;turn 转 vis&#x2F;vid&#x3D;see 看 viv&#x3D;live 活 "},{"title":"Use GiffGaff SIM card in China","date":"2023-10-26T14:00:34.000Z","url":"/giffgaff-britain-sim-card-in-china/","tags":[["GiffGaff","/tags/GiffGaff/"],["SIM","/tags/SIM/"]],"categories":[["GiffGaff","/categories/GiffGaff/"]],"content":"Use GiffGaff SIM card in ChinaIntrodutiongiffgaff 是来自英国的一家新锐低成本运营商，隶属于英国三大运营商 O2 旗下，2009 年创立，采用了无营业网点，无热线客服，灵活套餐的特色服务来降低用户成本，特别适合短期游客及英国留学生。它支持全球漫游，在中国也可收发短信，接听电话和上网。 为什么选择英国 giffgaff SIM 卡？ 性价比高：0 月租，免费接收短信，充值一次，接码可以用 20 年以上（仅需半年保号一次），可能是国内性价比最高的接码实体卡！ 安全：实体卡无须担心因号码被风控，还可以换 2 次号码，比 Google Voice 整天被风控来的好用 漫游：支持中国大陆激活及漫游 稳定性高：无限有效期，每半年发一条短信即可保号 兼容性好：支持绝大部分海外 APP&#x2F;应用&#x2F;银行，例如 TikTok&#x2F;Twitter&#x2F;Facebook&#x2F;Instagram&#x2F;LINE&#x2F;WhatsApp&#x2F;Telegram 等等，ChatGPT3.5&#x2F;4.0 ，苹果 ID ，Amazon ，PayPal ，花旗，渣打，巴克莱，德意志银行，瑞士银行，还有一些新出现的虚拟信用卡等等 Q&amp;AQ：官网申请到的空白卡里有话费吗？A：没有，收到卡后按照教程自助激活。 Q：充值送 5 磅话费的福利一直有吗？A：直接官网在线申请的，目前此项福利已经取消。可以通过朋友邀请链接申请才有，或者自行购买。不激活不充值是没有的哦，超时充值也有可能没有错过福利哦。 Q：月租多少钱？A：若和我一样，主要是用来接码，建议选择 0 月租的 Pay As You Go 套餐，充多少用多少，TB 或 JD 上卖的都是针对游客的短期月租套餐卡，不合适长期使用。如果您需要前往海外，只需到官网上调整您的套餐即可。 Q：如何保号，成本多少？A：这种 0 月租的卡一般都有保号要求，giffgaff 要求每 180 天话费余额需要变动一次，否则号码会被回收。在国内，最低成本就是发出一条短信，发送对象是国内外手机号码均可以，每条 0.3 磅，因此一年消费 0.6 磅，仅仅不到 6 元人民币。每次话费余额变化后，例如充值，消费，保号周期重新开始计算。首次充值，也属于余额变动，因此在 180 天内完成保号即可。 Q：收短信免费吗，其他费用如何？A：收短信免费，打电话&#x2F;接电话&#x3D;1 英镑&#x2F;分钟，发短信&#x3D;0.3 英镑&#x2F;条，上网&#x3D;0.2 英镑&#x2F;MB Q：首次自助充值激活需要准备什么？A：请准备一张 VISA 或万事达的外币实体信用卡或借记卡，国内发行的也可以，单银联、JCB 、AE 等信用卡以及任何虚拟信用卡均无法使用哦，充值最低 10 英镑起，请确保您的卡额度足够。特别提醒，首次充值不支持 PayPal ，以后续费可以使用。 Q：插卡后没信号A：由于海外运营商与国内运营商之间的漫游对接有很多环节和验证过程，耐心等待 1-5 分钟， 就会出现。 Q：我的卡号是多少A：首次插卡，会收到一条激活成功的提示短信，内有您的手机号码，后面也可以登录官网查询。 Q：手机号码正确，无法登录官网或软件提示号码格式不对A：英国国际区号 (United Kingdom) 是 +44 ，有时候也用 0044 表示，输入时候要选择正确区号。 Q：为什么我的卡无法拨打电话，无法发短信？A：可以在手机设置里取消 运营商自动选择 ，改为手动选择到中国移动，并重启手机后再尝试 Q：支持哪些手机？信号如何？A：支持目前所有主流手机，gg 卡是 FDD-LTE 制式，除了极少数电信 CDMA 3G 手机不支持，其他均无问题。它在国内默认通过中国移动或中国联通进行漫游，还支持 5G ，通话质量，数据质量，覆盖范围非常不错。 Q：苹果手机使用上有什么注意事项？A：不建议打开 iMessage&#x2F;Facetime 功能，因为如果点击确认，苹果后台会发出一条短信，因此会被扣费 0.3 磅。由于国内短信价格很低，很多人都是套餐里送的，所以不知道有这么一个短信发送的过程。 giffgaff 常用功能 首次充值激活： 登录个人账户&#x2F;重置密码： 查询话费余额&#x2F;SIM 号码： 续费充值： 话费账单查询： 个人资料修改： 申请换号：  （一般在被 app 封号后建议用，有 2 次额度） 查询 SIM 号码：发送 [ NUMBER ] 到 43430查询话费余额：直接拨打 [100#]关闭语音信箱：直接拨打 [##002#]打开语音信箱：直接拨打 [*61443*1020#] 第 1 条附言 · 48 天前 接着讲讲我在使用 giffgaff （ gg ）卡注册各类 app 遇到的坑 Q：为什么收不 Telegram 电报的验证码？A：请使用 Telegram 移动端申请注册，网页端及电脑客户端是不行的。如果还不行，大概率是因为你使用的是国内阉割版的安卓手机，TG 的安卓版需要手机系统内置谷歌服务框架 GMS 软件包才能收到验证码，建议更换苹果手机，或者带 GMS 服务的安卓手机，具体请百度谷歌查询。 Q：为什么收不到 Line 的验证码？A：Line 近期已经加强了防欺诈能力，无论你用什么运营商的海外号码申请注册，凡是通过机场&#x2F;VPN 这种共享 IP 来使用，大概率会被识别出来，看似没有任何报错，就是收不到验证码。解决方案是开启 gg 卡自带的漫游上网来完成所有注册流程，同时建议暂时关闭其他 App 的网络访问，避免消耗流量。 Q：为什么收不 Tik Tok 国际版抖音的验证码？A：确保您的卡和 App 在同一部手机，其次确保手机里就一张 gg 卡，国内卡不能同时存在，最后建议更换 VPN 或机场线路，比如切换到美国&#x2F;日本&#x2F;新加坡&#x2F;英国等地，港台线路容易受污染。 第 2 条附言 · 14 天前 给各位 giffgaff 用户带个喜讯，手机支持 eSIM 的话，giffgaff 在 2023&#x2F;10&#x2F;11 正式官宣开放实体卡转 eSIM 啦 官方介绍 省流 TIPS：① 仅支持实体卡转 eSIM ，所以初次用户还是要弄张 giffgaff 的卡② 需要有 eSIM 功能的手机，卡槽里有 giffgaff 实体卡，通过 giffgaff 官方 app 操作，所以没有实体卡槽的美版苹果，貌似不行③国内漫游环境下，三星、谷歌 Pixel ，苹果手机均可以，转移到 eSIM 后，有人几十分钟就收到信号，也有人几小时，官方承诺不超过 24 小时 第 3 条附言 · 7 天前 做了一个简单的公众号：GEEK World ，分享在国内使用 gfiigaff 的各种经验与心得，争取未来保持周更的节奏，欢迎大家关注！ Useful官方免费服务功能清单：查询自己号码：发送短信「NUMBER」到 43430查询话费余额：直接拨打「***100#」关闭语音信箱：直接拨打 「##002#**」打开语音信箱：直接拨打「**61443*1020#**」默认 PIN：5555 or 6666 官网常用功能清单：新卡激活：登录个人账户&#x2F;重置密码：查询话费余额&#x2F;SIM 号码：续费充值：账单查询：资料修改： 码申请：申请换号： （一般在被 app 封号后建议用，有 2 次额度）换 SIM 卡：（保留老号与话费） Reference TG Channel：Telegram: Contact @Giffgaff_China "},{"title":"Vue3 项目脚手架搭建和运行指北","date":"2023-10-11T08:20:06.000Z","url":"/javascript/vue-project-start-tutorial/","tags":[["JavaScript","/tags/JavaScript/"],["JS","/tags/JS/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["Vue3","/tags/Vue3/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 项目脚手架搭建和运行指北本指南带你从 0 到 有 的编写一个 Vue3 项目的脚手架，解剖完整的 Vue3 项目结构和各种配置文件，并手把手教你配置 VSCode 达到最高效率，运用到以下技术： NodeJS TypeScript – JS 的超集，添加友好的类型提示和更多功能 Vscode – 地表最强写 Vue3 IDE pnpm – 比 npm 更好的包管理工具 Vite /vit/ – Vue3 构建、打包工具，比 webpack 更好 Axios – Promise 异步请求库 Pinia – vue3 全局状态管理 ElementUI – Vue3 UI 组件库 Vueuse GitHub - vueuse&#x2F;vueuse: Collection of essential Vue Composition Utilities for Vue 2 and 3 – Vue3 composition API utils Vue3 组合式 API 工具集 Babel – 编译适应多个平台的 JS Babel 的使用 Install NodeJS、TypeScript、pnpm、vite安装 NodeJS(默认)，安装 TypeScript，换成 pnpm 包管理工具，安装 Vite 打包工具。 Vscode IDE安装以下 extension： Vue Language Features (Volar) Volar – Vue3 支持 TypeScript Vue Plugin (Volar) Volar – TS 支持 Auto Close Tag – 标签自动合并 Auto Rename Tag – 标签自动修改 EditorConfig for VSCode – editorconfig code rule Prettier for VSCode – prettier .prettierrc code rule ESLint for VSCode – ESLint VSC 支持，需要安装 ESLint package Create Vite Framework选择 ts vue3 技术栈 Set vite.config.ts&#x2F;tsconfig.jsonPath alias 路径别名vite.config.ts： reference: javascript - `Vue3 - Vite` project alias src to @ not working - Stack Overflow tsconfig.json TS 配置 Code rule 代码规范规范先行：【vue3-element-admin】ESLint+Prettier+Stylelint+EditorConfig 约束和统一前端代码规范_有来技术的博客-CSDN 博客 .editorconfig.editorconfig：这个文件的作用是强制编辑器以该配置来进行编码，比如缩进统一为空格而不是 Tab ，每次缩进都是 2 个空格而不是 4 个等等。 VSCode 需要安装 EditorConfig for VSCode 扩展 。 Prettier [英 &#x2F;‘prɪtɪ&#x2F; 漂亮].prettierrc 配合 VSCode 的 VSCode Prettier 扩展，可以在编辑器里使用该规则格式化文件。 ESLint (MAIN)ESLint 是一个查找 JavaScript &#x2F; TypeScript 代码问题并提供修复建议的工具，换句话说就是可以约束的代码不会写出一堆 BUG ，它是代码健壮性的重要保障。 这里以一个 Vite + TypeScript + Prettier 的 Vue 3 项目为例，在项目根目录下创建一个名为 .eslintrc.js 文件，写入以下内容： pnpm 安装对应的依赖 dependents： 排除检查：.eslintignore Auto import 自动导入Install Module Modify config filevite.config.ts： .eslintrc.cjs tsconfig.json SCSS 一款 CSS 预处理语言，SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。 Environment variate项目根目录新建 .env.development 、.env.production 开发环境变量配置：.env.development 生产环境变量配置：.env.production 环境变量智能提示 新建 src/types/env.d.ts 文件存放环境变量 TS 类型声明。 Vue3-router 路由reference: 安装 | Vue Router install： 修改 main.ts 文件： Import 导入建立 src&#x2F;router 目录，放 index.ts(入口文件) routes.ts (路由文件)。 src&#x2F;router&#x2F;index.ts src&#x2F;router&#x2F;routes.ts Pinia 全局状态管理Install src&#x2F;main.ts Stores Foldersrc&#x2F;stores&#x2F;index.ts 使用 storeToRefs 将 store 变为响应式，只需要导出文件的 config 即可。 Element UIInstall 按需要引入，安装在开发环境中： 修改 vite.config.js： Importsrc&#x2F;main.ts 封装一个 Element UI 的 noticesrc&#x2F;utils&#x2F;notice.ts Axois 请求库 Axios 基于 promise 可以用于浏览器和 node.js 的网络请求库 Install Axios 工具类封装src/utils/request.js 初始化 axios instance 实例，包含异常处理等： 高级封装： src&#x2F;plugins&#x2F;api.ts 具体请求： Vueuse起步 | VueUse 中文文档 Install Reference CSDN 博文：Vue3.3 + Vite4.3 + TypeScript5+ Element-Plus：从零到一构建企业级后台管理系统（前后端开源） "},{"title":"RFS 安卓模拟飞行 Tutorial 教程","date":"2023-10-01T12:57:46.000Z","url":"/rortos-flight-simulation-tutorial/","tags":[["飞行","/tags/%E9%A3%9E%E8%A1%8C/"],["Flight","/tags/Flight/"],["模拟飞行","/tags/%E6%A8%A1%E6%8B%9F%E9%A3%9E%E8%A1%8C/"],["RFS","/tags/RFS/"],["航空爱好","/tags/%E8%88%AA%E7%A9%BA%E7%88%B1%E5%A5%BD/"]],"categories":[["Flight","/categories/Flight/"]],"content":"RFS 安卓模拟飞行 Tutorial 教程Rortos-Flight-Simulation [/ˌsɪm.jəˈleɪ.ʃən/ n. 模拟] -Tutorial RFS 是一款运行在安卓手机端的模拟飞行应用，可能是安卓上最好的呢，适合买不起高配置的显卡和电脑的手机党使用。 Install 配置 在此链接下载正版的 rfs，不要打开 123pan.com&#x2F;s&#x2F;qDuLVv-wMFed.html 安装通用 Google Framework  之后下载这个在这里边导入刚刚下载的本体 ，会显示更新 更新完成之后登录 Google Account。 登录之后在设置账户里点一下谷歌授权 就可以玩耍了 Translation 配置翻译主界面​​ 地面服务系统​​ 主警报系统​​ 地面装载​​ 自动驾驶​​ 地面绕机检查​​ 主系统​​ 飞行检查单​ 引擎​​ 地面紧急服务​​ 燃料系统​"},{"title":"各种路由器折腾日记","date":"2023-10-01T12:57:46.000Z","url":"/router-experiment/","tags":[["OpenWRT","/tags/OpenWRT/"],["Router","/tags/Router/"],["路由器","/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"],["宽带","/tags/%E5%AE%BD%E5%B8%A6/"]],"categories":[["Router","/categories/Router/"]],"content":"各种路由器折腾日记CR8808CR8808 是红米 Redmi AX3000 路由器的移动定制款, 支持 WIFI6 各种性能都还不错, 主要是方便折腾. Reference 恩山论坛: [红米AX3000&#x2F;CR8809&#x2F;CR8808&#x2F;CR8806] 一站式刷机终结贴【红米AX3000&#x2F;CR8809&#x2F;CR8808&#x2F;CR8806&#x2F;CR880X】23.11.30 source Tutorial链接: 提取码:9svo TTL模块连线,配置TTL环境(下文均默认已配置好TTL环境) CR880X刷红米AX3000 CR880X刷OpenWrt 已刷openwrt强刷红米AX3000官方固件 一: TTL模块连线,配置TTL环境,固定uboot中断1.1: CH340将RX TX GND这三个角连接到你的主板对应阵脚上(可自己焊接,可以临时插针)CH341把编程器TTL排针12脚的跳帽接到23脚,这样就从编程模式切换到了USB TO TTL,继续将RX TX GND这三个角连接到你的主板对应阵脚上(可自己焊接,可以临时插针) 1.2将ch340&#x2F;ch341插上电脑主板的USB口,机箱前置的USB可能供电不足导致意外,如果没有自动安装驱动,在控制面版-设备管理器-未知设备中可以看到,解压我提供的CR880X包,使用对应文件安装驱动,安装好驱动就可以看到在设备管理器中已经被识别了.记住你的COM口我的这个是COM51.3右键对应你设备名称的设备,在这里修改下波特率,数值为115200,(可提前解除不跑码及乱码问题)1.4打开PuTTY选择串口,设置COM端口号,波特率设置为115200,回车1.5回车后会弹出命令行小黑框 输入以下令命:setenv boot_wait onsetenv uart_en 1saveenv (如果显示乱码,把TX、RX线调换即可,波比率速率调至115200!)(如果还是黑屏请检查com端口是否正确,还有路由器不要提前插电!还有VCC不要接!)(这一步做不了的需要下载救机包,刷机后即可继续,打开MIWIFIRepairTool根据提示刷入本地固件包miwifi_cr8806_firmware_4622b_6.2.33(期间需要记得关闭windows防火墙和自带杀毒软件))TTL固定uboot中断已成功,恭喜你学会了中断uboot,点这里直达返回选择其他选项刷入固件 二:CR880X刷红米AX3000首先告诉你的是,CR880X有两款主板,M79和M81, M81就就无所谓了,什么都可通刷没什么毛病, M79那恭喜你中奖了,接下来告诉你 优点是:自由组mesh、插件管理、解除营运商接入限制等.缺点是:2.4G功率减半(仅M79主板,目前解决需付费,嘿嘿嘿,中奖了)操作有风险!先备份数据以作后悔药 CR880X成功进入uboot中断后,双击Tftpd64运行(运行后不要管它).输入以下命令,并手动将网卡ip修改成192.168.1.1,网关为192.168.1.2setenv ipaddr 192.168.1.2setenv serverip 192.168.1.1以上设置好之后,输入以下命令:tftpboot OpenWrt.mtd1.bin &amp;&amp; flash 0:MIBIB做完不要断电!切记不要断电!继续输入以下命令:tftpboot OpenWrt.mtd11.bin &amp;&amp; flash 0:APPSBLtftpboot OpenWrt.mtd12.bin &amp;&amp; flash 0:APPSBL_1确认好步骤,没有报错后直接拔电!等待通电后闪黄灯,拔电打开MIWIFIRepairTool按照提示的步骤,刷文件中的miwifi_ra81_all_03430_1.0.33提示你可以进行刷机操作的时候 路由器长按reset不松手插电 ,等待刷机完成待蓝灯闪烁后拔电,关闭MIWIFIRepairTool软件即可!AX3000固件刷入完毕,教程到此结束,点这里提供快捷返回选择首页其他教程 三: CR880X刷OpenWrt3.1经过刚刚的配置TTL环境让CR880X成功进入uboot中断 3.2输入以下命令,并手动将网卡ip修改成192.168.1.1,网关为192.168.1.2:setenv ipaddr 192.168.1.2setenv serverip 192.168.1.1tftpboot ax3000.ubi(或你自己下载的ubi固件文件名!) 3.3 动下载完成后继续输入以下命令进行刷写:flash rootfs_1setenv flag_try_sys2_failed 0setenv flag_boot_rootfs 1setenv flag_last_success 1saveenv 3.4 修改过大分区报错误的话要用以下代码,如果上面代码没有反馈错误就不要输入下面的代码,直接跳过这一步flash rootfssetenv flag_try_sys1_failed 0setenv flag_boot_rootfs 0setenv flag_last_success 0saveenv 3.5继续输入以下命令进行重启:reset 3.6在最后会显示6秒后自动重启这时拔掉ttl插线和网线!不然会无限重启等蓝灯不再闪烁时刷机完成!ip设置自动获取,浏览器输入192.168.1.1进入管理界面,即可开心冲浪了OpenWrt刷入完毕,教程到此结束,点这里提供快捷返回选择首页其他教程四:已刷openwrt强刷红米AX3000官方固件4.1在ssh环境,把这三个分区刷进去,连续把三个文件刷回去,检查无漏无误再断电 4.2先用winscp把三个文件上传到&#x2F;tmp&#x2F;,然后用putty操作:命令如下:mtd erase &#x2F;dev&#x2F;mtd1mtd write &#x2F;tmp&#x2F;OpenWrt.mtd1.bin &#x2F;dev&#x2F;mtd1 4.3做完不要断电!继续输入以下命令:mtd erase &#x2F;dev&#x2F;mtd11mtd write &#x2F;tmp&#x2F;OpenWrt.mtd11.bin &#x2F;dev&#x2F;mtd11mtd erase &#x2F;dev&#x2F;mtd12mtd write &#x2F;tmp&#x2F;OpenWrt.mtd12.bin &#x2F;dev&#x2F;mtd124.4完成检查无漏无误后拔电!刷机风险自行承当 4.5然后通电后会发现闪黄灯,别慌!拔电,长按reset不松手插电用MIWIFIRepairTool刷红米AX3000_1.0.33版救机包!待蓝灯闪烁后拔电,关闭MIWIFIRepairTool软件即可!SSH强刷红米AX3000官方固件教程也到这里咯,点击这里就返回了,快去上网冲浪吧! 主板区分图M79M81AX3000"},{"title":"Pydantic & Typing —— Python 类型注解深入","date":"2023-09-23T16:41:23.000Z","url":"/python/python-pydantic-tutorial/","categories":[[" ",""]],"content":"Pydantic &amp; Typing —— Python 类型注解库深入众所周知，Python 是一门弱类型的语言，在定义变量时不用标注其类型，类型间也可以隐形的转换。这导致了开发时候 IDE 提示不智能，容易出现 BUG 等问题。 JavaScript 也是一门弱类型语言，但衍生出了他的超集 Typescript 拥有更加完善的注释系统。 而 Python3 开始可以显性的添加 function hint 类似：def cat(age: int, name: str) -&gt; str 等简单的类型，但稍微复杂的类型就需要用到 typing 等模块。 而 Pydantic 就解决了这个痛点，可以定义一个复杂的类型，集成了 数据验证，IDE 智能提示、Json 支持 ，等功能，提高开发体验，减少 BUG。 目前 Pydantic 已从 V1 升级成 V2 相关代码请修改并适配 ReferencePydantic Official Document：Welcome to Pydantic - Pydantic Models - Pydantic Python Typing Official Document：typing — Support for type hints — Python 3.11.5 documentation Vscode Support Pydantic使用 VS Code 的 Pylance 扩展。它是推荐的下一代 Python 官方 VS Code 插件。 Open the “User Settings” 打开“用户设置” Search for Type Checking Mode搜索 Type Checking Mode You will find an option under Python › Analysis: Type Checking Mode 您将在 Python › Analysis: Type Checking Mode 下找到一个选项 Set it to basic or strict (by default it’s off) 将其设置为 basic 或 strict （默认情况下为 off ） Callable 回调函数签名注释Callable[[int], str] 表示采用 int 类型的单个参数并返回 str 的函数，例如可以注释以下函数。 示例： Generics /dʒəˈner.ɪk/ (adj.一般的) 泛型支持 泛型是一种编程语言特性，允许在编写代码时使用 一些通用的类型，而不是特定的类型。它可以让代码更加通用、可重用和安全。比如 def func(parameter:T) -&gt; T T 就是一个泛型，根据传入的参数类型来决定传出的参数类型，而不指定传入是某个类型。 Python 是一种动态类型语言，它没有像 Java 或 C# 那样的严格类型限制。因此，Python 中的泛型并不像 Java 或 C# 中那样显式地定义类型参数。但是，Python 中可以使用 泛型编程技术 来实现通用、可重用的代码。 TypeVar() 参考：typing — Support for type hints — Python 3.11.5 documentation User-defined Generics types 用户定义的泛型TypeVar() 只支持 bound 绑定一个标准类型，而 Generic 支持绑定用户自定义的类型。 Annotating /ˈæn.ə.teɪt/ (v. 给..注解) tuples 注释元组在 Python 中，类型系统都假定容器的数据类型一样，如 List[str] ，但 Mapping 可以支持多种类型的容器。 Mapping 只接受两个类型参数：第一个表示键的类型，第二个表示值的类型。 Mapping 类似于 Dict 字典 tuple 类型天生支持多个参数： Order Typing Type 其他注释类型Union 联合Union[X, Y] 相当于 X | Y ，表示 X 或 Y。 版本 Python 3.10 中更改：联合现在可以写为 X | Y Optional 可选Optional[X] 相当于 X | None （或 Union[X, None] ）。 Annotated /&#39;ænə,teitid/ 注释这个在 FastAPI 中添加 router 注释用的多。用于将 metadata 元数据添加到一个类型中的 __metadata__ 属性。 Sequence[英 &#x2F;ˈsiːkwəns&#x2F; 序列], Iterable (可迭代) &amp; Iterator (迭代器) Infinite[英 &#x2F;ˈɪnfɪnət&#x2F; 无限] Generators 无限生成器 Pydantic BaseModel Validator 验证器Field validators 字段验证器： 如果您想将验证器附加到模型的特定字段，可以使用 @field_validator 装饰器。 第一个参数值是 UserModel 类，而不是 UserModel 的实例。所以在 @field_validator 装饰器下方使用 @classmethod 装饰器来进行正确的类型检查。 第二个参数是要验证的字段值；可以随意命名。 第三个参数（如果存在）是 pydantic.FieldValidationInfo 的实例，用于记录验证的信息。 验证器应该返回解析的值或引发 ValueError 或 AssertionError，也可以无脑 assert model_validator 模型验证器，针对整个模型进行验证，并提供几个 Hook 钩子，可用来预处理部分数据。务必 return 出处理完的整个数据。 Field [英 &#x2F;fi:ld&#x2F; 字段]Field 函数用于自定义元数据并将其添加到模型的字段中。用于改变 Pydantic 的行为。 序列化 Serialization [英 &#x2F;ˈsɪəri:əˌlaɪz&#x2F;] Read Environment value IN BaseSettings 使用 Pydantic 管理环境变量配置一个 Python 程序的最佳实践不是编写复杂的解析逻辑来解析 ini yaml 等配置文件，而是直接在环境变量读取。使用 pydantic-settings 可以很方便的从环境变量里读取配置信息。 创建一个定义明确、类型提示的应用程序配置类 自动从环境变量中读取对配置的修改 install：安装 示例： 通过 .env 文件加载环境变量的优先级＞.env 文件 .env file: 在 model_config 处加载： 实例化对象加载： "},{"title":"纪实、深度、冷门——中国独立纪录片推荐","date":"2023-09-19T13:44:19.000Z","url":"/china-documentary/","tags":[["Documentary","/tags/Documentary/"],["中共","/tags/%E4%B8%AD%E5%85%B1/"],["纪录片","/tags/%E7%BA%AA%E5%BD%95%E7%89%87/"],["政治","/tags/%E6%94%BF%E6%B2%BB/"],["CCP","/tags/CCP/"]],"categories":[["Documentary","/categories/Documentary/"]],"content":"纪实、深度、冷门——中国独立纪录片推荐前每当我们把视角从北上广的车水马龙和琉璃光彩里抽离出来，很多纪实类影片的色彩就变得恍如隔世，似乎某一瞬间都不像这个时间线里的东西。 我突然觉得，为什么中国如同这一类的电影，比如《红高粱》、《隐入尘烟》之类的 文艺纪实类 电影，一到这类的题材整个电影画面的格调和整体的氛围就会变得扑朔迷离和怅然往复？ 究竟是你我生活在包裹太多虚伪和谎言的城市光鲜里，还是平淡清冷的县城样貌才是这个中国最真实的底色。 中国这个千年以来背靠农耕、宗族而起的乡土社会，最后也将落地归根，回归乡土。而中国人骨子里里就有一种独特的乡土情结，亘古不变，这也是这些纪录片能取得观众共情的原因。 但近年来，中国大陆的言论自由在进一步收紧。而独立纪录片的“独立”之处在于 不受官方意志左右，寻求思想上的自由。 主动寻求体制外空间的话语权，与体制内的主流意识形态划清界限，反应社会问题，揭露社会阴暗面，将镜头对准少数群体，以博取观众的共情，促进相关制度的改良。 但严苛的制度限制了独立纪录片往商业化方向发展，也使得它们失去了像主流电影一样获得国家电视台和政府资金的机会，缺乏宣传展示的平台，致使电影人在拍摄制作独立纪录片的道路上步履艰难。 这些电影或许在国内得不了奖，甚至于无缘银幕，但是没关系，还有真正的电影人，敢于发声，守护真相，中国电影还有希望。 这就是纪录片，它不给你那些镜花水月的幻象，它给你一场皮开肉绽的、残酷的、荒芜的生活真相，有些人看过绝望，有些人却看到微光。 《隐入尘烟》隐入尘烟下架让这部作品的讽刺完成了最后的升华。 《高三》《出路 education》《宇宙探索编辑部》《最后的棒棒》《四个春天》🎬电影：四个春天（2017）💁‍♂️导演：陆庆屹🎙️音乐：情绪的尽头是沉默🥇奖项：FIRST 青年电影展最佳纪录长片 《狗十三》他一直坚持拍摄现实主义电影，而且自我要求很高，是中国目前现实批判主义电影的旗帜。 《我们俩》《活着》年代记实录，看了让人不舒服，特别是里面的台词，虽然他们在拼尽全力的活着，可是却又显得如此可笑和悲凉。“小鸡长大了就变成了鹅，鹅长大了就变成了羊，羊长大了就变成了牛，牛长大了就是共产主义了。” 《杀马特我爱你》在大众媒体的话语体系中，杀马特等同于低俗、哗众取宠、博人眼球。而本世纪初，在广东一带兴起的杀马特一族，其实绝大部分都是十几岁进厂打工的留守儿童，他们在流水线上出卖体力、感觉不到存在的意义，得不到周围人的认可，日常被孤独、压抑、苦闷填满。于是他们只能通过廉价而又扎眼的发型获得心理上安慰（即：有人关注我、关心我，哪怕是异样的眼光）。这种发型进而发展成一种身份上的认同，工厂流水线上一个个孤独的个体终于有了归属。他们宁肯被辞退、找不到工打、忍饥挨饿、遭人唾弃，也要保留自己的发型。因为只有这样，他们才感觉自己是完整的、自由的、有归属的。至于后来网络直播平台上戴着假发套、装疯卖傻的“杀马特”，早已不是当年这群孤独的人了。这群人最后终被无力穿透的阶层困住，重新坠入千篇一律的生活。 毛坦厂的日与夜移民英国梦 新加玻拍摄零零后记录两个孩子的成长过程 高十剩女 以色列拍摄异类🎬电影：异类💁‍♂️导演：Wang Ziyi 王子易🥇奖项：第三届 86358 电影短片交流周华语短片竞赛单元 最佳影片 小则看老师，中则看教育，大则看制度。 两个主题：教育与友情一个是落后的思想决定的落后教育一个是悲情的英雄主义 观看渠道：Wang Ziyi 镜子人在三和阿辉《我的诗篇》💁‍♂️导演：秦晓宇🥇奖项：2015 年上海国际电影节最佳纪录片金爵奖"},{"title":"ChatGPT API 学习笔记","date":"2023-09-19T13:44:19.000Z","url":"/artificialintelligence/chatgpt-api-study/","tags":[["AI","/tags/AI/"],["ChatGPT","/tags/ChatGPT/"],["人工智能","/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"]],"categories":[["ArtificialIntelligence","/categories/ArtificialIntelligence/"],["AI","/categories/ArtificialIntelligence/AI/"]],"content":"ChatGPT API 学习笔记Reference Openai Offical Document ConceptsGPT or ChatGPTOpenAI’s text generation models (often referred to as generative pre-trained transformers or “GPT” models for short) OpenAI 的文本生成模型(通常称为生成式预训练变化者 或简称”GPT”模型) Prompt 提示词Designing a prompt is essentially how you “program” a model like GPT-4, usually by providing instructions or some examples of how to successfully complete a task. prompt 的设计本质上是如何”编程”一个像GPT-4这样的模型,通常是通过提供成功完成任务的说明或一些示例来完成的. Embedings 嵌入模型Embeddings are a numerical representation of text. 嵌入是文本的数字表示. An embedding is a vector representation of a piece of data (e.g. some text) 嵌入是一段数据(例如某些文本)的矢量表示. that is meant to preserve aspects of its content and&#x2F;or its meaning. 它被用于保留其内容和&#x2F;或含义的方面. text embedding models that take as input a text string and produce as output an embedding vector. 文本嵌入模型将文本字符串作为输入, 并将嵌入向量作为输出. Embeddings are useful for search, clustering, recommendations, anomaly detection, classification, and more. 嵌入对于搜索、聚类、推荐、异常检测、分类等非常有用. can be used to measure the relatedness between two pieces of text 可用于衡量两段文本之间的相关性 Token 词元&#x2F;代币Text generation and embeddings models process text in chunks called tokens. A token is a single unit of text, such as a word or a subword. (as English words) Token 是文本生成和嵌入模型处理文本的块,称为词元. 词元是文本的单个单位,例如单词或子词. (如英语单词), 可以理解成, 在 LLM(Large Language Model) 中, Token 是最小的文本单位, 他维护着一个词表, 词表中的每个词都有一个对应的 Token. tokenization &#x3D; token + ization As a rough rule of thumb, 1 token is approximately 4 characters or 0.75 words for English text. 根据粗略的经验,1 个标记大约相当于 4 个字符或 0.75 个英文单词. 可以使用英语做 prompt , 并要求用中文输出, 来节省 token. The limit is that for a text generation model the prompt and the generated output must be no more than the model’s maximum context limit. 对于文本生成模型, 提示和生成的输出的总和不得超过模型的最大上下文长度. For embeddings models (which do not output tokens), the input must be shorter than the model’s maximum context length. 对于嵌入模型(不输出标记), 输入必须比模型的最大上下文长度短. Both input and output tokens count towards the context limit. 输入和输出标记都计入上下文限制. Counting tokens for chat API calls.(use Python function) Large Multimodal Model 大型多模态模型GPT-4 is a large multimodal model (accepting text or image inputs and outputting text) GPT-4 是一个大型多模态模型(接受文本或图像输入并输出文本) Multilingual(Multiple Language) capabilities 多语言能力 DALL-EDALL·E is a AI system that can create realistic images and art from a description in natural language. DALL·E 是一个人工智能系统, 可以根据自然语言的描述创建逼真的图像和艺术. Text To Speech (TTS) 文本转语音TTS is an AI model that converts text to natural sounding spoken text. TTS 是一种人工智能模型,可将文本转换为听起来自然的语音文本. Whisper 耳语Whisper is a general-purpose speech recognition model. Whisper 是一种 通用目的 的语音识别模型. Moderation 适度(审查模型) censorship modelThe Moderation models are designed to check whether content complies with OpenAI’s usage policies. 审核模型旨在检查内容是否符合 OpenAI 的使用政策. The models provide classification capabilities(分类能力) that look for content in the following categories: hate(仇恨), hate&#x2F;threatening(仇恨&#x2F;威胁), self-harm(自残), sexual(性), sexual&#x2F;minors(性&#x2F;未成年性), violence(暴力), and violence&#x2F;graphic(暴力图像). Frequency and presence penalties (penal adj.刑事的) (频率和存在惩罚)can be used to reduce the possibility of sampling repetitive sequences of tokens. 可以用来减少采样重复标记序列的可能性. 如果目的只是稍微减少重复样本,那么惩罚系数的合理值约为 0.1 到 1.如果目标是强烈抑制重复,那么可以将系数增加到 2,但这会显着降低样本的质量.负值可用于增加重复的可能性. Prompt Engineering 提示词工程Prompt engineering can be used to improve model inference and reduce the likelihood of the model hallucinating. 提示词工程可用于改善模型推理, 减少模型产生幻觉的可能性. Temperature Parameter 温度参数Lower values for temperature result in more consistent outputs (e.g. 0.2) 较低的温度值会产生更一致的输出(例如 0.2) higher values generate more diverse(difference) and creative results (e.g. 1.0). 较高的值会产生更多样化和创造性的结果(例如 1.0). The temperature can range is from 0 to 2. 温度范围是从 0 到 2. Function call 函数调用connect LLM to external tools. (e.g. sending an email, making a reservation, or generating code) 将大型语言模型连接到外部工具 Fine-tuning (微调) (精细的调整)Fine-tuning improves on few-shot learning by training on many more examples than can fit in the prompt. 微调通过训练比 prompt 中可以容纳的更多示例, 来改进少样本学习. Once a model has been fine-tuned, you won’t need to provide as many examples in the prompt. 一旦模型被微调, 你就不需要在 prompt 中提供太多的示例. Fine-tuning is a method for customizing a model to better fit(vt. 安装;使……适应;) specific task, such as role-playing. 微调是自定义个性化模型的一种方法, 通过微调, 可以让模型更好地适应特定的任务. 例如指定的角色扮演(role-playing). Few-Shot Learning (少样本训练)Few-shot learning is a method for training a model on a small number of examples. 少样本学习是一种在少量示例上训练模型的方法. For example, u can input a few prompt to the model, and the model can generate the output based on the prompt. 例如, 您可以向模型输入几个提示, 模型可以根据提示生成输出. AGI (Artificial General Intelligence) 人工通用智能AGI is a hypothetical AI that can understand and learn any intellectual task that a human being can. AGI 是一种假设的人工智能, 可以理解和学习人类可以理解和学习的任何智力任务. DPO(Direct Perfer Optimal) 直接偏好优化DPO 是一种稳定且高效的方法, 用于微调 (fine-tuning) LLMs, 以便生成符合用户偏好的输出. 能够在不依赖复杂的基于人类反馈的强化学习 (Reinforcement Learning based on Human Feedback) 的情况下, 实现精准控制. NLP(Natural Language Processing) 自然语言处理CV (Computer Vision) 计算机视觉"},{"title":"GPT-SoVITS 小实验","date":"2023-09-19T13:44:19.000Z","url":"/artificialintelligence/gpt-sovits-experiment/","tags":[["AI","/tags/AI/"],["人工智能","/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"],["GPT-SoVITS","/tags/GPT-SoVITS/"]],"categories":[["ArtificialIntelligence","/categories/ArtificialIntelligence/"],["AI","/categories/ArtificialIntelligence/AI/"]],"content":"GPT-SoVITS 小实验Reference GPT-SoVITS Offical Tutorial GitHub Repository Project So-VITS-SVC 4.1: 支持声音克隆 需要半小时以上的素材训练. GPT-SoVITS: 花儿不哭, 声音克隆 歌曲翻唱 文本转语音, 一分钟以上素材. 训练几分钟. RVC: 花儿不哭, 实时语音, 半小时素材几小时训练 Training Steps训练 Sovits 模型: 低轮次准确, 高轮次感情会比较丰富, 但容易出现声音泄露. 8伦 batch_site 设置为显存的一半. 10分钟以内, 参数全部默认, 30分钟到一小时,调大训练轮速. 10分钟学习率为默认 0.4, 30分钟以上调到 0.3. SoVITS模型轮数可以设置的高一点,反正训练的很快.GPT模型轮数千万不能高于20(一般情况下)建议设置10.然后先点开启SoVITS训练,训练完后再点开启GPT训练,不可以一起训练(除非你有两张卡)!如果中途中断了,直接再点开始训练就好了,会从最近的保存点开始训练. GPT 模型: gpt可以适当把轮数调成 15, 10-15 效果比较好. 最大 50 gpt轮次越高感情越丰富, 轮次越低越准确. Dpo训练: 如果你的显卡大于12g,且数据集质量较好,且愿意等待漫长的训练时间,那么可以开启dpo训练.否则请不要开启.下面是切片长度为10s时实测的不同显存的gpt训练最大batch_size.如果切片更长、数据集更大的话要适当减少. 推理 Steps TOP-K 越低越准确,但缺少变化和多样性.比如故事讲述类,可调高这个值追求多样性;新闻类就要低一些,追求准确连贯; TOP-P 默认为1,假如调到0.9,相当于生成时只要概率大于90%就可能被选中,因此,越低随机性越大,越高准确性和相关性也越大. temperature :就像炒菜时的火候,大了容易糊,小了炒不熟.一般都要保持在0.9-1之间. 以上值具体多少合适只能根据实际情况亲自尝试,俗称”炼丹” UVR5 (Ultra Voice Remover 5)先用HP2模型处理一遍(提取人声),然后将输出的干声音频再用onnx_dereverb最后用DeEcho-Aggressive(去混响),输出格式选wav.输出的文件默认在GPT-SoVITS-beta\\GPT-SoVITS-beta\\output\\uvr5_opt这个文件夹下,建议不要改输出路径,到时候找不到文件谁也帮不了你.处理完的音频(vocal)的是人声,(instrument)是伴奏,(No Reverb)的没混响的,(Reverb)的是混响.(vocal)(No Reverb)才是要用的文件,其他都可以删除.结束后记得到WebUI关闭UVR5节省显存.如果没有成功输出,报错了.那么推荐使用下面一种方法——UVR5客户端.(✅可能兼容性有问题,但是效果是和UVR5对齐的,不要瞎黑内置工具效果有问题)"},{"title":"高中课程自学 Tutorial","date":"2023-09-18T10:00:56.000Z","url":"/study/gk-study-tutorial/","tags":[["高考","/tags/%E9%AB%98%E8%80%83/"],["自学","/tags/%E8%87%AA%E5%AD%A6/"],["语文","/tags/%E8%AF%AD%E6%96%87/"],["数学","/tags/%E6%95%B0%E5%AD%A6/"],["英语","/tags/%E8%8B%B1%E8%AF%AD/"],["物理","/tags/%E7%89%A9%E7%90%86/"],["化学","/tags/%E5%8C%96%E5%AD%A6/"],["地理","/tags/%E5%9C%B0%E7%90%86/"]],"categories":[["Study","/categories/Study/"]],"content":"高中课程自学 Tutorial笔者高二的时候就被 【某某高中】因 抑郁症 劝退，所以要在家自学备考，以下是自学期间在 B 大 BiliBili 等互联网平台搜寻到的学习资料，以帮助因为各种原因被 中国体制 内学校 开除、劝退、休学 导致无法正常完成学业的鼠鼠们。 Reference： B站高中最全9科网课老师推荐，一数，黄夫人，学过石油的语文老师准高中生必备！ 【高中网课·白嫖指南】高中优质网课，免费白嫖指南！ 英语笔者的博客记录了很多英语学习的笔记，在 categories English 下。 英语语法精讲合集 (全面, 通俗, 有趣 | 从零打造系统语法体系) 英语兔 BiliBili 比较系统语法教程： 英语语法精讲合集 (全面, 通俗, 有趣 | 从零打造系统语法体系) BV1XY411J7aG 数学 一数高中：一数观看指南【高中部分】（新版） - 哔哩哔哩 一数高中基础： 【高中数学基础全集】或许是高中最值得收藏的合集！奥数保送生主讲|2020新教材（涵盖所有） 一数的视频挺好的，也比较基础，能听懂。如果是高三一轮复习，可以购买他的一数教辅，也不贵，50元。这样下来数学及格应该是可以的。 物理 黄夫人：黄夫人-视频合集 关注微信公众号：黄夫人物理，领取讲义。"},{"title":"Vscode 常用快捷键","date":"2023-09-09T12:54:20.000Z","url":"/vscode-shortcut-key/","tags":[["Vim","/tags/Vim/"],["Vscode","/tags/Vscode/"]],"categories":[["Vscode","/categories/Vscode/"]],"content":"Vscode 常用快捷键无线老鼠坏了，所以只能依靠触控板和键盘进行编程，呜呜呜！无奈之下只能学习一下 Vscode 的快捷键了。 编辑文字相关 移动行：alt+up&#x2F;down 行增加&#x2F;减少缩进: ctrl + [ or ] 选中文字：shift + left &#x2F; right &#x2F; up &#x2F; down 视图滚动：Ctrl+up &#x2F; down 隔单词跳转：Ctrl+ left &#x2F; right 快速回到顶部 ： ctrl + Fn +home 快速回到底部 : ctrl + Fn + end 选择整行 CTRL + L 删除整行 CTRL + SHIFT + K &#x2F; Ctrl+d |Home| 光标跳转行头| |End|光标跳转行尾| 回到上一次编辑的位置：Alt + ← 单词删除：Ctrl+Backspace Delete 右删除 Backspace 退格 左删除 页面相关 显示&#x2F;隐藏左侧目录栏 ctrl + b 控制台终端显示与隐藏：ctrl + ~ 关闭编辑器窗口 : ctrl + w 关闭所有窗口 : ctrl + k + w **显示当前文件所有符号 (函数)**：ctrl + shift + O "},{"title":"Python database 数据库 ORM 框架","date":"2023-09-09T00:13:04.000Z","url":"/python/python-database-orm-tutorial/","tags":[["databases","/tags/databases/"],["python","/tags/python/"],["ORM","/tags/ORM/"],["mysql","/tags/mysql/"]],"categories":[["Python","/categories/Python/"]],"content":"Python database 数据库 ORM 框架ORM (Oobject Relational Mapper) 对象关系映射,用于在 Code 中通过 Object 来操作关系型数据库,将用户定义的 Python 类映射到数据库表和其他构造 ,而不用直接手撕 SQL 语句.增加安全性和可维护性. SQLAlchemy (SQL 炼金术 /ˈæl.kə.mi/ )是 Python 中用于操作各种 关系型数据库 的 ORM SQLAlchemy 2.0 教程 - Yifei’s Notes SQLAlchemy Offical Tutorial SQLAlchemy 包含 对象关系映射器 ORM 和 核心 Core 两部分 API,ORM 构建于 Core 之上,如上图.DBAPI 代表底层数据库的驱动,例如:pymysql sqlite3 与特定数据库交互的第三方驱动程序. Install Establish Connectivity 建立链接Engine 对象通过 create_engine() 方法来构造,是只用创建一次的全局对象.create_engine() 首次返回不会链接到数据库,仅在调用 Engine 对象执行数据库操作时才链接到数据库 (被称为 Lazy loading 的设计模式),lazy initialization Connect mysql serverreference: MySQL and MariaDB — SQLAlchemy 2.0 Documentation Transactions 事务操作Core Engine Connect ORM Engine Session使用 ORM 时的基本事务&#x2F;数据库交互对象称为 Session.Session 在结束事务后实际上并不保留 Connection 对象.下次需要对数据库执行 SQL 时,它会从 Engine 获取新的 Connection . 通过 with 语句构建 begin 开始、rollback 回滚、commit 提交 语句. 更简洁的实现: 或者使用 session macker(会话生成器): Database Metadata 数据库元数据 ORMSQLAlchemy 中数据库元数据最常见的基础对象称为 MetaData 、 Table 和 Column.一种创建表的方式是 显性使用 MetaData 表集合来创建: Declarative base 声明式基础一种是使用 对象 的方式来创建表. Table Reflection 表反射用于识别已有数据库的映射. Working with Data 处理数据Working with sql core 拼接构造 sql 语句reference: Using SELECT Statements — SQLAlchemy 2.0 Documentation Insert 插入 Select 选择查询 Update 更新 Delete 删除 Count 计数python - How to count rows with SELECT COUNT(*) with SQLAlchemy? - Stack Overflow Woking with ORMInstances of Classes represent Rows 表类的实例代表行. 从主键获取对象: 从 execute 获取对象:scalar() scalar &#x2F;ˈskeɪ.lər&#x2F; adj. 标量的 AsyncIO Support对异步 IO 的支持:Overview — SQLAlchemy 2.0 Documentation reference: Asynchronous I&#x2F;O (asyncio) — SQLAlchemy 2.0 Documentation install: install Asynchronous DBAPI: uses: Complete example 完整示例 Legacy query API 旧版查询 APILegacy Query API — SQLAlchemy 2.0 Documentation 多年来,它是使用 SQLAlchemy ORM 时唯一的 SQL 接口.从版本 2.0 开始,一种全新的工作方式现已成为标准方法,其中适用于 Core 的相同 select() 构造也适用于 ORM,为构建查询提供一致的接口. 从旧版本迁移到 2.0 SQLAlchemy 2.0 - Major Migration Guide — SQLAlchemy 2.0 Documentation SQLAlchemy 2.0 中最大的明显变化是使用 Session.execute() 与 select() 结合使用来运行 ORM 查询,而不是使用 Session.query() .正如其他地方提到的,没有计划实际删除 Session.query() API 本身,因为它现在是通过在内部使用新 API 来实现的,它将保留为旧版 API,并且这两个 API 都可以自由使用. SQLAlchemy Extansion 扩展Sqlalchemy-utils看样子比较老了. GitHub - kvesteri&#x2F;sqlalchemy-utils: Various utility functions and datatypes for SQLAlchemy. Various utility functions and datatypes for SQLAlchemy. SQLAlchemy 的各种实用函数和数据类型. Q&amp;AIs the Session thread-safe (线程安全)? Is AsyncSession safe(异步并发安全) to share in concurrent tasks?¶Session 是一个可变的、有状态的对象,session 的实例就无法在并发线程或异步任务之间共享. Session 旨在以非并发方式使用. 在设计并发数据库应用程序时,适当的模型是 每个并发任务&#x2F;线程都处理自己的数据库事务 Session. 确保这种使用的最佳方法是在线程或任务内部的顶级 Python 函数中本地使用 标准上下文管理器 模式. sqlalchemy.exc.CompileError: VARCHAR(varchar 变长字符串) Requires a length on dialect(方言) mysqlpython - InvalidRequestError: VARCHAR requires a length on dialect mysql - Stack Overflow official docs: ORM Mapped Class Overview — SQLAlchemy 2.0 Documentation 在 mysql 中使用 变长字符串 时需要使用 String(100) 来定义字符串长度: Default timestamppython - SQLAlchemy default DateTime - Stack Overflow 使用 server_default 而不是 default ,因此值将由数据库本身处理. Optimize数据库连接方面,可以避免出现 sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2013, &#39;Lost connection to MySQL server during query&#39;) 的错误,reference: sqlalchemy 报错 Lost connection to MySQL server during query 解决 - 金色旭光 - 博客园 relationship 延迟加载 DatabaseURL 数据库 URL Alembic [英 &#x2F;ə’lembɪk&#x2F; 蒸馏器] sqlalchemy 数据库迁移 Migrationreference: FastAPI with Async SQLAlchemy, SQLModel, and Alembic | TestDriven.io using asyncio with alembic(异步支持): Cookbook — Alembic 1.12.0 documentation 官方文档:  相关项目:  - 文档 migration[&#x2F;maɪˈɡreɪʃn&#x2F;] (migr-&#x3D;remove 迁移 + ate(动词) + tion (名词)) immigrant[&#x2F;ˈɪmɪɡrənt&#x2F;] 移民(imm-&#x3D;in 进入 -ant 表名词,”…人”.) merge[&#x2F;mɜːdʒ&#x2F;]: 合并 alembic [英 &#x2F;ə’lembɪk&#x2F;] 是 sqlalchemy 的作者开发的.用来做 OMR 模型与数据库的迁移与映射.alembic 使用方式跟 git 有点了类似,表现在两个方面,第一个,alembic 的所有命令都是以 alembic 开头;第二,alembic 的迁移文件也是通过版本进行控制的.首先,通过 pip install alembic 进行安装.以下将解释 alembic 的用法: 初始化 alembic 仓库在终端中,cd 到你的项目目录中,然后执行命令 alembic init alembic,创建一个名叫 alembic 的仓库. 创建模型类创建一个 models.py 模块,然后在里面定义你的模型类,示例代码如下: 设置数据库连接在 alembic.ini 中设置数据库的连接,sqlalchemy.url = driver://user:pass@localhost/dbname,比如以 mysql 数据库为例,则配置后的代码为: sqlalchemy.url = mysql+mysqldb://root:root@localhost/alembic_demo?charset=utf8 设置 target_metadata为了使用模型类更新数据库,需要在 env.py 文件中设置 target_metadata,默认为 target_metadata=None.使用 sys 模块把当前项目的路径导入到 path 中: test connect: 自动生成迁移文件使用 alembic revision --autogenerate -m &quot;message&quot; 将当前模型中的状态生成迁移文件. 异步 Base 支持: 更新数据库使用 alembic upgrade head 将刚刚生成的迁移文件,真正映射到数据库中.同理,如果要降级,那么使用 alembic downgrade head. 命令和参数解释 init:创建一个 alembic 仓库. revision:创建一个新的版本文件. –autogenerate:自动将当前模型的修改,生成迁移脚本. -m:本次迁移做了哪些修改,用户可以指定这个参数,方便回顾. upgrade:将指定版本的迁移文件映射到数据库中,会执行版本文件中的 upgrade 函数.如果有多个迁移脚本没有被映射到数据库中,那么会执行多个迁移脚本. [head]:代表最新的迁移脚本的版本号. downgrade:会执行指定版本的迁移文件中的 downgrade 函数. heads:展示 head 指向的脚本文件版本号. history:列出所有的迁移版本及其信息. current:展示当前数据库中的版本号. 另外,在你第一次执行 upgrade 的时候,就会在数据库中创建一个名叫 alembic_version 表,这个表只会有一条数据,记录当前数据库映射的是哪个版本的迁移文件. 经典错误 错误描述 原因 解决办法 FAILED: Target database is not up to date. 主要是 heads 和 current 不相同.current 落后于 heads 的版本. 将 current 移动到 head 上.alembic upgrade head FAILED: Can&#39;t locate revision identified by &#39;77525ee61b5b&#39; 数据库中存的版本号不在迁移脚本文件中 删除数据库的 alembic_version 表中的数据,重新执行 alembic upgrade head Is it possible to store the alembic connect string outside of alembic.iniref: python - Is it possible to store the alembic connect string outside of alembic.ini? - Stack Overflow Alembic for asynchronous database supportAlembic[&#x2F;ə’lembɪk&#x2F;] migration[&#x2F;maɪˈɡreɪʃn&#x2F;] 蒸馏器迁移工具异步支持. Reference:  "},{"title":"TypeScript 快速入门☞北","date":"2023-09-01T13:51:14.000Z","url":"/javascript/typescript-fast-start/","tags":[["Vue","/tags/Vue/"],["TypeScript","/tags/TypeScript/"],["TS","/tags/TS/"],["Javascript","/tags/Javascript/"]],"categories":[["JavaScript","/categories/JavaScript/"]],"content":"TypeScript 快速入门 ☞ 北因为在学习 Vue Framework 的过程中,碰到了很多 TypeScript 之类的知识和语法以及 Vue 源码也是通过 ts 写的,所以有必要去了解一下 TypeScript 这个语言语法. reference: TypeScript 教程 | 菜鸟教程 最近发现一本好书:TypeScript 入门教程 阮一峰 ES6 入门教程:ES6 入门教程 2024&#x2F;1&#x2F;21 更:最近又发现一个宝藏 up 主的视频 小满 zc:小满 zc 自残 TypeScript 基础教程全集(完结) TypeScript &#x3D;&#x3D;&gt; JavaScript 的一个 超集,支持 ECMAScript 6 标准 TypeScript 由 微软 爸爸开发. TypeScript 设计目标是开发大型应用,它可以 编译成纯 JavaScript,编译出来的 JavaScript 可以运行在任何浏览器上. TypeScript 是一种给 JavaScript 添加特性的语言扩展,他主要添加了 对 JS 类型 的支持 ,相当于 Python 的 function hint (函数暗示) Pydantic BaseModel、typing 等给弱类型的动态语言 提供类型支持. INSTALLTS 基于 NodeJS 编写 main.ts 然后执行以下命令将 TypeScript 转换为 JavaScript 代码: TypeScript &#x3D;&#x3D;&gt; TypeScript Compiler &#x3D;&#x3D;&gt; JavaScript 安装 ts-node 可以直接运行 ts 文件 数据类型 数据类型的层级关系 顶级类型 (top type) :any unknown (unknown 只能赋值给自身或者 Any 且如果赋值给对象不能读取其 attr) Object 所有对象的基类 Number String Boolean 对象 number string boolean (instantiation object 实例化对象) Object 和 objectobject 表示引用类型,常用于泛型约束. 数组类型 array 在函数内部有一个特殊的 value —— arguments,用于记录传入参数的列表,但不是一个常规的 array 类型. 元组类型 tuple元组(tuple) 是固定数量的不同类型的元素组合. 元组和数组的不同之处,元组中的 元素类型是可以不同的,且数量固定.元组的好处在于可以把 多个元素作为一个单元传递.如果一个 function 需要返回多个值,可以把这多个值作为元组返回,而不需要创建额外的类来表示. 枚举类型 enumerate 类型推断和类型别名TS 在定义变量的时候天然支持推导其类型,如果不确定的话,会被推断成 Any. Never 类型never 类型来表示不应该存在的状态.表示永远不能达到: never 是最底层的类型, never 用于 switch 兜底的场景: Symbol 类型象征、标志,是 es5 新增的一个数据类型. 应用:在一个对象中,key 值如果相同,就会被覆盖.如果 key 是一个 Symbol(name) 则 name 相同也不会覆盖. 联合类型 类型断言 交叉类型联合类型 交叉类型 类型断言:在联合类型的参数中,用 as 指明是哪个类型.类型断言只能欺骗 ts 的 静态类型检查,以编译成功,但无法规避运行时的类型错误. TS 内置对象JavaScript 中有很多内置对象,它们可以直接在 TypeScript 中当作定义好的类型. 流程控制TypeScript 还支持 for…of 、forEach、every 和 some 循环. Function 函数 ts 可以定义 object 内 this 的类型,但在 origin JS 中无法使用,必须是 method 的第一个参数定义 this 的类型,传参时不用传 this ,和 Python 中 class 的 self 一样. 函数重载:重载函数传入和返回的数据类型,在实现函数内部判断所属的类型进行操作 Interface 接口对象实现接口.类是对象的构造器. 与 Golang 接口的概念一样,接口是 method 和 attribute 的集合,需要有对应的类去实现,如果类实现了接口中的所有 methods 就可以说这个类实现了这个接口. interface 接口来实现一种约束,让 对象&#x2F;类 的结构满足约束的格式. interface 接口命名 第一个字母要大写. 遇到重名 interface 时,会自动进行合并. interface 中使用 union type 索引签名:接口中可以为数组的 index 和 content 设置类型 可选的值加 ? 接口继承接口可以通过其他接口来扩展自己,可以继承多个接口,使用 extends 语句 允许多继承: Interface 接口定义函数类型 Class 类Class 类是对象的构造器:与 JS 的使用方法相同 类的继承: 需要注意的是 子类只能继承一个父类,TypeScript 不支持继承多个类,但支持多重继承: static 静态 methods 、attribute,可直接通过类名来调用,不需要 New instanceof [&#x2F;ˈɪnstəns&#x2F;] 运算符,用于判断对象是否为指定类: 类的访问控制: public(默认) : 公有,可以在任何地方被访问. protected : 受保护,可以被其 自身 以及其 子类 访问. private : 私有,只能被其定义所在的类访问. 类实现接口对象实现接口.类是对象的构造器. 使用 implements [英 &#x2F;ˈɪmplɪment&#x2F; vt. 使生效 n.用具] 关键字 实现一个 Vue Virtual Dom 虚拟 DOM 类的 getter 和 setter 抽象类 基类abstract 定义抽象类,抽象类不能被实例化,只能被继承,子类需要实现抽象类中的抽象方法. abstract 所定义的方法,都只能描述,不能实现. Initialization Order 初始化顺序In some case, 继承类会出现 反人类 的行为: What happened here? The order of class initialization, as defined by JavaScript(由JS定义), is: Initialize base class fields (初始化基类字段) Run base class constructor (运行基类构造函数) Initialize derived(v.得到 n.源于) class fields (初始化派生类字段) Run derived class constructor (运行派生类构造函数) The confusing this (容易混淆的 this)JavaScript’s handling of this is indeed unusual (JS 对于 This 的处理的确很不寻常) 调用函数时, 函数内 this 的值取决于函数的 调用方式.在此示例中,由于该函数是通过 obj 引用调用的,因此其 this 的值为 obj 而不是类实例. 由谁调用的函数, this 就是谁. 当使用箭头函数(arrow function)时, this 的值取决于函数的定义位置. 箭头函数不会绑定 this,而是从定义时的作用域中继承 this. 使用了箭头函数, 就不能在派生类(derived class) 中使用 super 调用定义的 箭头函数. 因为 原型链 中没有箭头函数的定义. (可能是没有绑定到基类的 this) You can’t use super.getName() in a derived class, because there’s no entry in the prototype chain(原型链) to fetch the base class method from. Explicitly Declared this parameters 显式声明 class 中的 this在方法或函数定义中,名为 this 的初始参数在 TypeScript 中具有特殊含义.这些参数在编译期间被删除. TypeScript 会检查函数是否以指定的 this 上下文调用, 可以在方法定义中添加一个 this 参数来静态强制(statically enforce) 调用该方法, 而不是使用箭头函数: 这样, 函数也可以正确的在 派生类(derived class) 中使用 super 调用. Constructor Signature 构造函数签名JavaScript 类使用 new 运算符进行实例化. 给定类本身的类型, 使用 InstanceType 实用程序类型(utility type models) 获取实例类型. Dock Typing 鸭子类型鸭子类型(英语:duck typing)是动态类型的一种风格,是多态 (polymorphism [英 &#x2F;ˌpɒlɪ’mɔːfɪz(ə)m&#x2F;]) 的一种形式. “ 当看到一只鸟 走 起来像鸭子、游泳 起来像鸭子、叫 起来也像鸭子,那么这只鸟就可以被称为 鸭子.” ——&lt;落落前传&gt; 在 鸭子类型 中,关注的是 object 的 方法 methods ,而不是 object 的类型.换言之如果一个类型 A 实现了 run() 和 eat() 的方法(即实现了行为接口)就可以通过接口类型调用这个方法,不需要知道类型是什么. 命名空间命名空间可以解决重复命名的问题. Module 模块 可以更改的组织代码 模块在自身的作用域执行,定义在模块里面的变量、函数和类在外部是不可见的,除非使用 export 导出,并在外部使用 import 导入. SomeInterFace.ts mian.ts 使用 tsc 编译代码: 生成器 迭代器手写一个生成器,使用 function* 标记为生成器 迭代器: es6 新增的数据类型 set map argument 以上类数组 他们都有迭代器 Symbol.iterator,所以可以使用迭代器来遍历他们: 泛型 generic根据传入的参数,动态定义 function 内部的类型,T 相当于一个占位符号. 应用:封装一个 XMLHttpRequest ,使用 generic 定义返回的类型,这样在 then 接收的时候就能自动提示类型. 泛型约束用于控制泛型的范围,在类型后面跟一个 extands 再跟一个约束的类型 keyof 读取对象的所有属性名 实现安全的对象访问: keyof 的高级用法,将 interface 的 key 变可选 tsconfig.json 配置文件通过 tsc --init 生成. tsconfig.json Namespace 命名空间编程中,无法避免 同名全局变量(global variable)造成的污染 pollution,namespace 避免这个问题的出现.相当于闭包,把函数的变量隔离出来. namespace 支持:嵌套、抽离、导出、简化、合并 应用场景:跨端项目,同一个功能,不同的 platform 有不同的实现,同一个 function 名字相同,可以用 namespace 划分不同平台的实现. 三斜线指令三斜线指令是包含单个 XML 标签的单行注释.注释的内容会做为编译器指令使用. 三斜线指令 仅可放在包含它的文件的最顶端. ///&lt;reference path＝＂…&quot;/&gt; 指令是三斜线指令中最常见的一种.它用于声明文件间的依赖.三斜线引用告诉编译器在编译过程中要引入的额外的文件. 也可以把它理解能 import,它可以告诉编译器在 **编译过程中要引入的额外的文件.**、 也可以引用声明 declare 文件:/// &lt;reference type=&quot;node.d.ts&quot;&gt; 声明文件 declare d.ts初始化一个项目 当使用第三方库时,我们需要引用它的声明文件,才能获得对应的代码补全、接口提示等功能.声明文件不包含具体实现,只是一个类型 hint. 一些老的库都是用 js ,要另外安装对应的 d.ts 声明库才能使用 ts 的语法提示: 手动编写 declare 文件: index.ts express.d.ts Mixins 混入Object 混入 Class 类的混入一般用于 Plugins 依赖注入,类似 app=MixinsPlugin(app): ref: TypeScript: Documentation - Mixins JS 原型链 (JS prototype chain)好像不是 TS 的知识,但为了更好的理解原理我放到这里来了. 构造函数如果一个函数用 new xxx() 的方式调用,这个函数就称为构造函数,相当于 ES6 中的 class 语法糖.在构造函数中的 this 原先是 null,可以在函数内部通过 this.xx 的方式赋予 value 和 method,new 这个函数返回的就是 this 这个对象. 使用 class 语法糖: prototype Attributeprototype 是 构造函数、class 类,独有的一个 对象.prototype 是 函数才会有的属性 函数的 prototype 属性指向了一个 原型对象,这个对象正是调用该构造函数而创建的 实例 的原型,也就是这个例子中的 person1 和 person2 的原型. 那什么是原型呢?你可以这样理解:每一个 JavaScript 对象 (null 除外) 在创建的时候就会与之关联另一个对象,这个对象就是我们所说的 原型,每一个对象都会从原型 “ 继承 “ 属性. __proto__ Attribute__proto__ 这是每一个 JavaScript 对象 (除了 null ) 都具有的一个属性,叫 proto,这个属性会指向该对象的原型. __proto__ 被称为 对象 的 隐式原型,对应的是构造函数(类)的 prototype 原型对象 Constructor 构造器每个原型对象都有一个 constructor 属性指向关联的构造函数. 综上: 原型链构造函数(类)的原型对象也是一个对象 object,所以他也具有 __proto__ 隐式原型属性,指向 object 对象的构造函数(类)的原型对象 Object.prototype . 所以对象的隐式原型的原型对象构成一条原型链: 对象寻找数值,是原型链从下到上一直找到原型链顶端,用 冒泡 的方式查找的. 【Experiment】装饰器 Decorator在 tsconfig.json 启动 experiment 实验功能: Class decorator类装饰器,可以在不修改类的情况下,通过操作类(构造函数)的原型对象 prototype 向类添加 method 和 attribute. decorator factory 装饰器工厂:允许往装饰器内传参,也就是一个高阶函数闭包,返回一个 ClassDecorator Method decorator 方法装饰器 返回的参数:可以在 descriptor 更改 value 的数值,达到直接改传参的目的. 通过 Rollup 构建 TS 项目 TS 实现发布订阅模式发布订阅模式于类似 mqtt 物联网,在前端中 addEventListener 和 vue eventBus 也是发布订阅模式. 发布订阅模式有:发布者、订阅者、调度者 ES6 新类型 weakMap weakSet set mapSet集合是由一组无序且唯一 (即不能重复) 的项组成的,可以想象成集合是一个既没有重复元素,也没有顺序概念的数组. attribute size: 返回 set 数据结构的数据长度 methods add(value):添加某个值,返回 Set 结构本身. delete(value):删除某个值,返回一个布尔值,表示删除是否成功. has(value):返回一个布尔值,表示该值是否为 Set 的成员. clear():清除所有成员,无返回值. 数组去重: Map它类似于对象,也是键值对 (key-value) 的集合,但是 key 的 type 不限于 string,各种类型的值(包括 object 等 引用类型)都可以当作 key,是一种更完善的 Hash 结构实现.如果你需要”键值对“的数据结构,Map 比 Object 更合适. 操作方法同 set WeakSet WeakMapweak: adj. 弱的,weakSet 和 weakMap 的键都是弱引用,不会计入垃圾回收. Javascript V8 引擎 GC 是通过 计数引用 进行清除的. 首先 obj 引用了这个对象 +1,aahph 也引用了 + 1,wmap 也引用了,但是不会 + 1,因为他是弱引用,不会计入垃圾回收,因此 obj 和 aahph 释放了该引用 weakMap 也会随着消失的,但是有个问题你会发现控制台能输出,值是取不到的. 因为 V8 的 GC 回收是需要一定时间的,需要延长到 最少 200ms weakMap 才会回收,为了避免这个问题 weakMap 不允许取键值,也不允许遍历,同理 weakSet 也一样. Function 函数的二义性 箭头函数一个函数有两种意义:1. 作为一个普通函数调用 2. 作为对象的构造函数 object construct function 开发者标准:如果一个普通函数开头大写,declare 声明这个函数就是对象构造函数. 在 ts 中,如果需要构建对象,可以使用 class 定义一个类,通过 new 实例化类来拿到类实例化后的对象: 箭头函数 Arrow Function如果想要消除函数的二义性需要使用 箭头函数 const fn = (x, y)=&gt; x+y this 指向的不同: 普通 function 定义的函数 this 指向它自身. 箭头函数 this 是指向外面环境的,所以箭头函数本身无法去创建属性. 箭头函数没有 prototype 原型对象,所以它不能被 new 成为对象构造函数. 箭头函数与 this 绑定: Note: 箭头函数(Arrow Functions) 和 普通函数 (Function Declarations) (Function Expressions) 在 this 的处理上有一个很大的不同: 普通函数: this 的值是在 运行时根据调用方式动态确定的 .比如在对象方法中, this 通常指向调用该方法的对象. 箭头函数: 箭头函数 没有自己的 this 绑定, 它会捕获其 定义时所在上下文 的 this 值,作为自己的 this.这意味着箭头函数的 this 是静态的,不会根据调用方式改变. TS 进阶代理&amp;反射 proxy &amp; ReflectProxy 对象用于创建一个对象的代理,从而实现基本操作的拦截和自定义(如属性查找、赋值、枚举、函数调用等). Vue3 正是通过 Proxy 代理对象实现页面的响应式的. Reflect与大多数全局对象不同 Reflect 并非一个构造函数,所以不能通过 new 运算符 对其进行调用.要将 Reflect 对象作为一个函数来调用.Reflect 的所有属性和方法都是静态的(就像 Math 对象) API: Reflect.get 方法查找并返回 target 对象的 name 属性,如果没有该属性返回 undefined Reflect.set 方法设置 target 对象的 name 属性等于 value. 实现 mobx observer 观察者模式 Type Guards 类型守卫在 TypeScript 中,类型守卫(Type Guards)是一种用于在 运行时检查类型 的机制.它们允许你在代码中执行特定的检查,以确定变量的类型,并在需要时执行相应的操作. Typeof 类型收缩声明一个函数可以接受任意类型,并返回一个 boolean,只筛选出字符串类型,进行类型收缩. typeof 只能返回有限的字符串类型,包括 “string”、”number”、”boolean”、”symbol”、”undefined” 和 “object”.对于函数、数组、null 等类型,typeof 也会返回 “object”.因此,typeof 对于复杂类型和自定义类型的判断是有限的. Instanceof使用 instanceof 类型守卫可以 检查一个对象是否是特定类的实例. instanceof 操作符用于检查一个对象是否是某个类的实例.它通过 检查对象的原型链 来确定对象是否由指定的类创建. instanceof 操作符主要用于检查对象是否是特定类的实例,它 无法检查基本类型.此外,它也无法检查对象是通过字面量创建的,因为字面量对象没有显式的构造函数. The left-hand side of an ‘instanceof’ expression must be of type ‘any’, an object type or a type parameter.‘instanceof’ 表达式的左侧必须是 ‘any’ 类型,对象类型或类型参数. Custom Guard 自定义守卫实现一个函数支持任意类型: 如果是对象,就检查里面的属性, 如果里面的属性是 number 就取两位,如果是 string 就去除左右空格 如果是函数就执行 编写代码时,需要用到 类型谓语 (type predicate) 才能拥有良好的 type hint. Type compatible[&#x2F;kəmˈpætəbl&#x2F;] 类型兼容类型兼容,就是用于确定一个类型 是否能赋值给其他的类型.TS 中的类型兼容性是基于 结构类型 的(也就是形状 shape),如果 A 要兼容 B,那么 A 至少具有 B 相同的属性. 型变 (协变&#x2F;逆变) &amp; Duck Type 鸭子类型 什么是鸭子类型?一只鸟 走路像鸭子 ,游泳也像,做什么都像,那么这只鸟就可以成为鸭子类型.– duck type A B 两个类型完全不同但是可以赋值并无报错,B 类型充当 A 类型的子类型,当子类型里面的属性满足 A 类型就可以进行赋值,也就是说不能少可以多,这就是协变. 逆变TypeScript 给 JavaScript 添加了一套静态类型系统,是为了保证类型安全的,也就是保证变量只能赋同类型的值,对象只能访问它有的属性、方法.这是类型检查做的事情,遇到类型安全问题会在编译时报错. 子类型是可以赋值给父类型的变量的,可以完全当成父类型来使用,也就是”型变(variant)”(类型改变). 这种”型变”分为两种,一种是子类型可以赋值给父类型,叫做协变(covariant),一种是父类型可以赋值给子类型,叫做逆变(contravariant). 对于 字面量类型 采用 协变 的变换规则,即 子类型 &#x3D;&gt; 父类型, 看下面,因为 a 具备 string 的可能,没办法直接赋值给 b.但 b 可以赋值给 a, 子类型可以赋值给父类类型, 这就是协变. covariant (variant [&#x2F;‘veərɪənt&#x2F;] n. 变体 adj. 不同的) 而对于 函数的参数类型,采用完全相反的规则,即逆变 (contravariant),允许父类型赋值给子类型,因为函数中是以父类型进行的约束,赋值一个限制更明确的子类型反而会造成意料之外的问题. 协变和逆变在类型体操的时候会常常出现.当然不论是协变还是逆变,它们首先得是 型变.型变都是针对父子类型来说的,非父子类型自然就不会型变也就是不变(invariant).ts 中父子类型的判定是按照结构 来看的,更具体的那个是子类型. 开启双向协变 tsconfig strictFunctionTypes 设置为 false 支持双向协变 fna fnb 随便可以来回赋值 TS 泛型工具泛型工具 是一组预定义的泛型类型和操作符,用于操作和转换类型.它们可以帮助我们编写更灵活、更通用的代码,并提高代码的可读性和可维护性. Partial(adj. 局部的) 和 Required(adj. 必须的)Partial 是一个泛型类型,用于将一个类型的所有属性变为可选.与之相反,Required 是一个泛型类型,用于将一个类型的所有属性变为必选 Pick(选取) 和 Exclude(排除)Pick 用于从一个类型中选取指定的属性.Exclude 是一个类型操作符,用于从一个类型的属性集合中排除指定的属性. Omit用于创建一个新类型,该新类型从原始类型中排除指定的属性. Record约束一个 object 对象的 key,value. Record 工具类型接收两个泛型参数 K 和 T,其中: K 表示创建的新对象需要具有哪些属性,属性可以只有一个,也可以有多个,多个属性时采用 “ 联合类型 “ 的写法. T 表示对象属性的类型. ReturnType这个工具主要适用于函数,能够提取函数所返回的类型. 类型体操类型编程中类型才是一等公民,我们并不能直接传入一个变量或是函数.需要通过 typeof infer 将值转换为类型才可. Extands (扩展)extends 关键词它可以保证某个参数至少具备某个类型, 也就是子类型是父类型的延伸, 扩展. e.g. arr extends unknown[] 意思就是 arr 至少需要满足 unknown[] 的类型, arr 是 unknown[] 类型的延伸, 扩展. Infer 类型推断infer 关键词只能用于 extends 右侧,他们两个需要联动来使用,它的作用是可以完成类型的推导,我们知道在 ts 类型编程中,类型是一等公民,而不使用 infer 的时候,restArr 是无法被推导成一个类型的. 简单来说,在类型编程我们就可以使用 yy extends xx&lt;infer xxx&gt; ? xxx : never 的方式,提取出和 yy 相关的类型,比如这个例子中的去除第一个元素后,剩下的数组类型. 类型条件判断在上面提到 extends 可以用来限制参数的类型,extends 关键词它可以保证某个参数至少具备某个类型,同样地,我们也可以将 extends 与 三元符 来结合,达到类 if 的作用. 以上面的代码为例,arr extends [unknown, …infer restArr] ? restArr : never 可以理解成,arr 可以按照 [unknown, …infer restArr] 来解析吗?如果可以的得到有效值的话,就返回 restArr, 反之返回 never. never(从不) unknown(未知) any(任意) 对对碰在 ts 中,never 表示 永远不可能存在的值, 永远不能取得任何值的地方, 这个类型兜底了所有我们预料之外的情况,并且可以在用户触发这种场景的时候提供编译报错进行报警. 通常在类型编程中,遇到我们 预料之外 不知道该如何对应的值时(对应 null), 应该去使用 never. unknown 则是 可以取得任何值,但是不知道类型的地方. any 大家都很熟悉,使用它将 丧失所有的类型检查, 如果不考虑维护性, 做完就跑路, 大可以将 typescript 写成 anyscript. 映射类型 (Map Type)在 TypeScript 中对象、class 对应的类型是 索引类型(Index Type),映射类型可以用于修改索引类型,也就是将一个集合映射到另一个集合中,比如下面的例子,我们通过定义 MapType 作为映射类型,就可以很轻松地将一系列对象转化成我们需要的类型. 类型提取 (Type Extraction)使用 泛型 (generics) / infer (类型推断) / extands 结合. 这个是类型编程中最为常用的技巧. 提取函数的返回值和参数类型 递归处理 (recursion processing)类型编程所提供的能力并不完全等同于一个普通的编程语言,它是不支持循环的,对于一些需要循环的场景我们不能通过单次类型提取或是直接处理得到我们需要的结果.虽然不支持循环,但是 ts 的类型编程可以支持递归的实现,通过这种方式我们也可以处理这一类复杂场景. 如何深度(即也要处理子对象)将一个对象的属性转换为 readonly? 涉及到两个知识点,一个是 映射类型 (Map type),另一个就是 递归 (Recursion),需要先遍历对象的所有 key,并将每个 key 转化为 readonly,对应 key 映射的 value 我们需要做一个判断,如果这个 value 对应 object 类型,那么我们就对这个 value 再执行一遍我们定义的这个类型函数,反之,直接返回. 需要注意的是,这里额外加上了 T extends any,是为了触发对 完整类型 的计算,ts 只会 对用到的类型展开计算,所以不加的话,后续的 readonly 会由 deepReadonly 代替,而不是深度计算. 递归获取多层 Promise 的返回值. 递归反转数组, 每次我们反转一个元素和剩下的数组序列,然后对剩下的数组序列执行同样的操作即可. End至此,我应该了解了 TypeScript 这个语言的大概,继续学习 Vue 去了. 对于 TypeScript,它是一个很有价值,甚至能对 Pure JavaScript 应用于大型项目中缺陷进行有效弥补的超类.如果遇到阻塞的类型就使用 any,项目的劣化程度只会越来越严重,甚至 typeScript 也会形同虚设.好好地学习一下 typeScript 和类型编程是有意义的."},{"title":"Vue3 正式学习笔记","date":"2023-08-22T07:35:04.000Z","url":"/javascript/vue-tutorial/","tags":[["JavaScript","/tags/JavaScript/"],["JS","/tags/JS/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"],["Element-UI","/tags/Element-UI/"],["UI","/tags/UI/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 正式学习笔记经过了前面 Javascript 和 Nodejs 前置知识的铺垫，我想我应该可以正式学习 Vue 这个前端框架了叭。 先看视频放松下过一遍： 【2023最新版】Vue3从入门到精通，零基础小白也能听得懂，写得出，web前端快速入门教程_哔哩哔哩_bilibili 上面的视频虽然说得是 Vue3 但是是按照 组合式 API 讲解的，Vue3 文档推荐使用 响应式 API 编写代码。不过具体原理大同小异。 reference：创建一个 Vue 应用 | Vue.js 需要用到的组件库、UI、AJAX 请求库 文档。 Element-UI 组件库 axios /ˈæksɪos/ AJAX 请求库 基本用例 | Axios 中文文档 | Axios 中文网 Vue.js 3 HTTP &amp; Axios Tutorial | KoderHQ Vue Route 路由 Pinia 全局状态管理，类似于 LocalStore ？ Pinia | The intuitive store for Vue.js 一文搞懂pinia状态管理（保姆级教程） - 知乎 JavaScript ES6 Asynchronous Promise：箭头函数 - JavaScript | MDN How to study vue?粗略的过了一遍上述文档就可以看这个 《Vue3 入门指南与实战案例》 ：出版说明 | Vue3 入门指南与实战案例 但是上文没有介绍 axios 请求等操作，请看我的文章：Vue-Project-Start-Tutorial Vue 项目快速搭建指南 笔者是用了大概 2 周的业余时间看完以上的文档的，理论知识有了，接下来就是具体的项目实践，推荐阅读 Vue-Admin 的源代码和具体的文章：介绍 | vue-element-admin 这个项目还是用 webpack + vuex 的，待寻找更好的替代品： GitHub - youlaitech&#x2F;vue3-element-admin: 🔥基于 vue3 + vite4 + typescript + element-plus 构建的后台管理系统（配套接口文档和后端源码）。vue-element-admin 的 vue3 版本。 Vue3.3 + Vite4.3 + TypeScript5+ Element-Plus：从零到一构建企业级后台管理系统（前后端开源）_element plus 开源项目-CSDN博客 代码 format 规范：【vue3-element-admin】ESLint+Prettier+Stylelint+EditorConfig 约束和统一前端代码规范 web full stack：web 全栈开发学习路线 1. 前言(Preface) | web全栈体系 Fast StartInstall vue framework in NodeJS 响应式 API 和组合式 APIHelloWorld.vue App.vue main.js 声明响应式状态在组合式 API 中，推荐使用 ref() 函数来声明响应式状态，定义响应式依赖。 计算属性 computed返回值为一个计算属性 ref，通过 publishedBooksMessage.value 访问计算结果，计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。 计算属性值会基于其响应式依赖被缓存 计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建。 Watch 监听器每次响应式状态变化时触发回调函数： 使用 Vite 脚手架 创建项目 Vite Build Single fileGitHub - richardtallent&#x2F;vite-plugin-singlefile: Vite plugin for inlining JavaScript and CSS resources 常用 CSS当谈到 CSS (层叠样式表) 时，有许多常用的属性可用于控制和布局网页元素的外观和行为。以下是几个常用的 CSS 属性的描述： color：color 属性用于设置文本的颜色。可以使用命名颜色（例如 red、blue）或十六进制颜色码（例如 #FF0000）来指定颜色。 font-size：font-size 属性用于设置文本的大小。它接受像素值、百分比、em 等单位。例如，font-size: 16px; 将文本大小设置为 16 像素。 margin：margin 属性用于设置元素的外边距。外边距是元素周围的空白区域，用于控制元素与其他元素之间的距离。可以使用单个值设置所有边距，也可以使用上、右、下、左四个值分别设置各个边距。 padding：padding 属性用于设置元素的内边距。内边距是元素内容与边框之间的空白区域。类似于外边距，可以使用单个值或四个值分别设置各个边的内边距。 background-color：background-color 属性用于设置元素的背景颜色。可以使用命名颜色或十六进制颜色码来指定颜色。例如，background-color: #FFFFFF; 将背景颜色设置为白色。 display：display 属性用于定义元素的显示类型。常见的值包括 block、inline、inline-block 和 none。block 元素在页面中以块级元素的形式显示，占据一整行；inline 元素则在行内显示，不独占一行；inline-block 元素则同时具备块级和行内元素的特性；none 则表示元素不显示。 border 边框 以上只是 CSS 的一小部分常用属性示例。CSS 拥有众多属性，每个属性都有不同的功能和用途，用于控制网页的各个方面，如布局、字体、边框、动画等。"},{"title":"NodeJS 速通笔记","date":"2023-08-22T06:40:10.000Z","url":"/javascript/nodejs-fast-start/","tags":[["JavaScript","/tags/JavaScript/"],["NodeJS","/tags/NodeJS/"],["JS","/tags/JS/"]],"categories":[["JavaScript","/categories/JavaScript/"]],"content":"NodeJS 速通笔记Node.js 教程 | 菜鸟教程 Nodejs 是运行在服务端的 JavaScript 环境.速通 NodeJS 也可以为开发 Vue 应用打下基础.使用 NodeJs 时,不仅实现了应用还实现了一整个 HTTP 服务器,可以避免使用 Nginx 进行提供 HTTP 服务.NPM 是 NodeJS 的一个包管理工具,类似 Python pip. NodeJS 是 单线程单进程 的应用程序,但是 V8 引擎提供了异步执行回调的接口,通过接口可以处理大量并发. Npm 包管理工具 本地安装好之后,express 包就放在了工程目录下的 node_modules 目录中,因此在代码中只需要通过 require(&#39;express&#39;) 的方式就好,无需指定第三方包路径. npm 的包安装分为本地安装(local)、全局安装(global)两种.使用 -g 指定全局安装. 在工程目录使用 package.json 定义包的属性,类似 Python 中的 requirements.txt Nodejs 回调函数异步编程依托于 回调 来实现.Node 使用了大量的回调函数. 例如可以一边读取文件一边执行其他命令,在文件读取完成后,可以将文件内容作为回调函数的参数返回,这样在执行代码时候就没有堵塞和等待 I&#x2F;O 操作 回调函数一般作为函数的最后一个参数出现: 例如读取文件: 非堵塞: 因此,阻塞是按顺序执行的,而非阻塞是不需要按顺序的,所以如果需要处理回调函数的参数,我们就需要写在回调函数内. NodeJS event loop 事件循环Node.js 单线程类似进入一个 while(true) 的事件循环,直到没有事件观察者退出,每个异步事件都生成一个事件观察者,如果有事件发生就调用该 回调函数. 本质上就是一个 事件驱动程序 Node.js 所有的异步 I&#x2F;O 操作在完成时都 会发送一个事件到事件队列. Node.js 里面的许多对象都会分发事件:一个 net.Server 对象会在每次有新连接时触发一个事件, 一个 fs.readStream 对象会在文件被打开的时候触发一个事件. 所有这些产生事件的对象都是 events.EventEmitter 的实例. Nodejs Buffer 缓冲区js 语言没有二进制类型,但是处理 tcp 流或者文件流时候必须使用二进制数据. 使用 Buffer 类(自带的不需要引入),可以创建一个专门存放二进制数据的缓冲区. 详细请参考:Node.js Buffer(缓冲区) | 菜鸟教程 NodeJs Module System 模块系统引入模块 Node.js 提供了 exports 和 require 两个对象,其中 exports 是模块公开的接口,require 用于从外部获取一个模块的接口,即所获取模块的 exports 对象. hello.js 在以上示例中,hello.js 通过 exports 对象把 world 作为 模块的访问接口,在 main.js 中通过 require(&#39;./hello&#39;) 加载这个模块,然后就可以直接访 问 hello.js 中 exports 对象的成员函数了. main.js NodeJS steaming 流 English Version Streams in Node.js have a reputation(n. 名气) for being hard to work with, and even harder to understand.Node.js 中的流因难以使用而闻名,甚至更难理解. Advantages: Memory efficiency&#x2F;i’fiʃәnsi&#x2F;:&#x2F;: 在处理大数据之前,不需要将其全部加载到内存中 Time efficiency(时间效率): 在数据传输过程中, 可以同时处理数据. 不必等到全部数据传输完毕再处理 4 types of streams in Node.js: Readable(可读流): Used for read operation. e.g. fs.createReadStream() Writable(可写流): Used for write operation. e.g. fs.createWriteStream() Duplex(双工流): Used for both read and write operation. e.g. net.Socket Transform(转换流): A type of duplex stream where the output is computed based on input. Readable Streams 可读流Start: Readable.from(): Creating readable streams from iterables (从可迭代对象创建可读流) 从迭代器创建可读流的实用方法, 它保存可迭代器中包含的数据. 可迭代对象可以是同步可迭代对象, 也可以是异步可迭代对象, 参数选项是可选的,除其他外,可以用于指定文本编码. Two Reading Modes: 两种读取模式flowing(流动) and paused(暂停) In flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the EventEmitter interface. 在流动模式下,数据会自动从底层系统读取, 并通过 EventEmitter 接口使用事件尽快提供给应用程序. In paused mode, the stream.read() method must be called explicitly[&#x2F;ɪkˈsplɪsɪt&#x2F;](adv. 明确地) to read chunks of data from the stream. 在暂停模式下,必须显式调用 stream.read() 方法才能从流中读取数据块. In flowing mode, data can be read from the stream using events, such as data, end, and error. In paused mode, you just need to call read() on the stream instance repeatedly until every chunk of data has been read: All Readable streams begin in paused mode but can be switched to flowing mode in one of the following ways: Adding a ‘data’ event handler. Calling the stream.resume() method. Calling the stream.pipe() method to send the data to a Writable. The Readable can switch back to paused mode using one of the following: If there are no pipe destinations, by calling the stream.pause() method. If there are pipe destinations, by removing all pipe destinations. Multiple pipe destinations may be removed by calling the stream.unpipe() method. Writable Streams 可写流start: Writing to a StreamUsing readable.pipe() to write to a writable stream: like it: readableStream.pipe(writableStream) readableStream —-pipe()—&gt; writableStream You can also use async iterators to write to a writable stream, which is recommended Readable and Writable Streams pipline() 管道pipeline() should be used instead of pipe(), as pipe is unsafe. Piping is a way that provide the output of one stream as the input to another stream. 管道是一种方式, 将一个流的输出作为另一个流的输入. output—-pipeline()—-input The Stream Module 流模块The Node.js stream module provides the foundation(基础) upon which all streaming APIs are build. The Stream module is a native module that shipped(装船) by default in Node.js. The Stream is an instance of the EventEmitter class which handles events asynchronously in Node. Because of this, streams are inherently event-based. Stream 模块是 Node.js 中默认提供的原生模块. Stream 是 EventEmitter 类的一个实例,它在 Node 中异步处理事件.因此,流本质上是基于事件的. Here are some important events related to writable streams: error – Emitted to indicate(v. 指示) that an error has occurred while writing&#x2F;piping. pipeline – When a readable stream is piped into a writable stream, this event is emitted by the writable stream. unpipe – Emitted when you call unpipe on the readable stream and stop it from piping into the destination stream. The stream module is useful for creating new types of stream instances. It is usually not necessary to use the stream module to consume streams."},{"title":"JavaScript 快速上手指南","date":"2023-08-19T08:21:59.000Z","url":"/javascript/javascript-fast-start/","tags":[["JavaScript","/tags/JavaScript/"],["Guide","/tags/Guide/"]],"categories":[["JavaScript","/categories/JavaScript/"]],"content":"JavaScript 快速上手指南主要把 JavaScript 的基础语法过一遍，为接下来学习 Vue framework 打基础，因为是自用复习，所以会比较简洁。会加入一些 ES6 的语法特性，并参考以下文档： JavaScript 简介 | 菜鸟教程 语法（Syntax） 每行末尾加分号 ; 注释： 变量&amp;数据类型（Data types）值类型： Number 数字 String 字符串 Boolean 布尔 Null 空 Undefine 未定义 Symbol 符号 引用数据类型： Object 对象 –&gt; RegExp 正则、Date 日期； Function 函数 Array 数组 String 字符串字符串可以是对象 属性： attribute description constructor 返回创建字符串属性的函数 length 返回字符串的长度 prototype 允许您向对象添加属性和方法 方法： method description charAt() 返回指定索引位置的字符 charCodeAt() 返回指定索引位置字符的 Unicode 值 concat() 连接两个或多个字符串，返回连接后的字符串 indexOf() 返回字符串中检索指定字符第一次出现的位置 lastIndexOf() 返回字符串中检索指定字符最后一次出现的位置 match() 找到一个或多个正则表达式的匹配 replace() 替换与正则表达式匹配的子串 search() 检索与正则表达式相匹配的值 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 split() 把字符串分割为字符串数组 …. 模板字符串： Array 数组相当于 Python List 列表 Object 对象相当于 Python 字典 Dict，JavaScript 对象是变量的容器。 变量 变量必须以字母开头 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做） 变量名称对大小写敏感（y 和 Y 是不同的变量） 使用 let 和 const (ES6): let 声明的变量只在 let 命令所在的代码块内有效。const 声明一个只读的常量，一旦声明，常量的值就不能改变。在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。 声明提升 (Declare Hoisting [&#x2F;hɔɪst&#x2F;]): JavaScript 在执行任何代码段之前，将 函数和变量声明放入内存中, 但不会赋值。 这意味着 变量和函数的声明 会在物理层面移动到代码的最前面. 函数和变量相比，函数会被优先提升。这意味着函数会被提升到更靠前的位置。 初始化变量不会提升. 生命周期 JavaScript 变量的生命期从它们被声明的时间开始。 局部变量会在函数运行以后被删除。 全局变量会在页面关闭后被删除。 Scope 作用域Global Scope 全局作用域: 如果不用 var const let 关键字声明变量，那么该变量会被自动声明为全局变量。将被绑定在全局变量 windows 上. Block Scope 块级作用域: var 声明的变量没有块级作用域，它们只有函数作用域. 使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到。 但在函数中用 var 声明变量, 只能在函数内部访问。 ES6 可以使用 let 关键字来实现块级作用域. let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。 Loop scope 循环作用域: 分支语句&amp;循环&amp;判断&amp;控制流（Control flow）条件语句 Switch 选择语句工作原理：首先设置表达式 n（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行。请使用 break 来阻止代码自动地向下一个 case 运行。使用 default 关键词来规定匹配不存在时做的事情。 For 循环Statement 1 在循环开始之前设置变量 (var i&#x3D;0)。Statement 2 定义循环运行的条件（i 必须小于 5）。Statement 3 在每次代码块已被执行后增加一个值 (i++)。 While 循环while 循环会在指定条件为真时循环执行代码块。break; continue; 同样用于跳出和继续循环。 函数&amp;模块 （Functions） JS return 只能返回一个数据 JS Function 是一个函数对象： typeof -&gt; function JavaScript 函数有 属性 和 方法。.length-&gt;返回接收的参数个数 .toString()-&gt;将函数作为一个字符串返回 函数表达式JavaScript 函数可以通过一个表达式定义。函数表达式可以 存储在变量 中： 以上函数实际上是一个 匿名函数 (类似 Python limbda a:a+1 函数没有名称)。函数存储在变量中，不需要函数名称，通常通过变量名来调用。 Function 构造函数 （最好不用） 在 JavaScript 中，很多时候，你需要避免使用 new 关键字。 函数本质上是一个 object ，可以通过 new Function() 函数构造器定义。 函数提升 （Hoisting）类似 var 时的变量提升，使用表达式定义函数时无法提升。 提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的行为。 提升（Hoisting）应用在变量的声明与函数的声明。 匿名函数 (Anonymous function)自调用函数 | 立即执行函数 （self invoking） 函数表达式 可以 “ 自调用 “。 自调用函数会随着浏览器启动自动运行。 如果表达式后面紧跟 () ，则会自动调用。 不能自调用声明的函数。 通过添加括号，来说明它是一个函数表达式 以上函数实际上是一个 匿名自我调用的函数 (没有函数名)。 箭头函数 ES6 (arrow[&#x2F;ˈærəʊ&#x2F;] function) 箭头函数 没有 自己的 this。 不适合作为定义一个 对象的方法 (类似 class)。 当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。 箭头函数是 不能提升 的，所以需要在使用之前定义。 使用 const 比使用 var 更安全，因为函数表达式始终是一个常量。 如果 函数部分只是一个语句，则可以省略 return 关键字和大括号 {} Format: e.g. for example: 函数参数 (args &#x3D;&#x3D;&gt; arguments)Parameters （显性参数） Arguments （隐式参数）JavaScript 函数有个内置的对象 arguments 对象。arguments 对象包含了函数调用的参数数组，可以传入不定数量的参数。 Default Args (默认参数)如果函数在调用时未提供隐式参数，参数会默认设置为： undefined 值传递和引用对象传递 通过值传递给函数，函数对值的更改，在函数外部是不可见的。 通过引用对象传递给函数，函数接收到的是 引用对象的指针，在函数内部对引用对象的修改是可以影响到函数外部原本的对象的。 函数调用（function invoking）in general. this 指向函数执行时当前的对象。在浏览器环境，this 指向的是 windows 对象，为浏览器环境的全局对象。 全局对象： func as obj methods invoking: 使用构造函数调用函数：如果在函数调用前使用了 new 关键字，就是调用了构造函数。 作为函数方法调用函数： function 就是一个 Object 他有自己的 attribute 和 methods. call() apply() 是预定义的函数方法，这两个方法用于调用函数，第一个参数必须是函数 this 的对象本身： 函数闭包 （Function Closure） 变量的生命周期 变量的作用域：所有函数都能访问全局变量。在 JavaScript 中，所有函数 都能访问它们上一层的作用域。 闭包是一种保护函数私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰： 匿名函数内部定义的变量和函数 只能在函数内部访问，外部无法直接访问，从而实现了信息的封装和隐藏。如果要实现外部访问，可以通过 return 一个函数或者 obj 来实现外部访问。 高阶函数 （Higher-Order Function）接收另一个函数作为参数的函数，或者返回一个函数。 JS import 模块Ref：import - JavaScript | MDN 类 （class）对象Create class 创建类类是用于创建对象的模板。 使用 class 关键字来创建一个类，类体在一对大括号 {} 中，我们可以在大括号 {} 中定义类成员的位置，如方法或构造函数。 每个类中包含了一个特殊的方法 constructor() （构造器），它是类的 构造函数 （类似 Py def __init__(self)），这种方法用于创建和初始化一个由 class 创建的对象，初始化对象的 attribute。 类表达式：类表达式是定义类的另一种方法。类表达式 可以命名或不命名。命名类表达式的名称是该类体的局部名称。 Extends class 继承类super() 用于调用父类的构造函数 constructor() JavaScript 并没有像其他编程语言一样具有传统的类，而是基于 原型的继承模型。ES6 引入了类和 class 关键字，但底层机制仍然基于原型继承。ES6 引入了 class 关键字，使得定义类和继承更加清晰，extends 关键字用于建立继承关系，super 关键字用于在子类构造函数中调用父类的构造函数。 基于 原型链 (prototype /ˈprəʊ.tə.taɪp/ ) 的继承： 在下面实例中，Animal 是一个基类，Dog 是一个继承自 Animal 的子类Dog.prototype 使用 Object.create(Animal.prototype) 来创建一个新对象，它继承了 Animal.prototype 的方法和属性，通过将 Dog.prototype.constructor 设置为 Dog，确保继承链上的构造函数正确。 Getter and setter类中我们可以使用 getter 和 setter 来获取和设置值，getter 和 setter 都需要在严格模式下执行。getter 和 setter 可以使得我们对属性的操作变的很灵活。 类中添加 getter 和 setter 使用的是 get 和 set 关键字。 即使 getter 是一个方法，当你想 获取属性值时也不要使用括号。 使用 setter，请使用与设置属性值时相同的语法，虽然 set 是一个方法，但需要 不带括号 getter/setter 方法的名称不能与属性的名称相同，在本例中属名为 sitename。 很多开发者在属性名称前使用下划线字符 _ 将 getter/setter 与实际属性分开： 类提升（class Not hoisting）函数声明和类声明之间的一个重要区别在于, 函数声明会提升，类声明不会。你首先需要声明你的类，然后再访问它，否则将抛出 ReferenceError Class static method (类静态方法)静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 类名.方法名 调用静态方法。 静态方法不能在对象上调用，只能在类中调用。 This keyword this 关键字面向对象语言中 this 表示当前对象的一个引用。 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的 (undefined)。 在事件中，this 表示接收事件的元素。 类似 call() 和 apply() 方法可以将 this 引用到任何对象。（#1） 显式函数绑定： 在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法： 异常处理 （Exception handling）当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。描述这种情况的技术术语是：JavaScript 将**抛出 (throw)**一个错误。 javascript:void(0) 含义javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。 JavaScript Asynchronous 异步JavaScript 中的异步操作函数往往通过 回调函数 来实现异步任务的结果处理。回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。 JavaScript Promise | 菜鸟教程 JS Promise Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。 通过回调里的 resolve(data) 将这个 Promise 标记为 resolverd，然后进行下一步 then((data)&#x3D;&gt;{&#x2F;&#x2F;do something})，resolve 里的参数就是你要传入 then 的数据。 用于多次调用异步函数，避免回调地狱，如： 用 Promise 实现相同功能： Promise 将嵌套格式的代码变成了顺序格式的代码。 Promise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数。 Promise 构造函数接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，分别表示 Promise 成功和失败的状态。 起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。 Promise 构造函数返回一个 Promise 对象，该对象具有以下几个方法： then：用于处理 Promise 成功状态的回调函数。 catch：用于处理 Promise 失败状态的回调函数。 finally：无论 Promise 是成功还是失败，都会执行的回调函数。 resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。 then 方法可以接收两个回调函数作为参数，第一个回调函数是 Promise 对象的状态改变为 resoved 是调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中第二个参数可以省略。 这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。 异步函数 async function一个返回 Promise 对象的 Promise 函数： 用不同的时间将 顺序输出 三行文本： 可以使用 await 等待异步函数的执行完成，增加代码可读性：异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。 处理异常也可以用 thy-catch 机制实现： 如果 Promise 有一个正常的返回值，await 语句也会返回它： 进阶 (Advanced)事件循环 event loopRef: Youtube: JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue 定义: JS 是单线程 (single thread) 的在 Chrome V8 引擎中, 主线程不断地重复获取执行信息, 再执行. 不断循环的机制称为事件循环. 为什么: JS 是单线程的 再处理异步操作的时候需要事件循环机制 JS 运行时概念 (JavaScript Runtime Concept): 堆 (Heap): 大块非结构化内存区域, 储存对象,数据. 栈 (Call Stack): 调用栈 储存该次循环待主程序执行的任务. 队列 (Queue): 事件队列, 先进先出被推入调用栈中. Web APIs 提供异步操作, 回调的宏任务 微任务队列 (Tasks queue &#x2F; microtask): Primise.then(…).catch(…).finally(…) 宏任务队列 (macros[&#x2F;‘mækrəʊ&#x2F;] queue): 一些 Web Api: fecth setTime IntervalTime 事件循环 (Event Loop) : 负责 调度 tasks queue 和 macros queue 将其放入到 Call stack 中. 具体是检测 Call stack 中是否有函数执行, 如果没有就先从 macros queue(微任务队列) 拿函数到 call stack 运行, 再从 tasks queue(宏任务队列) 拿取执行. Loop’s responsibility to check if the call stack is empty, and if that is case so if nothing is running and then gets the first available task from the task queue. Call stack (调用栈) 处理函数嵌套调用: WebAPI 提供与浏览器交互的能力, 常用于耗时的异步任务: Web api 的调度过程 (Scheduling process) microtask queue(微任务队列): 微任务 (microtask) 与 宏任务 (macro task) 的优先级 Process.nextTick(callback)这是一个 nodeJS 的方法, 他的 callback 是一个微任务 micro task, 他的 优先级最高, 会排在所有 microtask 的前面. 用于将异步任务尽可能早得执行. 在全部代码执行完成之后, 进入 event loop 事件循环之前会立即调用. 如果下面代码不加 process.nextTick(callback) callback 可能在主线程中直接执行, 也可能在 eventloop 的 IO 轮询阶段被调用. 不可预测. 加上能使得 readFile full asynchronous 完全异步. setImmediate(callback)表示立即执行, 它是 macro task(宏任务), callback 会被放置在 event loop 的 check 阶段, 这个阶段不会阻塞 main thread 和 event loop. 在应用中, 如果有大量的 CPU binding(CPU 计算密集型) 任务, 它是不适合放在主线程中执行的, 因为计算任务会 block 主线程, 所以这种类型的任务最好交给由 C++ 维护的线程执行. JS 原型链 (JS prototype chain)原型链是 JS 实现继承的重要原理. 构造函数如果一个函数用 new xxx() 的方式调用，这个函数就称为构造函数，相当于 ES6 中的 class 语法糖。在构造函数中的 this 原先是 null，可以在函数内部通过 this.xx 的方式赋予 value 和 method，new 这个函数返回的就是 this 这个对象。 使用 class 语法糖： prototype Attributeprototype 是 构造函数、class 类，独有的一个 对象。prototype 是 函数才会有的属性 函数的 prototype 属性指向了一个 原型对象，这个对象正是调用该构造函数而创建的 实例 的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个 JavaScript 对象 (null 除外) 在创建的时候就会与之关联另一个对象，这个对象就是我们所说的 原型，每一个对象都会从原型 “ 继承 “ 属性。 __proto__ Attribute__proto__ 这是每一个 JavaScript 对象 (除了 null ) 都具有的一个属性，叫 proto，这个属性会指向该对象的原型。 __proto__ 被称为 对象 的 隐式原型，对应的是构造函数（类）的 prototype 原型对象 Constructor 构造器每个原型对象都有一个 constructor 属性指向关联的构造函数。 综上： 原型链构造函数（类）的原型对象也是一个对象 object，所以他也具有 __proto__ 隐式原型属性，指向 object 对象的构造函数（类）的原型对象 Object.prototype 。 所以对象的隐式原型的原型对象构成一条原型链： 对象寻找数值，是原型链从下到上一直找到原型链顶端，用 冒泡 的方式查找的。 浏览器储存 (Browser Storage [&#x2F;ˈstɔːrɪdʒ&#x2F;]) 跨域资源共享 Cross-Origin Resource Sharing (CORS) JavaScript 模块化 打包 捆绑器 (Module Bundler[&#x2F;ˈbʌndəl&#x2F;]) Webpack Note: 通常使用 babel 作为 webpack 的 compiler，将 ES6 语法转换为 ES5 语法。 "},{"title":"Python 黑魔法","date":"2023-08-11T02:51:51.000Z","url":"/python/python-black-magic/","tags":[["高级编程","/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"],["Python","/tags/Python/"],["coding","/tags/coding/"]],"categories":[["Python","/categories/Python/"]],"content":"Python 黑魔法记录一些 Python 语言独有的，不太常见的写法，方便进行库的开发。一般我在读源码的时候可以碰见很多没有见过的魔术方法和神奇实现，所以把它记录下来。 Getattr (get attribute 获取属性)source code: Pyrogram Conversation-Pyrogram getattrgetattr() 是 Python 的一个内置函数，用于获取对象的属性值。它接受两个参数：对象和属性名，并返回属性值。 语法： object: 要获取属性值的对象。 name: 属性名。 default (可选): 如果属性不存在，则返回 default 值（默认为 None）。 示例： 在上述示例中，通过 getattr(obj, &#39;foo&#39;) 获取了对象 obj 的属性 foo 的值，返回结果为 42。而通过 getattr(obj, &#39;bar&#39;, &#39;default value&#39;) 获取了对象 obj 的属性 bar 的值，由于该属性不存在，所以返回了指定的默认值 ‘default value’。 getattr() 的特点是可以在 运行时动态地获取属性值，而不需要提前知道属性的名称。这在处理需要根据不同条件获取不同属性值的情况下非常有用。 __getattr__ 魔术方法在类中定义 __getattr__ 方法可以实现自定义的属性访问逻辑。当访问一个不存在的属性时，Python 解释器会自动调用 __getattr__ 方法，传入属性名作为参数，并期望返回一个值。 以下是一个示例： 在上述示例中，当访问 obj.foo 属性时，由于该属性不存在，Python 解释器会调用 __getattr__ 方法，并将属性名 “foo” 作为参数传入。 __getattr__ 方法打印了一条消息并返回了 42。 需要注意的是，如果一个类定义了 __getattr__ 方法，那么该方法只会在访问不存在的属性时被调用。对于已经存在的属性，仍然会直接访问。如果需要在访问任何属性时都进行拦截，可以使用 __getattribute__ 方法。 loop.run_until_complete() Vs asyncio.runpython - asyncio run or run_until_complete - Stack Overflow loop.run_until_complete() 是用于在一个已存在的事件循环中运行一个协程，它会一直运行直到协程完成或抛出异常。这个函数在 Python 3.7 之前是主要的运行协程的方法。 而 asyncio.run() 是在 Python 3.7 中引入的一个方便的函数，它会创建一个新的事件循环并在其中运行一个协程。它会一直运行直到协程完成或抛出异常，并且在协程完成后会自动关闭事件循环。 使用 loop.run_until_complete() 时，你需要先创建一个事件循环对象，并在使用完后手动关闭它。而使用 asyncio.run() 时，你不需要手动创建和关闭事件循环，它会自动处理这些细节。 以下是使用 loop.run_until_complete() 和 asyncio.run() 的示例： Copy 总结来说，loop.run_until_complete() 适用于在已存在的事件循环中运行协程，而 asyncio.run() 适用于创建一个新的事件循环并运行协程，并且它能够自动处理事件循环的创建和关闭。在 Python 3.7 及更高版本中，推荐使用 asyncio.run() 来运行协程。 @contentmanager在 Python 中，@contextmanager 是一个装饰器，用于创建上下文管理器。上下文管理器是一个对象，它定义了在进入和退出上下文时要执行的代码块。通常，上下文管理器用于管理资源的分配和释放，例如打开和关闭文件，获取和释放锁等。 @contextmanager 装饰器可以应用于一个生成器函数，该函数使用 yield 语句来定义进入和退出上下文时的操作。被装饰的生成器函数必须返回一个上下文管理器对象。 当使用装饰器 @contextmanager 装饰一个生成器函数时，该函数将被转换为一个上下文管理器对象。装饰器会自动处理进入和退出上下文的逻辑，并在进入上下文时返回生成器的迭代器，以便在进入和退出上下文时执行相应的代码。 下面是一个使用 @contextmanager 装饰器的示例： 在上面的示例中，file_manager 函数被装饰为上下文管理器。在 with 语句块中，文件 example.txt 被打开，并在退出上下文时自动关闭。在 yield 语句之前的代码块表示进入上下文时要执行的操作，yield 语句之后的代码块表示退出上下文时要执行的操作。在 with 语句块中，可以使用 f 变量来访问文件对象，并在其中执行相应的操作。 使用 @contextmanager 装饰器可以简化上下文管理器的创建过程，使代码更加简洁和可读。 异步 sqlite3 GitHub - omnilib&#x2F;aiosqlite: asyncio bridge to the standard sqlite3 module Python enum 枚举类型enum — 枚举类型支持 — Python 3.7.13 文档 AsyncGenerator func hint异步生成器、异步迭代器函数注解： AsyncGenerator 类型应该使用 AsyncGenerator[YieldType, SendType] 的形式来表示，其中 YieldType 是生成器产出的值的类型，而 SendType 是使用 yield 语句发送给生成器的值的类型。 @dataclass 装饰器@dataclass 是 Python 3.7 中引入的一个装饰器，用于简化数据类的定义。数据类是一种用于存储数据的类，通常包含一些属性和方法，用于表示和操作数据。 Python 3.10 新特性海象运算符 := (walrus operator) 是 Python 3.8 中引入的一个新特性，它允许在 表达式中同时进行赋值和比较操作。在 Python 3.10 中，海象运算符的使用范围得到了扩展，可以在 if 语句中使用海象运算符。其实借鉴了 Go 语言的写法。这使得代码更加简洁，并且避免了引入不必要的临时变量。 before: now: 对某些需要跳出 while 循环的情况, 尤其是分片读取文件时, 这个特性非常有用。 "},{"title":"【科普向】如何在 China 轻松免费使用 ChatGPT","date":"2023-07-24T09:40:07.000Z","url":"/how-to-ues-free-chatgpt-in-china/","tags":[["AI","/tags/AI/"],["ChatGPT","/tags/ChatGPT/"],["小白","/tags/%E5%B0%8F%E7%99%BD/"],["科普","/tags/%E7%A7%91%E6%99%AE/"]],"categories":[["ChatGPT","/categories/ChatGPT/"]],"content":"【科普向】如何在 China 轻松免费使用 ChatGPT StartChatGPT，是一个由美国公司 OpenAI 开发的一个基于大数据文字模型的人工智能系统。简单来说就是可以聊天帮你解决问题的一个对话系统。 众所周知，China Gov 因为一些原因将 ChatGPT 拒之门外，宛如当年满清慈禧太后将西人的蒸汽机车拒之国门外的场景，十分讽刺。 据记载，1888年清朝政府在北京西苑修建了一条铁路，慈禧太后因火车司机坐在自己前面开车，弃用了从德国引进的蒸汽机车而改用太监牵拉。——《全球通史》 综上所述，在中共国，墙内的鼠鼠们有以下渠道可以自由使用 ChatGPT： 使用 魔法 软件，进入 国际互联网，使用官方 ChatGPT 的服务器。门槛较高，需要非86手机号注册 OpenAI Account 但可以稳定使用。魔法软件的使用请看我的这篇文字 Clash 小猫咪使用备忘 | 😊落落のBlog😊 使用国内套壳的 ChatGPT 镜像网站，这种一般是个人自建，隐私和安全性得不到保障，内容也有所审查。缺点是不稳定可能随时跑路。优点是免费。 使用国内的其他 AI 服务代替，例如 百度 文心一言 之类的云云。当然相比正统 ChatGPT ，这些只是个玩具。 基于本文针对的对象是想体验并使用 ChatGPT 的小白白，本文主要阐述第二种方案。 GitHub Free GPT 项目这是一个公开的 GitHub Repo 会分享一些国内可用的 ChatGPT 镜像地址，点进去就可以使用了 链接：GitHub - LiLittleCat&#x2F;awesome-free-chatgpt: 🆓免费的 ChatGPT 镜像网站列表，持续更新。List of free ChatGPT mirror sites, continuously updated. （国内网络打开 GitHub 链接缓慢） 下面是一些网站的 URL，请注意时效性。 自用 笔者自用的是 EasyGPT地址发布页 用了几个月比较稳定，3.5 模型也是免费的，点进去就会出现一个 EasyGPT 的导航页，挑一个延时小的使用。如果一个网址不可使用，返回引导页再尝试另一个。若服务完全不可用，请尝试下文提供的 GitHub 镜像网址合集。 WAN: 使用第三方 ChatGPT 国内套壳服务时 请勿提交敏感信息，网站运营者 会查看的到你提交的任何内容. 若提交一些 NSFW (NOT SEE FOR WORK) 及一些涉政的内容，网站运营者可能会把你的 IP 地址提交给网安国保之类的机构，请鼠鼠们注意！ 镜像合集 2023&#x2F;7&#x2F;24 update 序号 网站 标签 添加时间 备注 1  🆓 💪 2023-07-11 2  🆓 💪 2023-07-07 3  🆓 💪 2023-07-07 4  🆓 💪 2023-06-25 5  🆓 💪 2023-06-18 备用链接:  6  🆓 💪 2023-06-17 7  🆓 2023-07-13 8  🆓 2023-07-12 9  🆓 2023-07-11 10  🆓 2023-07-10 11  🆓 2023-07-10 12  🆓 2023-07-09 13  🆓 2023-07-08 访问码:754685. 14  🆓 2023-07-04 15  🆓 2023-07-01 16  🆓 2023-06-30 17  🆓 2023-06-29 18  🆓 2023-06-28 19  🆓 2023-06-26 20  🆓 2023-06-26 21  🆓 2023-06-25 22  🆓 2023-06-24 23  🆓 2023-06-23 24  🆓 2023-06-17 25  🆓 2023-06-16 26  🆓 2023-06-15 27  🆓 2023-06-14 28  🆓 2023-06-13 29  🆓 2023-06-13 30  🆓 2023-06-08 31  🆓 2023-06-08 32  🆓 2023-06-06 33  🆓 2023-06-02 34  🆓 2023-06-01 35  🆓 2023-06-01 36  🆓 2023-06-01 37  🆓 2023-05-31 38  🆓 2023-05-31 39  🆓 2023-05-29 40  🆓 2023-05-26 41  🆓 2023-05-26 "},{"title":"Openwrt LEDE 固件自定义编译笔记","date":"2023-07-15T06:49:21.000Z","url":"/openwrt-lede-build-note/","tags":[["Linux","/tags/Linux/"],["OpenWRT","/tags/OpenWRT/"]],"categories":[["OpenWRT","/categories/OpenWRT/"]],"content":"Openwrt LEDE 固件自定义编译笔记LEDE 有些软件 Openwrt 没有。比如我认为很重要的硬解 nat。lean 对国内用户也比较友善。 LEDE 项目地址：GitHub - coolsnowwolf&#x2F;lede: Lean’s LEDE source 参考看完这篇，自定义 OpenWrt&#x2F;LEDE 路由固件不求人 - 少数派 编译前的准备Dedian11、Ubantu18 以上的系统，根据文档安装好依赖。保持使用 Clash Tun 模式进行代理，在 Vmare 虚拟机上进行。 自定义固件根据菜单自定义 选择 docker Base system取消选中 dnsmasq选中 dnsmasq-full因为 dnsmasq-full 支持 ipset 功能，对于基于域名的 xx 很有用。 Network-&gt;File Transfer 中选中 ssh ntpcurlwget【两个下载工具】 Network-&gt;IP Addresses and Names 中选中bind-digddns-scripts_No-IP_com。（用来支持 no-ip.com 的 ddns 服务）一个是测试工具；另一个是某个 ddns 支持，还有其他 ddns 支持，也可以酌情选中。 Network-&gt;Routing and Rediction 中选中ip-full这个很关键。Network 中选中iperf3ipset一个是测试工具；另一个是 ipset，用于支持基于域名的 xx。 Network-&gt;Web Servers&#x2F;Proxies 选中那些 SS，如果您需要使用 SS 的话。Utilities-&gt;Editors 中选nano （也可以选 vim）Utilities-&gt;Shells 中选中bash点击 Save，保存为.config。一路 Exit 退出。在输入 make 开始编译。 源码修改修改默认语言主题：修改 vim feeds&#x2F;luci&#x2F;modules&#x2F;luci-base&#x2F;root&#x2F;etc&#x2F;config&#x2F;luci 文件: 修改主机名，设定时区，IP 地址: vim package&#x2F;base-files&#x2F;files&#x2F;bin&#x2F;config_generate SSH&#x2F;TELNET 显示信息修改方式:vim package&#x2F;base-files&#x2F;files&#x2F;etc&#x2F;banner 修改路由连接数vim package&#x2F;base-files&#x2F;files&#x2F;etc&#x2F;sysctl.confnet.netfilter.nf_conntrack_max&#x3D;65535 Openwrt 编译，修改lan、wan口，ip，拨号 - 简书拨号 编译 OpenClash 小猫咪编译带 OpenClash 的 OpenWrt 固件 | 心底的河流 行为管控 编译openwrt编译openclash-老徐小屋 使用 GitHub Action使用 p3terx 大佬的脚本。 GitHub Actions 在线云编译 OpenWrt 固件 - P3TERX ZONE 编译时空间不足问题： OpenWRT在Actions编译过程中因磁盘空间不足从而编译失败，如何清理磁盘空间？ · Issue #11159 · coolsnowwolf&#x2F;lede · GitHub 减少编译所用空间 · Issue #7004 · coolsnowwolf&#x2F;lede · GitHub 缓存 cache 加速编译： 使用github actions cache缓存工具链， 加速你的云编译项目，让你做更快的男人 by stupidloud · Pull Request #7796 · coolsnowwolf&#x2F;lede · GitHub 自定义编译GitHub - VIKINGYFY&#x2F;OpenWRT-CI: 云编译OpenWRT固件 官方源 OpenClash 定时任务 OpenClash DocsDNS污染对Clash（for Windows）的影响 · Fndroid&#x2F;clash_for_windows_pkg Wiki · GitHub"},{"title":"Clash 小猫咪使用备忘","date":"2023-07-09T02:26:56.000Z","url":"/clash-proxy-tutorial/","tags":[["Proxy","/tags/Proxy/"],["Clash","/tags/Clash/"]],"categories":[["Proxy","/categories/Proxy/"]],"content":"Clash 小猫咪使用备忘Clash is a rule-based tunnel in Go. Clash is a cross-platform rule-based proxy utility that runs on the network and application layer, supporting various proxy and anti-censorship protocols out-of-the-box. It has been adopted widely by the Internet users in some countries and regions where the Internet is heavily censored or blocked. China Anti-censorship: censorship.ai | 揭示和规避中国对加密SNI（ESNI）的封锁 anti-censorship &#x2F;ˌæn.tiˈsen.sə.ʃɪp&#x2F; adj. 反审查 cambridge dictionary DocumentGitHub: GitHub - Dreamacro&#x2F;clash: A rule-based tunnel in Go.official document: What is Clash? | ClashClash for Windows config file: 配置文件 | Clash for Windows Use ClientUse Raw Console ProgramThe main configuration file is called config.yaml.Use command-line option -d to specify a configuration directory.use option -f to specify a configuration file OpenWRT OpenClashReleases · vernesong&#x2F;OpenClashHome · vernesong&#x2F;OpenClash Wiki · GitHub 内核文件下载Release Clash · vernesong&#x2F;OpenClash · GitHub Dev 内核下载:  内核下载:  游戏内核:  INSTALL curl 故障：重新安装 libmbedtls[Bug] 升级后更新功能错误 · Issue #3386 · vernesong&#x2F;OpenClash · GitHub Config FileFake-IPref: 浅谈在代理环境中的 DNS 解析行为 | Sukka’s Blog 在 Client 端设置 Socks5 代理的分流过程： 但是使用 Route 透明代理、全局 tun&#x2F;tun2socks 代理时，此时应用程序是 不会感知到代理客户端的存在，它们会正常的 发起 TCP 连接，并且由于 TCP&#x2F;IP 协议，在拿到 DNS 解析结果之前，连接是不能建立的。 在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。 —— TCP&#x2F;IP 协议 当 Proxy 运行在 tun 模式的透明代理时： 和应用程序直接将流量 封装成 SOCKS5 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此需要得到一个 DNS 解析结果，才能建立 TCP 连接；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名，进行分流。 浏览器、应用程序直接设置 SOCKS5 代理的话，可以不在代理客户端发起 DNS 解析请求 就能将流量发送给远端服务器；而在 透明代理模式 下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。 而且 DNS 解析的过程在 Proxy Server 上实现，远端服务器只能获取到解析出来的 IP，对于 CDN 优化不好。 如果是支持 redir 的代理客户端，那么代理客户端就会直接将 域名 和 TCP content 封装成 某种协议 发给远端服务器，总之解析域名 DNS 和请求将在远端服务器进行，最大程度优化 CDN 速度。 Fake-ip 和 Redir-host 两个模式，从速度上看，那个有优势？如果综合看那个更有优势？ · Issue #974 · vernesong&#x2F;OpenClash · GitHub Fake-IP 实现过程： Fake-IP 能够省下 Client 向远端 DNS 请求 IP 的过程，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接。 Fake-IP 技术更加适合根据 IP 规则分流、Route 透明代理 的情景，如果应用程序直接将流量封装成 SOCKS5 可以不在 Client 发起 DNS 请求就能把浏览转发到 Proxy Server.而在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。 Fake-IP 可以使域名解析在远端服务器上进行，能有效优化 DNS 解析速度。 实际使用 Fake-IP 可能导致映射表丢失，导致浏览器或者本地缓存了错误的 DNS 解析结果比如 192.168.16.7 --&gt; google.com 这时需要清除 DNS 缓存才行。 "},{"title":"Onedrive 完全使用指南","date":"2023-06-03T03:05:50.000Z","url":"/onedrive-guide/","tags":[["onedrive","/tags/onedrive/"],["云盘","/tags/%E4%BA%91%E7%9B%98/"],["Rclone","/tags/Rclone/"]],"categories":[["onedrive","/categories/onedrive/"]],"content":"Onedrive 完全使用指南前言最近一直在寻找一个国内使用的高可用不限速的在线云盘存储，试过了很多国内的云盘存储，不是有内容审查就是网盘限速。这些网盘都拘泥于一个固定的客户端，不能做到 多端可用、随地随用、增量同步。 就选择了 Onedrive 这个云盘，在小咸鱼买了一年 39 CNY 的 office365 家庭版拼车。Onedirve 家庭版可以支持 6 个用户，每个用户有 1T 的 onedrive 空间和 5 台设备的 office365 授权。 Onedrive 支持将云空间挂载到各种软件上，例如：Rclone、Alist、oneindex。可以支持直链共享，目测在中国大陆的网速也不错。​ 创建 OneDrive API获取 client_id 首先访问 Microsoft Azure 应用注册，登录账号后点击 应用注册 填写以下信息： ​点击注册后可以看到你的应用的相关信息，复制好 应用程序 (客户端) ID ，这个就是 client_id。 ​​ 获取 client_secret 依次点击 证书和密码，新客户端密码，在截止期限中将时间选择为最长（即两年） ​​ 然后就可以看见值和机密 ID，我们只需要记录下 值 就可以，这个就是 client_secret。 ​​ 添加 API 权限依次点击 API 权限，添加权限，Microsoft Graph，在右边栏搜索并添加权限。 需要 Files.Read, Files.ReadWrite,Files.Read.All, Files.ReadWrite.All, offline_access, User.Read 。 ​​​ 添加以下权限： ​​ 添加身份验证依次点击 身份验证，添加平台，Web ​ ​在重定向 URI 中输入  ​​至此，OneDrive API 创建完成 使用 RcloneRclone 是一个用于多个云平台之间同步文件和目录的命令行工具，其支持多种运营商网盘。使用 Golang 编写，所以跨平台兼容性良好。 支持 RC 接口可以通过 API 或 Web UI 操作。 官网网址： 开源地址： 中文文档部分翻译：  rclone 中文站点：  DockerRclone can serve a web based GUI. ​rclone rcd --rc-web-gui​​ 53682 为 微软令牌验证端口  打开  并登录显示以下页面： ​​ 进入 docker bash：docker exec -it rclone sh​, 输入 rclone config ，按照提示进行 onedrive 设置。 远程 OA 验证：; 验证完毕后可以在 Explorer 查看文件： ​### Rclone 常用命令 语法： 常用功能选项： 常用参数： 授权保活If you don’t use rclone for 90 days the refresh token will expire. This will result in authorization problems. This is easy to fix by running the rclone config reconnect remote:​ command to get a new token and refresh token. 如果在 90 天内不使用 rclone，刷新令牌将过期。这将导致授权问题。通过运行 rclone config reconnect remote: 命令获取新令牌并刷新令牌，可以轻松解决此问题。 重新运行授权： 命令示例将 onedrive 上的全部内容下载到本地： ​​​ 速度还行，将旧的 onedrive 文件一同迁移到本地硬盘。 双向同步 仅同步备份到云盘，考虑到云盘备份不需要特别高的实时性，不需要双向同步，所以我选择通过 sync 将硬盘内容定时上传到云盘。; 将源同步到目标，仅更改目标。不传输源和目标上相同的文件，按大小和修改时间或 MD5SUM 进行测试。 目标更新以匹配源，包括在必要时删除文件（重复对象除外，见下文）。如果不想从目标位置删除文件，请改用复制命令。 ​​ 这是一个关于 bisync​ 命令的错误信息。该错误信息表明，在上一次运行 bisync​ 命令时出现了致命错误，导致无法找到先前的 Path1​ 或 Path2​ 列表。因此，bisync​ 命令无法确定哪些文件需要同步，因此它需要使用 --resync​ 选项来恢复同步操作。 如果您需要在生产环境中进行文件同步操作，建议使用其他可靠的工具，如 rsync​ 或 robocopy​。这些工具已经被广泛使用，并且已经被证明是可靠的文件同步工具。 主配置翻译 同步坚果云因为坚果云 Webdav 有并发限制，所以需要限制线程数慢慢拉取。 将坚果云拉取到本地。 在容器内定时运行同步命令 Alpine：已经预装，可以使用 which crond​ 查看。 对于 Docker 容器来说，多用户的作用不大，只需要专注全局的配置文件：/etc/crontab​ 即可。 通过 Crantab 实现定时备份写一个备份脚本：rclone_bak.sh 实测 22000 个文件需要大概 6 分 35 秒 才能完全扫描并同步。 双向同步前需要先在 Onedrive 创建文件夹。 快速备份文件夹，双向同步。; This will effectively make both Path1 and Path2 filesystems contain a matching superset of all files. Path2 files that do not exist in Path1 will be copied to Path1, and the process will then sync the Path1 tree to Path2. 简单同步将源同步到目标，只修改目标。 参考：performance - rclone to OneDrive is excruciatingly slow - Super User--drive-chunk-size 128M 增加上传文件分块的大小。 pastes： 查看 Rclone 进程 RcloneNg UI Windows Mount使用 Rclone 挂载 Onedrive 盘。 official docs：  OneDrive mount - extremely slow –vfs-cache-mode writes or full is recommended for this remote as it can’t stream off： In this mode the cache will read di­rectly from the re­mote and write di­rectly to the re­mote with­out caching any­thing on disk. (本地不做任何缓存，所有文件直接从云端获取并写入。建议网速特别好时使用。)minimal： This is very sim­i­lar to “off” ex­cept that files opened for read AND write will be buffered to disks. This means that files opened for write will be a lot more com­pat­i­ble, but uses the min­i­mal disk space. (和 off 类似，但是已经打开的文件会被缓存到本地。个人推荐，小文件基本够用，但是如果你的网络情况 (梯子) 不是特别好的话，用 writes 也行)writes： In this mode files opened for read only are still read di­rectly from the re­mote, write only and read&#x2F;​write files are buffered to disk first. (如果文件属性为只读则只从云端获取，不然先缓存在本地进行读写操作，随后被同步。个人推荐使用，但是在直接从本地复制文件到 GoogleDrive 时还是看网络情况)full：In this mode all reads and writes are buffered to and from disk. When a file is opened for read it will be down­loaded in its en­tirety first. [所有的读写操作都会缓存到磁盘中。然后才会同步。不是很推荐。会导致所有文件均被缓存到本地。直到达到你缓存总额 (–cache-to­tal-chunk-size，默认大小 10G)。但是你网速特别差时也可以使用。] --allow-other：指的是允许非当前 Rclone 用户外的用户进行访问 --attr-timeout 5m：文件属性缓存，（大小，修改时间等）的时间。如果小鸡配置比较低，建议适当提高这个值，避免过多的和内核交互，占用资源。 -vfs-cache-mode full：开启 VFS 文件缓存，这样可减少 Rclone 与 API 交互，同时可提高文件读写效率 --vfs-cache-max-age 24h：VFS 文件缓存时间，这里设置的 24 小时，如果文件很少更改，建议设置更长的时间 --vfs-cache-max-size 10G：VFS 文件缓存上限大小，建议不超过当前空余磁盘的 50% vfs-read-chunk-size-limit 100M：分块读取大小，这里设置的是 100M，可提高文件读的效率，比如 1G 的文件，大致分为 10 个块进行读取，但与此同时 API 请求次数也会增多 --buffer-size 100M：内存缓存，如果您内存比较小，可降低此值，如果内存比较大，可适当提高 --daemon：指后台方式运行 --drive-chunk-size 128M：增加上传文件分块的大小。 Onedrive Index 在线列出网盘 最大的优点是 Server-less (free) 使用 vercel 免费部署并支持绑定自定义域名。 Quick Start： 申请个人 API： 解决部署一周后出现的 404 错误今天是 2023&#x2F;6&#x2F;6 日，上去云盘看突然显示部署错误了： ​​ 经过 Github Issue 查找，#772 也同样存在这个问题，解决方法： 如果一进入首页就显示这个提示的话，请检查下最近是否修改过 Microsoft​ 的账户密码。如有修改请删除 upstash​ 中的 redis 缓存，再刷新你的网站重新进行认证。 進入首頁會看到Databasesonedrive-vercel-index 點進去後點上方的 Data Browser把裡面的 token 都刪除就可以重新認證了 一查是因为 redis 在线网站限额。改用  discuss 当站点访问量过大时：  使用： OneManager ServerlessOneManager Serverless 使用 Alist文档： Use ProxyWindows"},{"title":"【业余无线电】中国业余电台常用频率(短波)","date":"2023-05-06T08:37:48.000Z","url":"/amateurradio/radio-swshort/","tags":[["业余无线电","/tags/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5/"],["短波","/tags/%E7%9F%AD%E6%B3%A2/"],["SW","/tags/SW/"],["收音机","/tags/%E6%94%B6%E9%9F%B3%E6%9C%BA/"]],"categories":[["Radio","/categories/Radio/"]],"content":"中国业余电台常用频率 (短波)shortwave info website： 短波查询 波段80m 波段:3.840MHz 3.843MHz 3.850MHz 3.855MHz40m 波段:7.030MHz(CW) 7.050MHz 7.O53MHz 7.055MHz 7.060MHz 7.068MHz20m 波段:14.180MHz 14.225MHz 14.270MHz 14.330MHz15m 波段:21.400MHz10m 波段:29.600MHz(FM) 14.180MHz 是 “B NET” 工作频率.每天 8:00 开始.经常有老业余家出现 14.330MHz 是 “CRSA NET” 的工作频率.每周二 10:00 开始. 国内比较热闹的短波频点7.050MHZ LSB 单边带主要是早上和晚上很热闹，传播好的时候，比本地的中继台信号还要好，国内 HAM 默认的公用呼叫频率，大家常在 7.050 呼叫到对方后，都喜欢转到 7.055、7.060、7.065、7.070、7.080 做通联 QSO。 14.270MHZ USB 单边带主要是白天很热闹，传播好的时候，比本地的中继台信号还要好，国内 HAM 默认的公用呼叫频率，大家常在 14.270 呼叫到对方后，都喜欢转到 14.270、14.275、14.280、14.265 做通联 QSO。 14.180MHZ USB 单边带主要是早上 9 点前热闹，传播好的时候，比本地的中继台信号还要好，国内 1 级 BA 大哥和 2 级 BD 大哥 HAM 默认的公用呼叫频率，大家可以在早上收听他们的通联，可以学到更多的知识。 14.330MHZ USB 单边带中国无线电运动协会台网专用频点，每周二 10 点有 BY1PK 主持，发布总部的通知和点名，大家可以收听哦。 21.400MHZ USB 单边带传播特点：白天有传播，偶尔晚上的传播非常好,你的日文好，级别是 2 级的话，可以到 21.200—21.300MHZ 之间，可以和日本的友台通联，日本的 HAM 有很多使用 21MHZ 的 5W 手持机，你随时可以呼叫日本友台，毫不费力！ 29.600MHZ 模式：FM白天有传播，特别是下午 2 点到旁晚的 6 点传播，比打电话还清楚，4 级火腿可以在这频段上合法使用，很有挑战性哦 短波传播判别心得晚上我常在 14.195、14.200、14.202、14.210 等频点收听国外电台 每天晚上很多不同国家的无线电爱好者活跃在这里 也听到了很有趣的不同国家版本的英语口语！ 10 米波 29.600MHZ 模式：FM常常是下午和旁晚才有传播，当然偶尔上午和晚上 12 点前的传播厉害到 5W 可以呼叫全球任何地区的电台，通话质量比本地台还清楚。我常常在呼叫前，收听 29.600 附近的鱼船电台，若能清楚收听到他们的通话时，说明这时 29.600 有传播了，你就可以呼叫全球电台了，成功率很高哦！哈哈，但是 10 米波的传播时间持续时间可能很短哦，大家要抓紧时间通联，重要的是把对方的呼号抄下。功率嘛，不需要大功率，我常常使用 5W，都很好质量了。 20 米波 14.270MHZ 模式：USB白天传播好，有无传播，可以收听广州的 13.149MHZ，海事中转台，它使用率很高，能清楚收听的话，这时你的通话质量一定好，野外白天设台通联，主要就是使用这个波段和 21MHZ 40 米波 7.050MHZ 模式；LSB早晚上传播好，早上 5：30-8：30 前是最热闹的，通话质量很好，象听本地 FM 调频广播电台无线电短波电台是呼叫远方电台的主要工具，常常用来呼叫全球电台，晚上传播好的时候，频率上是密密麻麻的信号，只要你的级别允许你使用的频率范围，都可以用英文呼叫国外电台，是无线电通联技术训练和英语学习的好伙伴。晚上主要在 14.150—14.250MHZ 之间，很多国外电台都在此呼叫，是练习英语口语和听力的好机会，凌晨主要在 7MHZ 上，很是热闹的。 SSB 固定频率广州海岸电台：8782 8716 13107 13149 13149 13182 17398 22735天津海岸台：13092上海海岸台：8773烟台海岸台：13077 17332 8764 4381湛江海岸台：2182 6501 6200舟山海翔船务公司：12408厦门海岸台：8453 4314 12876美军夏威夷、关岛电台：13362 10320（白天）5765 6350（夜晚）冰岛电台：13855东亚太平洋航空天气台：8828国际海事通讯波段：8195-8815 12330-13200 业余电台无线电主要波段80 米 3500-390040 米 7000-7100（LSB）20 米 14000-1435015 米 21000-2145010 米 28000-29700 SSTV 图象 USB 信号：日本气象：13597 9970台湾气象：13900日本报纸：12745 短波以下频率的划分和常用频点中国业余电台常用频率: 80m 波段:3.840MHZ 3.843MHZ 3.850MHZ 3.855MHZ40m 波段:7.030MHZ(CW) 7.050MHZ 7.O53MHZ 7.055MHZ 7.060MHZ 7.068MHZ20m 波段:14.180MHZ 14.225MHZ 14.270MHZ 14.330MHZ15m 波段:21.400MHZ10m 波段:29.600MHZ(FM)14.180MHZ 是 “B?NET” 的工作频率.每天 8:00 开始.经常有老业余家出现14.330MHZ 是 “CRSA?NET” 的工作频率.每周二 10:00 开始. 部分 Freedom 台频率表自由亚洲电台 RFA自由亚洲电台普通话节目 A23 频率表 （更新于 2023 年 3 月 25 日） 时间 频率 11:00-12:00 11570 11895 11985 17800 12:00-13:00 11895 13750 17800 21505 13:00-14:00 11895 17800 21690 14:00-15:00 11895 13790 17800 17810 23:00-24:00 9940 11675 13810 24:00-01:00 7540 11610 13570 13810 01:00-02:00 9360 9970 02:00-03:00 9360 9970 11760 03:00-04:00 9360 9720 04:00-05:00 6080 9360 9535 05:00-06:00 7435 9685 07:00-08:00 9535 9720 15555 美国之声 VOA广播频率表(2023年3月26日–2023年10月28日)​ 普通话0600-0700 7500, 96200800-0900 7560, 9880, 11945, 154251700-1800 9795, 11650, 13830, 15150, 177201800-1900 9795, 9825, 11650, 13830, 151501900-2000 9825, 11660, 12080, 151502000-2100 7515, 9825, 11660, 119002100-2200 7470, 9585, 9825, 116602200-2300 9605, 9825, 11660, 12120 粤语2100-2300 7545 （坐标珠三角，听的很清晰） 藏语0000-0100 7470, 9530, 116700800-0900 5890, 7480, 95751100-1200 17865, 21650, 217501200-1300 15240, 17865, 216201300-1400 15240, 17865, 217602200-2300 11760, 12105, 13655, 17585 注：FNP &#x3D; Frequency Not Promoted，频率不固定，不公开，请自行扫频。再次提醒，短波国际广播具有政治倾向性，请注意内容甄别。 希望之声 SOH Xi Wang Zhi Sheng轮系电台，经常换频率避免干扰，有时候会收到很清晰的广播。一般来说早上和白天效果好，各地情况不同，较低的频率在晚上仍然有效果。不同时段尝试选择不同频率收听，可达到最好的收听效果。reference：希望之声官网 航空 HF高空 HF 航管:KHZ6616(8-20).5481(20-8),备用 11306 中国全境 (以下除外)6616(9-21).5481(21-9),备用 11306 乌鲁木齐 FIR11396(8-20).3485(20-8),备用 5655 三亚 FIR8873(8-20).6682(20-8),备用 8831 拉萨管制区 低空 HF 航管: KHZ5493(8-20).3449(20-8),备用 6622 上海,广州,武汉,三亚 FIR5598(8-20).3437(20-8),备用 8816 北京,渖阳 FIR6565(8-20).3464(20-8),备用 8960 昆明,兰州 FIR5553(9-21).3464(21-9),备用 8960 乌鲁木齐 FIR VOLMET(HF 航空气象): 3458.5673.8849.13285(8-24)KHZH+01-06,H+31-36: 福州.汕头.南昌.宁波.深圳H+06-11,H+36-41: 广州.桂林.海口.厦门.南宁.三亚H+11-16,H+41-46: 长沙.武汉.成都.昆明.重庆.贵阳H+16-21,H+46-51: 北京.天津.太原.呼和浩特.渖阳.哈尔滨H+21-26,H+51-56: 西安.兰州.洛阳.长春.乌鲁木齐H+26-31,H+56-01: 上海.杭州.南京.合肥.宁波.青岛 LDOC(HF 航务通讯)3007.4687.6637.8921.8930.10072.11342.11351.13324.13333.13342.13351.17916.17922.17934.17940.21949.21970 航路管理: (24H)130.45 京广航路 AOC,备用 130.95130.30 京沪航路 AOC,备用 130.95130.15 沪穗航路 AOC,备用 130.95 全国军民航协调联络: 130.0国际航空应急频率 (EMG): 121.5(主频), 243.0(军用)航空专用空对空通信: 123.1国际 inter-pilot 通讯: 123.45VHF 数据链路 (DCL,ACARS): 131.45 调制模式为 FM机场通讯常用航管频率: (步进频率&#x3D;25kHz)TWR 塔台 118.xxGND 地面 121.xxDLY 放行 121.xxATIS 气象 126.xx, 127.xx, 128.xxD-ATIS 气象数据 131.45AOC(OP) 机场航务 129.xx, 130.xx, 131.xx 各地气象传真广播播发频率一览表注：以下频率均以单边带制式播发 播发机构 播发频道 频率（kHz） 时间 日本气象厅 JMH 3622.5（实收 3620.6） 24h JMH2 7795（实收 7793.1） JMH4 13988.5（实收 13986.6） 韩国气象厅 HLL2 3585（实收 3583.1） 20:00 至次日 8:00 7433.5（实收 7431.6） 24h 9165（实收 9163.1） 13570（实收 13568.1） 8:00-20:00 上海海岸电台 XSG 4170（实收 4168.1） 一般以播发时间表为准，范围在北京时间 08:00-17:00 8302（实收 8300.1） 12382（实收 12380.1） 16559（实收 16557.1） 广州海岸电台 XSQ 4195（实收 4193.1） 一般以播发时间表为准，范围在北京时间 08:00-17:00 8310.5（实收 8308.6） 12375.5（实收 12373.6） 16562.5（实收 16560.6） US Navy Hawaii KVM70 9982.5（实收 9980.6） 24h 11090（实收 11088.1） 16135（实收 16133.1） 俄罗斯摩尔曼斯克气象局 RBW41 6445.5（实收 6443.6） 部分时段 泰国气象厅 HSW64 7395（实收 7393.1） 部分时段 日本共同社 JJC 4316（实收 4314.1） 部分播发时段 8467.5（实收 8465.6） 12745.5（实收 12743.6） 16971（实收 16969.1） 17069.6（实收 17067.5） 22542（实收 22540.1） 9VF&#x2F;252 16035（实收 16033.1） 部分播发时段 17430（实收 17428.1） 鹿儿岛县渔业无线局 JFX 4274（实收 4272.1） 以播发时间表为准 8658（实收 8656.1） 13074（实收 13072.1） 16907.5（实收 16905.6） 22559.6（实收 22557.7） 附图 1：XSG 播发时间表 附图 2：XSQ 播发时间表 附图 3：JFX 播发时间表 另 JJC 不播发具体时间表，但按规律会在中午 12 点，下午 4 点，以及晚上 8 点前后播发长传真（格式为 60rpm、20msec），以日文为主 （图片采集自互联网，均不代表作者实际接收效果） Reference短波电台频率表： 频率表 – BD6MM’s Blog"},{"title":"ATC 收听指南","date":"2023-04-29T07:51:48.000Z","url":"/amateurradio/air-traffic-control-listenning/","tags":[["Ham","/tags/Ham/"],["Radio","/tags/Radio/"],["ATC","/tags/ATC/"],["Aircraft","/tags/Aircraft/"],["业余无线电","/tags/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5/"],["航空无线电","/tags/%E8%88%AA%E7%A9%BA%E6%97%A0%E7%BA%BF%E7%94%B5/"]],"categories":[["Radio","/categories/Radio/"]],"content":"ATC 收听指南广州白云机场 ZGGG广州飞行情报区广州 FIR:高空 6616(8-20),5481(20-8), 备用 11306低空 5493(8-20),3449(20-8), 备用 6622 Other附近航空频率 珠三角能收到的航空频率 广州新白云机场（ZGGG） ZGGG&#x2F;CAN 广州白云国际机场"},{"title":"基于 Openwebrx 搭建 Rsp1 Websdr","date":"2023-04-29T07:51:48.000Z","url":"/amateurradio/openwebrx-sdr/","tags":[["Ham","/tags/Ham/"],["Radio","/tags/Radio/"],["业余无线电","/tags/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5/"],["软件无线电","/tags/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5/"],["Openwebrx","/tags/Openwebrx/"]],"categories":[["Radio","/categories/Radio/"]],"content":"基于 Openwebrx 搭建 Rsp1 WebsdrOpenwebrx 本文参考： 安装依赖 Install Csdr Install Pysdr Install Python js8py Module Install Rsp1 Device安装 rsp1 的 linux API 驱动,使用 API 3.07. Sdrplay 官网网站 Install Soapysdr 驱动SoapySDR 通过编译安装 SoapySdr 驱动, 或者通过 ​​apt-get​​ 软件包管理安装 Install Soapysdrplay 驱动用于使得 Soapysdr 使得支持 sdrplay 设备. Install rx_tools 加入内核 Blacklistrtl_sdr 设备 sdrplay 设备 重启后测试是否可以识别 SDR 设备 安装 Openwebrx 主程序 Install owrx_connector 链接组件 运行 Openwebrx 访问 IP:8073 打开页面进行 setting. Openwebrx 自动控制瀑布增益在 openwebrx/htdocs/index.html 末尾加入以下 JS 代码即可实现. "},{"title":"自由勇敢，翻越高墙 | 我的 “敌台” 偷听日记","date":"2023-03-06T08:20:58.000Z","url":"/amateurradio/mystery-radio-listening-diary/","tags":[["政治","/tags/%E6%94%BF%E6%B2%BB/"],["CCP","/tags/CCP/"],["shortwave","/tags/shortwave/"],["短波","/tags/%E7%9F%AD%E6%B3%A2/"],["SW","/tags/SW/"],["Politics","/tags/Politics/"]],"categories":[["Radio","/categories/Radio/"]],"content":"自由勇敢，翻越高墙 | 我的 “敌台” 偷听日记 本文章只是客观记录及收听学习之用，请勿用于非法用途，违者必究。**由于短波国际广播具有明显的政治倾向性，请收听者遵守所在国家的法律，注意内容甄别！因使用者自身原因造成严重后果的，本站不负有责任。 作为一个短波爱好者和广播爱好者，我比较喜欢收听境外的国际广播，因为没有广告，内容相较国内本地调频丰富充实；兼听则明，也能够听到跟国内不一样的声音，有助于独立思考。 Reference HFCC - International Broadcasting Delivery 历史背景“敌台”是 文革时期 的一个流行语，泛指中国以外的华语或者英语等短波广播电台。这些短波电台通常和当局口径不一，持批评态度居多，所以经常受到来自官方机构强大的电子干扰对抗，如有重大敏感事件发生时尤其这样。而当时一些有 独立思考、自由意志 的知识份子就利用无线电台收听国外报道，以此满足求知欲。这种行为如果被当局发现，就会被安上“收听敌台”的罪名，轻则没收收音机，重则批判致死，遭受牢狱之灾。 直到 1978 年，邓小平改革开放以后，社会风气逐渐开明，获取信息的控制、禁忌渐趋松弛，“偷听敌台罪”成为历史。直至，1989 年，天安门的一场学运改变了现状。在学运前后，各种媒体被封锁，各地学生运动组织为了解北京的情况曾大量购买过短波收音机，以通过 BBC 或者美国之音的广播收集信息，导致短波收音机脱销。此后，中国政府恢复了对国外短波电台的干扰直到今天。 国际广播很多是 冷战时期 的产物，这场没有硝烟的战争打了半个多世纪。在思想禁锢、文艺刻板、生活艰苦的文革岁月，进步青年 冒着偷听敌台的风险，打破信息闭塞，了解外部世界。很多 7080 后对于 民主政治运营 的理解和期待，最早就是从短波广播开始的。 着眼当下后疫情时代的中国，社会言论的尺度进一步紧缩，中国社会已是“处处是 红线”，负面新闻事件 “不许谈、不许说、统一口径” 成为常态。极端民族主义情绪在社交媒体中占据上风，而客观陈述事实，理性分析，普世价值却被扣上了各种各样的“帽子”，似乎又回到了那个文革处处批斗的年代。“长江黄河不会倒流”，但现在，恐怕在加速开倒车。 扯远了，回到短波电台的 Topic。当今网路时代，互联网几乎能获取到人们想知道的一切新闻资讯，那短波广播还有存在的必要吗？ 存在即合理，虽然网络发达，但网络基础设施还是掌握在当权者手中，网络审查无处不在。近年来，中国国家网络防火墙（简称 GFW）日益加高，固然之，想去外面世界的门槛进一步提高。比如，福建泉州已经建立了一套 出海网络白名单制度，可能会逐渐推行到全国网络基础设施。（不要低估 GFW 的力量） 这也充分验证了，如果国内发生某些极端事件，他们可以直接物理断开海底光缆（或者是某些软件手段），阻断国内出海的所有网络连接，这样即使是最优秀的科学上网软件也无济于事。这样，CN 就变成了一座互联网孤岛，里面的信息传不出去，外面的信息传不出来。（参考如今的北韩朝鲜半岛） 如果发生这种情况，只有两种方法能和外界通讯，其一是 Elon Musk（马斯克）的 Starlink（星链）但如今 Starlink 也不能在中国大陆使用。 第二种就是透过短波电台和短波收音机，因为短波基于 电离层反射，从而实现远距离跨洋跨州进行通讯。无线电爱好者们甚至研究出用短波进行低速率上网，发邮件等数字通讯方式。短波通讯虽然受电磁环境影响较大，但是政府很难去干扰通讯。 如今，很多国家取消了对华广播的业务，但仍有少数几个 “敌台” 在中华大地上传播来自墙外的声音。比如：RFA、VOA、SOH（轮系）、良友电台（福音基督教）、NHK、KBS、RIT 等。虽身处洼地，也能在深夜的收音机中，在丰收锣鼓的盖台下，得以窃听一丝自由的声音。 收听心得NHK 日本放送协会最喜欢听的短波广播。 NHK 日本国际传媒广播电台，节目比较 温和，通常是日本和国际的新闻、中日新闻为主。新闻结束后有学日语的节目。 “短波情长” 节目是讲述中国听众的来信，挺有意思的。也尝试向 NHK 寄过 QWL （收听证明），不过最后没有收到回卡。）悲 普通话：晚上 7 点半开始，每半点就开始广播，每次持续 30min。 晚上 6090 或 6190 KHz 南方接收不太清晰，有邻频的新疆电台。中午的效果极差，完全收不到。 KBS 韩国国际广播电台和 NHK 的节目差不多，也是以国际新闻、韩语学习为主，播音时间比较长，持续一小时。 我一般不太感兴趣，没怎么听。雾） 普通话： FEBC 良友电台经常听的电台之一，主要是传福音，传播基督教，诵读圣经等节目。教人向善，向主祈祷。 挺喜欢听一些感情小故事节目，9275KHz 晚上 11-12 点的时候播出。 广播的结束语：“亲爱的弟兄姐妹晚安，愿主赐福给您，晚安” 人在低谷的时候往往会沾点神学，也算是一种自我安慰吧。 在珠三角，东南地区收听效果很好，达到 FM 调频级，没什么被干扰的情况，经常晚上听这个入睡。 普通话： 少数民族语言：良友电台是为数不多播出那么多少数民族语言的电台了，基督福音真是传遍中国大地了。 Pray for each Chinese listener to the broadcast. VOA （Voice Of American 美国之音）这也算是老牌的敌台了，因为频率固定，经常会被中国之声盖台，不过好在 功率够大，且短波传播具有随机性，如果你位于山区远离干扰台，有机会听到十分清晰的声音。 “时事经纬” 节目不错，分析讨论最近发生的不能报道新闻。 但好像没有 学习语言 的节目了，全是有关负面政治的报道，听多了政治抑郁。） 普通话：盖台严重 粤语：坐标广州，虽然被 台海之声 盖台，但应该是试验台功率不大，所以还是很清晰能分辨出说什么的，是不是粤语是方言，官方不太投入资源干扰台的缘故？😂 藏语：未尝试，听不懂不评价。 RFA （Radio Free Asia）51 年冷战时成立，也是老牌对华敌台了，其使命是向媒体环境差、对 新闻自由 和 言论自由 的保护有限的亚洲国家提供不经 审查 的报道。 一天广播 12 小时，除正常播出时间之外，部分节目由希望之声转播。 纯负面新闻，纯政治内容，从银行储户到人权律师，全都是沉重的内容。悲） 普通话：都在凌晨，不过都大概率有中国之声盖台，收听体验较差。 粤语：收听没有 VOA 好，有中国之声盖台。 VOK 朝鲜之声赢麻了，不过多评论。 普通话： SOH （Sound of Hope 希望之声）轮子电台，节目丰富，但比较反感他的宗教宣传。可以说是为 anti-CCP 而成立的宗教。除了新闻以外，其他节目都比较弱智，不做阐述。只有短波上没有上面的电台可听时，才会扫描去听听他的新闻。 这个电台比较有意思，之前是 台湾央广 进行转播，后来因为 CPP 施压撤约了。现在是采用 海鸥电台 的形式，指的是在 台湾屏东高山 及中国周边的国家 设置很多个小功率的 AM 短波电台（义工团队），全天侯 24 小时用 100 多个频率进行广播，频率甚至去到短波非广播频段，10000-12000KHz 常常出现数个 SOH 的电台，这些电台由于 功率小，所以 背噪很大，有时候强台还可能被中国之声、台海之声盖台。 海欧电台 在台湾及周边国家，通过小型短波电台向大陆发射信号。 希望之声广播电台，由民间志愿者组成，通过卫星实时接收信号，再转为短波信号发射。因其短波倒 V 天线形似海鸥，就被称作 “海欧电台” 正由于 “海欧电台” 的形式，所以基本上都会在短波扫描到，频率时间不固定，虽然背噪大，但有时候也会有一两个频率能分辨出语音。 台标：“这里是希望之声广播电台 *2，希望时刻在你身边” 完整频率表：（可见 SOH 的大多数频率位于非广播业务频段，乱占频率） 2022.2.13 更新 6215，6230，6280，6340，6370，6850，6865，6900，6970， 7210，7280，7310，7460，7600，7645，7730，7810，9120，9140，9155，9180，9200，9215，9230，9255，9260，9280，9300，9325，9340，9360，9540，9635，9730，9850，9920，9970，9980，9985， 10160，10820，10870，10920，10940，10960， 11070，11100，11120，11150，11170，11410，11440，11460，11500，11520，11535，11550，11580，11600，11715，11775，11975，11990， 12120，12150，12190，12210，12230，12345，12365，12430，12500，12550，12795，12820，12835，12865，12880，12950， 13020，13070，13130，13160，13495，13530，13550，13590，13630，13640，13670，13680，13730，13805，13790，13840，13870，13890，13920，13960，13980， 14370，14430，14560，14580，14635，14690(清晰)，14775，14800，14820，14850，14870，14900，14920，14940，14980， 15295，15340，15360，15410，15610，15740，15760，15775，15800，15820，15840，15870，15890，15920，15940，15970， 16100，16160，16250，16300，16600，16680，16790，16800，16980， 17070，17150，17170，17400，17420，17440，17490，17780， 18180，18200，18900，18970，21530，21800 收听良好频率：日频 11100 11120 14370 14690 14900 14920 14635 15820 15870 15920 15940 16250 16300(收听良好但被主动用 1000HZ 音频干扰) 16790 夜频 6900 6850 6970 6865(被央广干扰) 神秘电台 Number Station We seek to understand and document all radio transmissions, legal and otherwise, as part of the radio listening hobby.我们寻求了解和记录所有无线电传输，无论其是否合法，都作为无线电收听爱好的一部分。 Number Station 一般是指在短波上的 不知名报数电台，用机器或者人声用 航空数字朗读法 朗读数字：“洞四拐八，洞拐勾四….”，普遍认为与 Military 有关，例如中文机器人 VC01 被认为是 China Air Force (CAF) 所有。 Related Website： Number Stations › Priyom.org VC01 – The Chinese Robot Youtube FirstToken VC01 Video Oddity station, VC01, Chinese Robot, mid transmission signal changes, 2012 and 2014 - YouTube 有关 China Military 的 PDF 分析报告: numbersoddities.nl&#x2F;Chinese-military-nets.pdf NumberSoddities.nl oddity 古怪广播网站，存放一些神秘电台的录音： Numbers stations hfunderground.This site is dedicated to documenting ShortWave anything： hfunderground Maritime Weather Transmissions：Site Unreachable Number stations Reserach and Information Center Number stations Reserach and Infomation Center 在 2024-3-5 UTC 19:00 听到在 8093KHz USB 上的男声报数电台（四个数为一组，一组报两次，属于 VC03），有别于 VC01 的机器人报数，他是语速正常应该是人类报数，大概率是 Southern Military Region of China (SARC) 正在训练。 在 2024-3-6 UTC 13:14 4452.4KHz USB 上听到的 VC01 中国机器人，正在快速报数。一直持续大概 4 个小时。 Most of these Chinese military nets are on the air for many years. The ALE transmissions were first reported in early 2012. This net is using 2G ALE to link stations and a FSK-8/PSK proprietary(专有) modem to exchange(交换) data. The ALE signals are usually transmitted(传输) in USB. Sometimes you can hear clear Chinese voice traffic. Also used is 4+4 75&#x2F;1000 or 4+4 75&#x2F;3000 LSB. The well known(总所周知) “numbers stations” M89, V26, M95, and Q26 are also part of the military system. Messages are identical(相同) but their behavior is somewhat(adv.有点) different. Most likely(很有可能) because they belong(属于) to a different branch of the military. The traffic of VC01,VC03 and MC03 is very different from the other stations mentioned here. They serve(服务) a different purpose(目的) sigint [英 &#x2F;‘siɡint&#x2F;] （Signals intelligence）：信号情报,通信情报 (指对无线电信号监听、截获和破译获得的情报)"},{"title":"Golang 学习笔记——目录","date":"2023-02-03T00:30:48.000Z","url":"/golang/golang-note-catalogue/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"【Catalogue】 Golang 学习笔记目录前言本博客用了大量的章节记录了我学习 Golang 语言的笔记，参考书是 《Go 语言圣经》 ，非常详细实用的一本书。强烈安利！部分截图来自 Bilibili 一些教程的视频。算是自己学习 Golang 的一个速查册。 Catalogue Go 环境搭建 Go 标识符-关键字-命名规则 Go 数据类型 Go 变量 const 常量 Type 关键字 Go 指针 复合数据结构-map 映射数据结构 复合数据结构-struct 结构体 Go 函数 Go 方法 Go 接口 Go 自定义包 Go 异常处理 Go go mod 包管理工具和项目结构 Go Json Go HTML Go goruntine 协程并发 &lt;– Current "},{"title":"个人常用的 Vim 配置","date":"2023-01-28T17:37:48.000Z","url":"/vim-config/","tags":[["Linux","/tags/Linux/"],["Vim","/tags/Vim/"]],"categories":[["Linux","/categories/Linux/"]],"content":"Vim 常用配置经常在服务端上修改文件，苦于 vim 默认的界面很不友好，又不想重新手捏配置文件，就分享一下个人常用的简单配置吧。 解决乱码问题Reference： Ubuntu的中文乱码问题 [完美解决]_lubuntu 终端乱码-CSDN博客 配置 自用 ​​**.vimrc​​ 已上传到 GitHub 仓库**参考：WhaleFell&#x2F;vimrcraw:  设置中文字符集 在用户目录下创建配置。 写入以下配置 使用现成的配置利用了 amix&#x2F;vimrc 这个开源项目。 参考 ReferenceVim配置文件（.vimrc），Vim配置教程Vim配置-王遗风"},{"title":"高二上期末考语文小抄","date":"2023-01-10T17:37:48.000Z","url":"/study/ancient-poems/","tags":[["Study","/tags/Study/"],["Chinese","/tags/Chinese/"]],"categories":[["Study","/categories/Study/"]],"content":"高二上期末考语文小抄论语十二章 子曰：“君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉，可谓好学也已。”（《学而》） 子曰：“人而不仁，如礼何？ 人而不仁，如乐何？”(《八佾》) 子曰：“朝闻道，夕死可矣。”(《里仁》) 子曰：“君子喻于义，小人喻于利。”(《里仁》) 子曰：“见贤思齐焉，见不贤而内自省也。”(《里仁》) 子曰：“质胜文则野，文胜质则史。文质彬彬，然后君子。”(《雍也》) 曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”(《泰伯》) 子曰：“譬如为山，未成一篑，止，吾止也。譬如平地，虽覆一篑，进，吾往也。”(《子罕》) 子曰：“知者不惑，仁者不忧，勇者不惧。”(《子罕》) 颜渊问仁。子曰：“克己复礼为仁。一日克己复礼，天下归仁焉。为仁由己，而由人乎哉？”颜渊曰：“请问其目。”子曰：“非礼勿视，非礼勿听，非礼勿言，非礼勿动。”颜渊曰：“回虽不敏，请事斯语矣。”(《颜渊》) 子贡问曰：“有一言而可以终身行之者乎？”子曰：“其‘恕’乎！己所不欲，勿施于人。”(《卫灵公》) 子曰：“小子何莫学夫《诗》？《诗》可以兴，可以观，可以群，可以怨。迩之事父，远之事君。多识于鸟兽草木之名。”(《阳货》) 翻译： 孔子说：“做人如果没有仁爱之心，如何谈礼仪制度呢？做人如果没有仁爱之心，又从何谈音乐呢？” 孔子说：“早晨能够得知真理，即使当晚死去，也没有遗憾。” 孔子说：“君子通晓的是道义，小人只通晓利益。” 孔子说：“看见有才能的人（德才兼备的人）就向他学习，希望能向他看齐；看见不贤的人，就反省自己有没有和他一样的缺点，有要改正。” 孔子说：“质朴胜过了文饰就会粗野，文饰胜过了质朴就会虚浮，质朴和文饰比例恰当，然后才可以成为君子。” 曾子说：“士不可不志向远大，意志坚强，因为他肩负重大责任，路途漫长遥远。以实行仁道为己任，不是很重大的责任吗？直到身死才能结束，不是很漫长遥远的吗？” 孔子说：“譬如用土堆山，只差一筐土就完成了，这时停下来，那是我自己要停下来；譬如填平洼地，虽然只倒下一筐，这时虽然只有一筐，但我也在前进。” 孔子说：“聪明人不会迷惑，有仁德的人不会忧愁，勇敢的人不会畏惧。” 颜渊请教什么是仁。孔子说：“约束自己返归于周礼就是仁。一旦所有的人都约束自己返归于周礼，天下的人都会称赞你是仁人。对仁的追求完全取决于自己，难道还靠别人吗？”颜渊说：“请问具体的做法。”孔子说：“不合于礼的不要看，不合于礼的不要听，不合于礼的不要说，不合于礼的不要做。”颜渊说：“我虽然愚笨，也要照您的话去做。” 子贡问孔子问道：“有没有一个字可以终身奉行的呢？”孔子回答说：“那就是‘恕’吧！自己不喜欢的事物，不要强加于别人身上。” 孔子说：“学生们为什么没有人学《诗经》呢？《诗经》可以激发心志，可以观察政治的得失，风俗的盛衰，可以培养群体观念，可以学得讽刺方法。近则可以用其中的道理来侍奉父母；远可以用来侍奉君主，还可以多认识鸟兽草木的名称。” 大学之道——《礼记》大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。 物有本末，事有终始。知所先后，则近道矣。 古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，壹是皆以修身为本。 其本乱而末治者，否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。 翻译：大学的宗旨在于弘扬光明正大的品德，学习和应用于生活，使人达到最完善的境界。 知道应达到的境界才能够志向坚定；志向坚定才能够镇静不躁；镇静不躁才能使内心安定；心安理得才能够思虑周详；思虑周详才能够处事合宜。每一样东西都有根本有始末，每件事情都有开始有终结。明白了这本末始终的道理，就接近事物发展的规律了。 古代那些要想在天下弘扬光明正大品德的人，先要治理好自己的国家；要想治理好自己的国家，先要管理好自己的家庭和家族；要想管理好自己的家庭和家族，先要修养自身的品性；要想修养自身的品性，先要端正自己的心思；要想端正自己的心思，先要使自己的意念真诚；要想使自己的意念真诚，先要使自己获得知识；获得知识的途径在于认识、研究万事万物。通过对万事万物的认识、研究后才能获得知识；获得知识后意念才能真诚；意念真诚后心思才能端正；心思端正后才能修养品性；品性修养后才能管理好家庭和家族；管理好家庭和家族后才能治理好国家；治理好国家后天下才能太平。上至天子下至平民百姓，都应该以修养自身的品德为根本。 通过推究事物的原理，而彰显明德，认识本心，表里如一。意念才能真诚；意念真诚后心思才能端正；心思端正后才能修养品性；品性修养后才能管理好家庭和家族；管理好家庭和家族后才能治理好国家；治理好国家后天下才能太平。上自国家君王，下至平民百姓，人人都要以修养品性为根本。 若这个根本被扰乱了，家庭、家族、国家、天下要治理好是不可能的。不分轻重缓急、本末倒置却想做好事情，这也同样是不可能的！这就叫知道了根本，这就是认知的最高境界。 人皆有不忍人之心《孟子》孟子曰：“人皆有不忍人之心。先王有不忍人之心，斯有不忍人之政矣；以不忍人之心，行不忍人之政，治天下可运之掌上。所以谓人皆有不忍人之心者：今人乍见孺子将入于井，皆有怵惕恻隐之心；非所以内交于孺子之父母也，非所以要誉于乡党朋友也，非恶其声而然也。由是观之，无恻隐之心，非人也；无羞恶之心，非人也；无辞让之心，非人也；无是非之心，非人也。恻隐之心，仁之端也；羞恶之心，义之端也；辞让之心，礼之端也；是非之心，智之端也。人之有是四端也，犹其有四体也。有是四端而自谓不能者，自贼者也；谓其君不能者，贼其君者也。凡有四端于我者，知皆扩而充之矣，若火之始然，泉之始达。苟能充之，足以保四海；苟不充之，不足以事父母。” 翻译：孟子说：“每个人都有怜悯体恤别人的心情。古代圣王由于怜悯体恤别人的心情，所以才有怜悯体恤百姓的政治。用怜悯体恤别人的心情，施行怜悯体恤百姓的政治，治理天下就可以像在手掌心里面运转东西一样容易了。之所以说每个人都有怜悯体恤别人的心情，是因为，如果今天有人突然看见一个小孩要掉进井里面去了，必然会产生惊惧同情的心理——这不是因为要想去和这孩子的父母拉关系，不是因为要想在乡邻朋友中博取声誉，也不是因为厌恶这孩子的哭叫声才产生这种惊惧同情心理的。由此看来，没有同情心，简直不是人；没有羞耻心，简直不是人；没有谦让心，简直不是人；没有是非心，简直不是人。同情心是仁的发端；羞耻心是义的发端；谦让心是礼的发端；是非心是智的发端。人有这四种发端，就像有四肢一样。有了这四种发端却自认为不行的，是自暴自弃的人；认为他的君主不行的，是暴弃君主的人。凡是有这四种发端的人，都知道要扩大充实它们，就像火刚刚开始燃烧，泉水刚刚开始流淌。如果能够扩充它们，便足以安定天下，如果不能够扩充它们，就连赡养父母都成问题。” 选必一 古诗词诵读无衣岂曰无衣？与子同袍。王于兴师，修我戈矛，与子同仇！岂日无衣？与子同泽。王于兴师，修我矛戟，与子偕作！岂日无衣？与子同裳。王于兴师，修我甲兵，与子偕行！ 春江花月夜 张若虚春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明！江流宛转绕芳甸，月照花林皆似霰。空里流霜不觉飞，汀上白沙看不见。江天一色无纤尘，皎皎空中孤月轮。江畔何人初见月？江月何年初照人？人生代代无穷已，江月年年望相似。不知江月待何人，但见长江送流水。白云一片去悠悠，青枫浦上不胜愁。谁家今夜扁舟子？何处相思明月楼？可怜楼上月裴回，应照离人妆镜台。玉户帘中卷不去，捣衣砧上拂还来。此时相望不相闻，愿逐月华流照君。鸿雁长飞光不度，鱼龙潜跃水成文。昨夜闲潭梦落花，可怜春半不还家。江水流春去欲尽，江潭落月复西斜。斜月沉沉藏海雾，碣石潇湘无限路。不知乘月几人归，落月摇情满江树。 将进酒 唐 李白君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生，将进酒，杯莫停。与君歌一曲，请君为我倾耳听。钟鼓馔玉不足贵，但愿长醉不愿醒。古来圣贤皆寂寞，惟有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱，径须沽取对君酌。五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。 江城子·乙卯正月二十日夜记梦 宋 苏轼十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。 夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 选必二古诗词诵读燕歌行并序 高适汉家烟尘在东北，汉将辞家破残贼。男儿本自重横行，天子非常赐颜色。摐金伐鼓下榆关，旌旗逶迤碣石间。校尉羽书飞瀚海，单于猎火照狼山。山川萧条极边土，胡骑凭陵杂风雨。战士军前半死生，美人帐下犹歌舞。大漠穷秋塞草腓，孤城落日斗兵稀。身当恩遇常轻敌，力尽关山未解围。铁衣远戍辛勤久，玉筋应啼别离后。少妇城南欲断肠，征人蓟北空回首。边风飘飘那可度，绝域苍茫更何有。杀气三时作阵云，寒声一夜传刁斗。相看白刃血纷纷，死节从来岂顾勋。君不见沙场征战苦，至今犹忆李将军。 李凭箜篌引 李贺吴丝蜀桐张高秋，空山凝云颓不流。江娥啼竹素女愁，李凭中国弹箜篌。昆山玉碎凤凰叫，芙蓉泣露香兰笑。十二门前融冷光，二十三丝动紫皇。女娲炼石补天处，石破天惊逗秋雨。梦入神山教神妪，老鱼跳波瘦蛟舞。吴质不眠倚桂树，露脚斜飞湿寒兔。 锦瑟 李商隐锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然。 书愤 陆游早岁那知世事艰，中原北望气如山。楼船夜雪瓜洲渡，铁马秋风大散关。塞上长城空自许，镜中衰鬓已先斑。出师一表真名世，千载谁堪伯仲间！ 老子四章 三十辐共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。 企者不立，跨者不行，自见者不明，自是者不彰，自伐者无功，自矜者不长。其在道也，曰余食赘行，物或恶之。故有道者不处。 知人者智，自知者明。胜人者有力，自胜者强。知足者富，强行者有志。不失其所者久，死而不亡者寿。 其安易持，其未兆易谋，其脆易泮，其微易散。为之于未有，治之于未乱。合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。为者败之，执者失之。是以圣人无为，故无败；无执，故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货，学不学，复众人之所过，以辅万物之自然而不敢为。 翻译： 三十根辐条汇集到一根毂中的孔洞当中，有了车毂中空的地方，才有车的作用。揉和陶土做成器皿，有了器具中空的地方，才有器皿的作用。开凿门窗建造房屋，有了门窗四壁内的空虚部分，才有房屋的作用。所以，“有”给人便利，“无”发挥了它的作用。 踮踮着脚跟的人站不牢，跨步行的人走不远，(就好像) 自逞己见的人反而不能明理，自以为是的人则是非不明，自我炫耀功劳的人反而不能成就大功，自尊自大的人反而得不到敬重。用道的观点来看，是吃剩下的食物或身体上的肉瘤，众人常常厌恶这些。所以有道的人是绝不会这样做的。 了解别人的人聪明，了解自己的人圣明。战胜别人的人有力量，战胜自己的人刚强。知道满足的人就是富人。确定不移、竭力实行的人有意志。不丧失合适位置的人能够长久。死而不朽的人就是长寿。 局面安定时容易保持和维护，事变没有出现迹象时容易图谋；事物脆弱时容易消解；事物细微时容易散失；做事情要在它尚未发生以前就处理妥当；治理国政，要在祸乱没有产生以前就早做准备。合抱的大树，生长于细小的萌芽；九层的高台，筑起于每一堆泥土；千里的远行，是从脚下第一步开始走出来的。有所作为的将会招致失败，有所执着的将会遭受损害。因此圣人无所作为所以也不会招致失败，无所执着所以也不遭受损害。人们做事情，总是在快要成功时失败，所以当事情快要完成的时候，也要像开始时那样慎重，就没有办不成的事情。因此，有道的圣人追求人所不追求的，不稀罕难以得到的货物，学习别人所不学习的，补救众人所经常犯的过错。这样遵循万物的自然本性而不会妄加干预。” 报任安书 司马迁古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。 仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉！然此可为智者道，难为俗人言也！ 翻译：古时候，富贵而湮没不闻的人数不胜数，多得数不清，只有那些不为世俗所拘的卓异之士才能见称于后世。西伯姬昌被拘禁而扩写《周易》；孔子受困窘而作《春秋》；屈原被放逐，才写了《离骚》；左丘明失去视力，才有《国语》。孙膑被截去膝盖骨，《兵法》才撰写出来；吕不韦被贬谪蜀地，后世才能流传《吕氏春秋》；韩非被囚禁在秦国，写出《说难》、《孤愤》；《诗》三百篇，大都是一些圣贤们抒发愤懑而写作的。这些都是人们感情有压抑郁结不解的地方，不能实现其理想，所以记述过去的事迹，让将来的人了解他的志向。就像左丘明没有了视力，孙膑断了双脚，终生不能被人重用，便退隐著书立说来抒发他们的怨愤，想到活下来从事著作来表现自己的思想。 我私下里也自不量力，近来用我那不高明的文辞，收集天下散失的历史传闻，粗略地考订其事实，综述其事实的本末，推究其成败盛衰的道理，上自黄帝，下至于当今，写成十篇表，十二篇本纪，八篇书，三十篇世家，七十篇列传，一共一百三十篇，也是想探求天道与人事之间的关系，贯通古往今来变化的脉络，成为一家之言。刚开始草创还没有完毕，恰恰遭遇到这场灾祸，我痛惜这部书不能完成，因此便接受了最残酷的刑罚而不敢有怒色。我现在真正的写完了这部书，打算把它藏进名山，传给可传的人，再让它流传进都市之中，那么，我便抵偿了以前所受的侮辱，即便是让我千次万次地被侮辱，又有什么后悔的呢！然而这些话只能对智者去说，却很难向世俗之人讲清楚啊！ 大道之行也《礼记》大道之行也，天下为公。选贤与能，讲信修睦。故人不独亲其亲，不独子其子，使老有所终，壮有所用，幼有所长，矜、寡、孤、独、废疾者皆有所养，男有分，女有归。货恶其弃于地也，不必藏于己；力恶其不出于身也，不必为己。是故谋闭而不兴，盗窃乱贼而不作，故外户而不闭。是谓大同。 翻译：大道在天下实行时，把天下作为大家所共有的，把品德高尚的人、能干的人选拔出来。人们都讲求诚信，培养和睦的气氛。因此人们不只是把自己的父母当做父母，把自己的孩子当做孩子，让老人能够终其天年，成年人能够为社会效力，年幼的人能够顺利地成长。使老而无妻的人、老而无夫的人、幼而无父的人、老而无子的人、残疾人都能得到供养。男子有职务，女子有归宿。对于财货，人们都憎恨把它扔在地上的行为，却不一定要自己私藏。人们都愿意为公众之事竭尽全力，而不一定为自己谋私利。因此，奸邪之谋不会发生，盗窃、造反和害人的事情不发生，家家户户都不用关大门了。这就是理想社会。 山居秋瞑 王维空山新雨后，天气晚来秋。明月松间照，清泉石上流。竹喧归浣女，莲动下渔舟。随意春芳歇，王孙自可留。"},{"title":"Golang 学习笔记——struct结构体","date":"2022-12-30T10:30:48.000Z","url":"/golang/golang-struct-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 结构体结构体: 是由一系列具有 相同类型 或 不同类型 的数据构成的数据 集合。 结构体成员是由 一系列的成员变量 构成，这些 成员变量 也被称为 字段。 字段 大写就表明该字段是可导出字段，可以被外部包导入。 如果考虑效率的话，较大的结构体通常会用 指针的方式 传入和返回。如果要在函数内部修改结构体成员的话，用 指针传入 是必须的；因为在 Go 语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。 结构体定义定义结构体 初始化结构体: 如果不赋值,默认存储的是类型的零值. 结构体指针 定义结构体指针 * 获取指针指向的原始数据.&amp; 获取一个对象的地址. 通过 new 构建结构体指针 内置函数 new() 专门用于创建某种类型的指针. 通过, new() 函数 (不为 nil,空指针) 指向了 新分配的类型的内存空间 ,里面存该类型的零值. 结构体的匿名匿名结构体 结构体的匿名字段 结构体嵌套一个结构体可能包含一个字段，而这个字段是一个结构体。这个结构体被称为嵌套结构。 将结构体的地址作为字段数值 (引用传递) [建议使用]在嵌套结构体中,结构体字段是结构体指针.使用了引用传递. Golang 中的 OPP(面向对象)Golang 并不是面向对象的语言….但可以模拟继承性. 通过结构体嵌套模拟面向对象的继承性. 通过结构体的嵌套模拟继承性 s3.Person.name-&gt;s3.name Student 结构体将 Person 结构体作为一个匿名字段了. 那么 Person 中的字段，对于 Student 来讲，就是提升字段. Student 对象直接访问 Person 中的字段 "},{"title":"Golang 学习笔记——Goruntine并发协程","date":"2022-12-30T03:11:48.000Z","url":"/golang/golang-goruntine-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Golang 学习笔记——Goruntine 并发协程并发程序指同时进行多个任务的程序，Web 服务器会一次处理成千上万的请求。 Go 语言中的并发程序可以用两种手段来实现。本节讲解 goroutine 和 channel，其支持“顺序通信进程”（communicating sequential processes）或被简称为 CSP。 在这种编程模型中值会在不同的运行实例（goroutine）中传递，通过 channel 进行不同 Goroutine 间的数据共享。 可以简单地把 goroutine 类比作一个线程，当一个程序启动时，其主函数即在一个单独的 goroutine 中运行，我们叫它 main goroutine（主线程）。 新的 Goroutine 会用 go 语句来创建。在语法上，go 语句是一个普通的函数或方法调用前加上关键字 go。go 语句会使其语句中的函数在一个新创建的 goroutine 中运行。而 go 语句本身会迅速地完成。（非阻塞） 主函数返回 时，所有的 goroutine 都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个 goroutine 来打断另一个的执行。 Go 显示一个加载动画函数，可以放在 go spinner(100 * time.Millisecond) 执行 go 后跟的 函数的参数 会在 go 语句自身执行时被求值，就是在 main goroutine 中被求值。 ChannelsChannel 是 goruntine 间的通信管道，每个 channel 都有一个可发送数据的类型。 可以使用 make 函数，创建一个 channel： 和 map 类似，channel 也对应一个 make 创建的 底层数据结构的引用。当我们复制一个 channel 或用于函数参数传递时，我们只是拷贝了一个 channel 引用，channel 的零值也是 nil。 发送&amp;接收 Channel 支持关闭 close 操作，关闭 channel 后对通道的任何发送操作都会 panic 但进行接收操作仍然可以接收到之前一键成功发送的数据，如果 channel 中已经没有数据了就返回一个零值数据。 不带缓存的 Channels一个无缓冲的 channel 的发送操作会导致发送者的 goroutine 堵塞，直到另一个 goruntine 在相同的 channel 上执行接收操作，堵塞才会解除，反之亦然。 当发送的值通过 channel 成功传输之后，两个 goroutine 才可以继续执行后面的语句。 检查 Channels 是否关闭接收 channels 的语句可以写成：第二个结果的一个 bool ，true 表示成功从 channels 接收到值，false 表示 channels 已经被关闭并且里面没有值可接收。 因为这种处理模式很常见，Go 语言的 range 循环可以直接在 channels 上面迭代，它依次从 channel 接收数据，当 channel 被关闭并且没有值可接收时跳出循环。 不管一个 channel 是否被关闭，当它没有被引用时将会被 Go 语言的垃圾自动回收器回收。所以不需要显性的 close(channel) 不要将关闭一个打开文件的操作和关闭一个 channel 操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的 Close 方法来关闭文件。 单方向的 Channel当一个 channel 作为一个函数参数 时，它一般总是被专门用于只发送或者只接收。这是为了防止滥用，可以定义只接收或只发送的 channel ，这种限制将在编译期检测。 close channel 只用于停止向 channel 发送新数据。但不能阻止接收 channel 的数据。所以 对一个只接受的 channel 调用 close 将引起编译错误。 调用 inChannel 时 in 的类型将隐式地从 chan int 转换成 chan&lt;- int。任何双向 channel 向单向 channel 变量的赋值操作都将导致该隐式转换。但是反之不能将单向 channel 赋值给 双向 channel 带缓存 (buffer) 的 Channels"},{"title":"Linux iptables 命令笔记","date":"2022-12-25T14:51:48.000Z","url":"/linux-iptables/","tags":[["Linux","/tags/Linux/"],["Network","/tags/Network/"]],"categories":[["Linux","/categories/Linux/"]],"content":"Linux Iptables 命令笔记 认识iptables 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。 iptables 操作需要超级用户权限，以上命令通常只用于处理 IPv4 数据包；而对于 IPv6 数据包，则使用类似的 ip6tables 命令。 原理iptables 的原理主要是对数据包的控制，看下图： 一个数据包进入网卡时，它首先进入 PREROUTING(预路由) 链，内核根据数据包目的 IP 判断是否需要转发出去. 如果数据包就是进入本机的，它就会沿着图向下移动，到达 INPUT 链。数据包到了 INPUT 链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过 OUTPUT 链，然后到达 POSTROUTING(路由后) 链输出。 如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出。 规则 表 链 iptables 由链组成,链中有规则 规则 (rules)规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了 源地址、目的地址、传输协议（如 TCP、UDP、ICMP）和服务类型（如 HTTP、FTP 和 SMTP）等。当数据包与规则匹配时，iptables 就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。 链 (chains)链（chains）是数据包传播的路径，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables 就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则 iptables 将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables 就会根据该链预先定义的默认策略来处理数据包。 表 (tables)表（tables）提供特定的功能，iptables 内置了 4 个表，即 raw 表、filter 表、nat 表和 mangle 表，分别用于实现包过滤，网络地址转换和包重构的功能。 其中 nat filter 表是常用的. Filter 表主要用于过滤数据包，主要利用在 filter 表中指定的规则来实现对数据包的过滤。Filter 表是默认的表，如果没有指定哪个表，iptables 就默认使用 filter 表来执行所有命令. filter 表包含了 INPUT 链（处理进入的数据包），RORWARD 链（处理转发的数据包），OUTPUT 链（处理本地生成的数据包）在 filter 表中只能允许对数据包进行接受,丢弃的操作，而无法对数据包进行更改 Nat 表主要用于网络地址转换 NAT,用于端口和&#x2F;或地址的转换. NAT 表包含了 PREROUTING 链（修改即将到来的数据包），POSTROUTING 链（修改即将出去的数据包），OUTPUT 链（修改路由之前本地生成的数据包） Iptables 命令 表名表名：Filter, NAT, Mangle, Raw 起包过滤功能的为表 Filter，可以不填，不填默认为 Filter 命令选项-A 在指定链的末尾添加（–append）一条新的规则 -D 删除（–delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则 -I 在指定链中插入（–insert）一条新的规则，默认在链的开头插入 -R 修改、替换（–replace）指定链中的一条规则，按规则序号或内容确定 -L 列出（–list）指定链中的所有的规则进行查看，默认列出表中所有链的内容 -F 清空（–flush）指定链中的所有规则，默认清空表中所有链的内容 -N 新建（–new-chain）一条用户自己定义的规则链 -X 删除指定表中用户自定义的规则链（–delete-chain） -P 设置指定链的默认策略（–policy） -n 用数字形式（–numeric）显示输出结果，若显示主机的 IP 地址而不是主机名 -P 设置指定链的默认策略（–policy） -v 查看规则列表时显示详细（–verbose）的信息 -V 查看 iptables 命令工具的版本（–Version）信息 -h 查看命令帮助信息（–help） –line-number 查看规则列表时，同时显示规则在链中的顺序号 链名可以根据数据流向来确定具体使用哪个链，在 Filter 中的使用情况如下： 条件匹配-p 指定规则协议，如 tcp, udp,icmp 等，可以使用 all 来指定所有协议 -s 指定数据包的源地址参数，可以使 IP 地址、网络地址、主机名 -d 指定目的地址 -i 输入接口 -o 输出接口 目标值数据包控制方式包括四种为： ACCEPT：允许数据包通过。 DROP：直接丢弃数据包，不给出任何回应信息。 REJECT：拒绝数据包通过，必须时会给数据发送端一个响应信息。 LOG：在&#x2F;var&#x2F;log&#x2F;messages 文件中记录日志信息，然后将数据包传递给下一条规则。 QUEUE：防火墙将数据包移交到用户空间 RETURN：防火墙停止执行当前链中的后续 Rules，并返回到调用链 (the calling chain) 应用NAT 转发实现将本机（192.168.1.7:7410）端口流量转发给（192.168.1.160:9200）。 1. 内核允许转发 2. 设置 Filter 表基础策略：允许入包&#x2F;出包&#x2F;转发-P 设置链的基础策略 3. 端口转发流量建立一个双向映射 其他命令显示 nat 规则列表： 删除指定规则： 允许出站的 DNS 连接: 将来自 422 端口的流量全部转到 22 端口: 这意味着我们既能通过 422 端口又能通过 22 端口进行 ssh 连接。启用 DNAT 转发。 除此之外，还需要允许连接到 422 端口的请求: 本机端口转发: 注意,在本机请求无法经过 PREROUTING 链,所以本机的 422 端口访问不了 22. 如果需要本机也可以访问，则需要配置 OUTPUT 链 特别注意: 本机访问外网的端口会转发到本地,导致访不到外网.实际上是访问到本地,建议不做 80 端口的转发或者指定目的 -d localhost： 原因：外网访问需要经过 PREROUTING 链，但是 localhost 不经过该链，因此需要用 OUTPUT。"},{"title":"Samba4 服务器配置最佳实践","date":"2022-12-25T11:37:48.000Z","url":"/samba4-config/","tags":[["Linux","/tags/Linux/"],["Server","/tags/Server/"]],"categories":[["Server","/categories/Server/"]],"content":"Samba4 服务器配置最佳实践 具体配置文件请按照实际情况进行修改! smb.conf.ini "},{"title":"Golang 学习笔记——文本和HTML模板","date":"2022-12-17T07:17:48.000Z","url":"/golang/golang-html-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"GO 文本和 HTML 模板前面的例子，只是最简单的格式化，使用 Printf 是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这写功能是由 text&#x2F;template 和 html&#x2F;template 等模板包提供的，它们提供了一个将变量值填充到一个文本或 HTML 格式的模板的机制。 一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的 &#123;&#123;action&#125;&#125; 对象。 通过 `` 定义字符串字面量。 对于每一个 action，都有一个当前值的概念，对应点操作符，写作“.”,模板中 &#123;&#123;.TotalCount&#125;&#125; 对应 action 将展开为结构体中 TotalCount 成员 模板中 &#123;&#123;range .Items&#125;&#125; 和 &#123;&#123;end&#125;&#125; 对应一个循环 action ，因此它们直接的内容可能会被展开多次，循环每次迭代的当前值对应当前的 Items 元素的值。 在一个 action 中， | 操作符表示将前一个表达式的结果作为后一个函数的输入，类似于 UNIX 中管道的概念。 生成模板 方法调用链 ：template.New 先创建并返回一个模板；Funcs 方法将 daysAgo 等自定义函数注册到模板中，并返回模板；最后调用 Parse 函数分析模板。 因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。template.Must 辅助函数可以简化这个致命错误的处理：它接受一个模板和一个 error 类型的参数，检测 error 是否为 nil（如果不是 nil 则发出 panic 异常），然后返回传入的模板。 html&#x2F;template使用和 text&#x2F;template 包相同的 API 和模板语言，但是增加了一个将 字符串自动转义特性，这可以避免输入字符串和 HTML JavaScript、CSS 或 URL 语法产生冲突的问题。 "},{"title":"Golang 学习笔记——JSON的解析","date":"2022-12-17T04:17:48.000Z","url":"/golang/golang-json-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Golang 解析 JSON 数据JSON 是对 JavaScript 中各种类型的值——字符串、数字、布尔值和对象—— Unicode 本文编码。它可以用有效可读的方式表示基础数据类型和数组、slice、结构体和 map 等聚合数据类型。 JSON 序列化（编码）将结构体 slice 转为 JSON 的过程叫编组（marshaling）。编组通过调用 json.Marshal 函数完成： 在结构体声明中，Year 和 Color 成员后面的字符串面值是结构体成员 Tag json.MarshalIndent 函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进： JSON 反序列化（解码）编码的逆操作是解码，对应将 JSON 数据解码为 Go 语言的数据结构，Go 语言中一般叫 unmarshaling，通过 json.Unmarshal 函数完成。 结构体中只有 Title 成员。通过定义合适的 Go 语言数据结构，我们可以 选择性 地解码 JSON 中感兴趣的成员。 将定义的结构体传入函数时，需要 传入结构体的地址（指针） 。因为在函数内部默认是深拷贝数据，写入结构体时需要映射原有的结构体。 Struct 结构体成员 TagGo 语言默认将结构体的成员名字作为 JSON 的对象（通过 reflect 反射技术）。只有导出的结构体成员才会被编码，要用大写字母开头的成员名称。 有些 JSON 成员名字和 Go 结构体成员名字并不相同，因此需要 Go 语言结构体成员 Tag 来指定对应的 JSON 名字。 Color 成员的 Tag 还带了一个额外的 omitempty 选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象。 流式 JSON 解码器基于流式的解码器 json.Decoder，它可以从一个输入流解码 JSON 数据，尽管这不是必须的。如您所料，还有一个针对输出流的 json.Encoder 编码对象。 调用 Decode 方法传入结构体指针来填充变量。"},{"title":"自由上网指北——21世纪网民天赋的权力","date":"2022-08-11T07:51:48.000Z","url":"/freedom-network/","tags":[["GFW","/tags/GFW/"],["Freedom","/tags/Freedom/"]],"categories":[["GFW","/categories/GFW/"]],"content":"自由上网指北——21 世纪网民天赋的权力​​ WARNINGWARNING：本文可能随时遭到来自 中国当局 方面的审查，对此，您需要清楚知悉文章内部分敏感词的代替表达方式。 法律依据：中华人民共和国宪法——保障公民互联网言论自由 前言自由上网，在种花家指得是 FQ ，等突破网络审查或突破网络封锁的手段。由于少数国家实行了高强度的网络审查，使得一些国际网站及软件遭到政府或组织的结构性屏蔽。比如 in China 你可能会发现 Stream 上的游戏怎么下载不动呢？GitHub 怎么打不开呢？YouTube 怎么上不了呢？这都是 ZF 对网络进行屏蔽的结果。 但互联网的 分布式设计 从体系上使得任何一个政府或组织完全控制互联网极其困难。俗话说：“ 你有张良计，我有过墙梯！ ”各种 FQ 软件被热爱自由的工程师设计了出来。 FQ 软件的原理通常是连接一个没有被 GFW 阻断的境外服务器，通过该服务器进行流量转发。本文主要面向一些 FQ 的小白，方便其 快速、安全、便捷 的建立安全的自由互联网连接。所以主要涉及软件的使用，没有涉及具体的实现原理。 态度FQ 对于个人而言是十分重要的，您可以第一时间知道世界上发生了什么大事，可以辩证的看待各种信息源，避免 ZF 给民众设置的 信息茧房。辩证地看待国内严重的民粹主义、极端的民族主义情绪。多信息源可以避免信息差。 同时，FQ 也是对个人媒介素养的考验，墙外的信息虽然没有审查、信息源也参差不齐，要有选择的吸取信息。总之，要坚持 良知、理性、平等和爱 的普世价值。这些价值观基本都超越了宗教、国家和民族，在地球的每个地区都被推崇，也是大多数人类都能共同认可的价值观。 安全性为了确保您上网的安全性，请勿使用那种傻瓜的一键 vpen，比如说 佛跳墙、快连、老王，这种 vpen 因为使用便捷，深受小白喜爱。殊不知这些傻瓜一键 vpen 大多数都是有中资背景的，您上网的一举一动王晶都看在眼里，记在小本本上，头上三尺有神明，您是躲不过的迟早会请去喝茶。 所以，为了您的安全请使用开源的 vpen 软件，但可能需要投入一点点的时间成本，但你会收获一个免费、快捷、安全的自由上网方法。 另外，请不要在 FQ 手机上安装 国家防诈 监控 APP，懂得都懂！ 最后，在访问境外网站时请不要使用手机厂商自带的浏览器和爱国浏览器，推荐使用 via 浏览器和 chrome google 浏览器，这两个浏览器百度都可以搜得到。 V2**y 使用安卓端下面简单介绍安卓端 v2**y 的使用。 下载GitHub releases 页 因为上面的链接需要 FQ 后才能使用，请用下面的链接下载： 蓝奏云  密码:7xzj 使用安装上面下载的 apk 文件，打开后点击左上角进行设置 VPN 设置 -&gt; 启动本地 DNS 路由设置 -&gt; 域名策略（IPIfNonMatch） 预定义规则 -&gt; 绕过局域网及大陆地址而后代理 设置好后回到首页选择订阅分组设置 点击加号添加订阅然后保存，如果你是我的朋友或者同学，可以问我白嫖订阅地址。 回到首页点击右上角，再选择更新订阅，不出意外的话就会出现各节点。 然后再选择测试 全部配置真链接，选择延迟较低的节点，然后点击右下角的 V 图标就会建立 VPN 连接。 测试连接上 VPN 后，可以使用 via 浏览器打开谷歌网站（）来检验节点是否有效。 打开  查看节点的落地 IP 地址。"},{"title":"Golang 学习笔记——go 包的使用","date":"2022-05-28T13:54:48.000Z","url":"/golang/golang-package-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 包的使用关于包的使用: 一个目录下的文件归属一个包。package 的声明要一致 package 声明的包和对应的目录名可以不一致。但习惯上还是写成一致的 包可以嵌套 同包下的函数不需要导入包，可以直接使用 main 包，main() 函数所在的包，其他的包不能使用 导入包的时候，路径要从 src 下开始写 变量名大写 表示该变量可以外部访问. init() 函数init()、main() 是 Go 语言中的保留函数。我们可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main() 中导入包，包中存在 init(),那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料. 相同点 init() main() 函数不能有返回值也不能有参数. 两个函数在定义时不能有任何的参数和返回值,该函数只能由 Go 程序自动调用,不可以被引用. 不同点 init() 可以应用于任意包中，且可以重复定义多个。 main() 函数只能用于 main 包中，且只能定义一个。 两个函数的执行顺序 对于同一个 Go 文件,从上到下执行 对于同一个 package 中的不同文件,将文件名按字符串进行从小到大排序,之后顺序调用各文件中的 init() 函数. 对于不同的 package,如果不相互依赖的话，按照 main 包中 import 的顺序调用其他包中的 init() 函数。 如果 package 存在依赖,调用顺序为最后被依赖的最先被初始化.例如：导入顺序 main-&gt;A-&gt;B-&gt;C ,则初始化顺序为 C-&gt;B-&gt;A-&gt;main ,一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包. 避免出现 循环 import ,例如：A-&gt;B-&gt;C-&gt;A.一个包被其它多个包 import ,.但只能被初始化一次 总结init() 函数和 main() 函数 这两个函数都是 go 语言中的保留函数。init() 用于初始化信息，main() 用于作为程序的入口 这两个函数定义的时候：不能有参数，返回值。只能由 Go 程序自动调用，不能被引用 init() 函数可以定义在任意的包中，可以有多个。main() 函数只能在 main 包下，并且只能有一个。 执行顺序 先执行 init() 函数，后执行 main() 函数 对于同一个 Go 文件中，调用顺序是从上到下的，也就是说，先写的先被执行，后写的后被执行 对于同一个包下，将文件名按照字符串进行排序，之后顺序调用各个文件中 init() 函数 对于不同包下.如果不存在依赖，按照 main 包中 import 的顺序来调用对应包中 init() 函数如果存在依赖，最后被依赖的最先被初始化导入顺序：main 一&gt;A 一&gt;B-&gt;C执行顺序：C 一&gt;B-&gt;A 一&gt;main 存在依赖的包之间，不能循环导入 一个包可以被其他多个包 import ,但是 只能被初始化一次。 _ 操作，其实是引入该包，而不直接使用包里面的函数，仅仅是调用了该包里的 init() 注意 如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入。这个操作经常是让很多人费解的一个操作符 管理外部包Go 允许 import 不同代码库的代码。对于 import 要导入的外部的包，可以使用 Go get 命令取下来放到 GOPATHS 对应的目录中去。举个例子，比如说我们想通过 Go 语言连接 mysql 数据库，那么需要先下载 mysql 的数据包，打开终端并输入以下命令： 安装之后，就可以在 GOPATHS 目录的 src 下，看到对应的文件包目录. 如果有多个 GOPATHS 目录,默认下载到第一个目录下. 我们可以通过 go install 来编译包文件。我们知道一个非 main 包在编译后会生成一个。a 文件 (在临时目录下生成)。除非使用 go install 安装到 $GOROOT 或 $GOPATH 下，否则你看不到 a,用于后续可执行程序链接使用。比如 Go 标准库中的包对应的源码部分路径在：$GROOT/src,而标准库中包编译后的 a 文件路径在 $GROOT/pkg/darwin_amd64 下。 "},{"title":"Golang 学习笔记——Go 项目结构和 Go mod","date":"2022-05-28T13:54:48.000Z","url":"/golang/golang-project-and-gomod-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 项目结构和 Go mod 最佳实践项目目录 一般地 bin 和 pkg 目录可以不创建，go 命令会自动创建（爽否？），只需要创建 src 目录放代码即可。 环境变量 GOROOT：安装的 go 路径 GOPATA：项目的根目录 go-test细心的人注意到，这里有一个 Project GOPATH，还有一个 Global GOPATH，把你的项目配置在 Project GOPATH 里，每个项目都不一样，创建另一个项目时这个路径要配置成新项目的。 Global GOPATH 可以弄一个公共项目，以后就把第三方的包直接装到这里，就可以自动在你的项目里引用了。 引用包 注意点 add.go 中的 Add 函数名首字母必须大写，只有大写的才是 Public 权限，外面的包才能访问，否则只能自己文件夹下代码才能访问。 add.go 的改名为 addyyy.go 也可以，查找 add 包的时候，并不会根据 add.go 这个文件名来查找。而是根据文件夹名来查找，一个文件夹下的所有文件都属于同一个包。所以函数变量自然不能重复。 main 中调用 add.Add(1,2) 时，add 是包， 必须跟 add.go 中的 package 处的包名一致，否则报错。 import 后， 根据 GOROOT 和 GOPATH 查找对应的包，src 这个目录名可不是能随便取的。 引用第三方项目 Go mod 包管理工具Why? 使用 go mod 仓库中可以不用再上传依赖代码包，防止代码仓库过大浪费以及多个项目同时用包时的浪费。 可以管理引用包的版本，这一点是 gopath（src 模式）和 vendor 做不到的 如果依赖 GOPATH 不同项目如果引用了同一个软件包的不同版本，就会造成编译麻烦 gopath 是 go 之前的默认策略，每个项目在运行时都要严格放在​**src​目录下，而 go mod 不用。** Go mod 的优点： 自动下载依赖包。 项目不必放在 $GOPATH/src 内了。 项目内会生成一个 go.mod 文件，列出包依赖。 第三方包会准确的指定版本号。 对于已经转移的包，可以用 replace 申明替换，不需要改代码。 在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/pkg/mod 中，也会把 go install 的结果放在 $GOPATH/bin 中。 配置 注意：只要在本地 设置一个公用 gopath 目录 就可以了，全部的包都会下载到那里，其他本地项目用到时就可以共享了，并且会自动根据 go.mod 选择对应版本的第三方库。 go.mod go.sum每一行都是由 模块路径，模块版本，哈希检验值 组成，其中哈希检验值是用来保证当前缓存的模块不会被篡改。 Go mod 命令使用go mod init：初始化 go mod， 生成 go.mod 文件，后可接参数指定 module 名，上面已经演示过。go mod download：手动触发下载依赖包到本地 cache（默认为 $GOPATH&#x2F;pkg&#x2F;mod 目录）go mod graph：打印项目的模块依赖结构go mod tidy ：添加缺少的包，且删除无用的包go mod verify ：校验模块是否被篡改过go mod why：查看为什么需要依赖go mod vendor ：导出项目所有依赖到 vendor 下 写入 go.mod 有两种方法： 你只要在项目中有 import 并使用或者使用下划线强制占用，然后 go build 时 go module 就会自动下载并添加。 go mod tidy 参考：Go mod用法"},{"title":"Golang 学习笔记——Go error 错误","date":"2022-05-21T16:44:48.000Z","url":"/golang/golang-error-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go Error 错误Go 使用控制流机制（如 if 和 return）处理异常，这使得编码人员能更多的关注错误处理。 在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go 语言没有提供像 Java、c# 语言中的 try..catch 异常处理方式，而是通过 函数返回值 逐层往上抛。这种设计，鼓励工程师在代码中 显式的检查错误 ，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让 代码啰嗦 。 错误&amp;异常 错误: 指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中。 异常: 指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分，而异常不是。 Go 中的错误 也是一种类型 。错误用内置的 error 类型表示。就像其他类型的，如 int,floate64.错误值可以存储在变量中，从函数中返回，等等。 处理 OS 模块异常如果一个函数或方法返回一个错误，那么按照惯例，它必须是 函数返回的最后一个值。因此，Open 函数返回的值是最后一个值。处理错误的惯用方法是将 返回的错误与 ​​**nil​​ 进行比较** 。nil 值表示没有发生错误，而 非nil 值表示出现错误。在我们的例子中，我们检查错误是否为 nil。如果它不是 nil ,我们只需 打印错误并从主函数返回。 错误类型表示G0 语言通过 内置的错误接口 提供了非常简单的错误处理机制。定义错误类型 的构建。错误是一个带有以下定义的接口类型: fmt.Println(err) 会在内部执行 Error() 方法,返回错误的字符串信息. 从错误中获取更多信息 断言判断接口底层类型 ,通过 struct 结构体的属性和方法获取更多的信息 使用 struct 类型属性 调用 struct 类型的方法 直接比较直接与错误类型的变量进行比较. 自定义 Error1. 通过 errors.New(&quot;描述&quot;) 2. 通过 fmt.Errorf()也可以使用 fmt.Errorf() 输出的错误更详细,支持格式化输出错误. 3. 定义错误 尽量不要 _ 忽略错误永远不要忽略一个错误。忽视错误会招致麻烦。 panic() 和 recover() 什么时候使用错误&#x2F;异常什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。以下给出异常处理的作用域（场景）: 空指针引用 下标越界 除数为 0 不应该出现的分支，比如 default 输入不应该引起函数错误 其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去 recover() .并打印堆栈信息，使得部署后的程序不会终止。 偶然异常重试机制如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的 时间间隔 或重试的 次数，防止无限制的重试。 无法运行的重大错误如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在 main 中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了 bug，才能在库函数中结束程序。 log 包中的所有函数会为没有换行符的字符串增加换行符。 只需要输出错误信息就足够了，不需要中断程序的运行。 或者向标准错误流输出错误信息。 文件结尾错误（EOF）读取文件时，调用者会重复的读取固定大小的数据直到文件结束，io 包保证任何由文件结束引起的读取失败都返回同一个错误—— io.EOF. "},{"title":"Golang 学习笔记——Type关键字","date":"2022-05-21T00:30:48.000Z","url":"/golang/golang-type-keyword-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go Type 关键字type 是 Go 语法里的重要而且常用的关键字,type 绝不只是对应于 C&#x2F;C+ 中的 typedef.搞清楚 type 的使用,就容易理解 Go 语言中的核心概念 struct、interface、函数 等的使用。 通过 Type 定义新类型 通过 Type 定义函数类型Go 语言支持 高阶函数 ,所以可以把函数作为一个函数的返回值,或者一个函数的参数. 类型别名常常用于代码迁移,适配新旧代码. 非本地类型不能定义方法time 包下的 Duration 类型不是 main 包下的类型,所以不是本地类型.不能定义方法. 在结构体成员嵌入时使用别名"},{"title":"Golang 学习笔记——Go 接口","date":"2022-05-16T10:30:48.000Z","url":"/golang/golang-interface-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 接口面向对象 世界中的接口的一般定义是 “接口定义对象的行为“。它表示让指定对象应该做什么。实现这种行为的方法（实现细节）是针对对象的。 在 Go 中，接口是 一组方法签名。当类型为接口中的所有方法提供定义时，它被称为 实现接口。它与 OOP 非常相似。接口指定了类型 应该具有 的方法，类型决定了 如何实现 这些方法。 它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。 图示 示例表达一个类型属于某个接口只要这个类型实现这个接口。 Go 语言中接口和类型的实现方式是 非侵入式 的,接口定义的方法没有具体代码. 通过接口模拟多态多态的定义“ 一个事物的多种形态 “ 就一个接口的实现: 看成 实现本身的类型，能够访问 实现类中的属性和方法. 看成 对应的接口类型，那就 只能够访问接口中的方法. 接口的用法： 一个函数如果接受 接口类型作为参数，那么实际上 可以传入该接口的任意实现类 对象作为参数。 定义一个类型为 接口类型，实际上可以 赋值为任意实现类的对象. 鸭子类型: 待补充… 空接口interface&#123;&#125; 不包含任何的方法,所以任何类型都是空接口的实现类,因此空接口可以储存任何类型的数值. 空接口定义任意类型的数据 空接口作为函数的参数表示函数的参数可以是任意类型,相当于 Python 的 typing.Any fmt 包就是应用了空接口,可以传入任何参数.fmt 包下的 Print 系列函数: 复合数据结构使用空接口 接口嵌套接口允许多继承. 如果 Cat 想实现接口 C,不仅要实现接口 C 自己的方法,还要实现接口 C 继承的接口 A B 中的方法. 接口断言前面说过，因为空接口 interface 没有定义任何函数，因此 Go 中 所有类型都实现了空接口。当一个函数的形参是 interface&#123;&#125; ，那么在函数中，需要对形参 进行断言，从而 得到它的真实类型。 方法一: 通过 x.(T) 的方式断言 如果断言的类型 T 是一个接口类型，然后类型断言检查是否 x 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型（type）和值部分（value）的接口值，但是结果为类型 T。 用于判断 x.(T) x 是否满足 T 接口。 如果一个类型满足下面的这个接口，然后 WriteString(s) 方法就必须和 Write([]byte(s)) 有相同的效果。 Write 方法需要传入一个 byte 切片而我们希望写入的值是一个字符串，所以我们需要使用 []byte(…) 进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉，会影响一丢丢性能。 我们知道在这个程序中的 w 变量持有的动态类型也有一个允许字符串高效写入的 WriteString 方法；这个方法会避免去分配一个临时的拷贝。 许多满足 io.Writer 接口的重要类型同时也有 WriteString 方法，包括 *bytes.Buffer，*os.File 和 *bufio.Writer。 我们不能对任意实现 io.Writer 接口类型的变量 w，假设它也拥有 WriteString 方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否 w 的动态类型满足这个新接口。 它太有用了以致于标准库将它作为 io.WriteString 函数提供。这是向一个 io.Writer 接口写入字符串的推荐方法。 上面的 writeString 函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。 如果断言操作的对象是一个 nil 接口值，那么不论被断言的类型是什么这个类型断言都会失败。 当类型断言的操作对象是一个变量时，if 内层其实是声明了一个同名的新的本地变量，外层原来的 w 不会被改变。 方法二：使用 switch…case… 语句，断言类型分支。 一个类型分支隐式的创建了一个词法块，因此新变量 x 的定义不会和外面块中的 x 变量冲突。每一个 case 也会隐式的创建一个单独的词法块。 接口值接口值由两部分组成：一个具体的类型（type）和这个类型的值（value）。接口是动态类型。一个接口值可以持有任意大的动态值。实现了这个接口的类型都可以赋值这个接口。 定义一个 nil 接口： 将 *os.File 类型赋值给变量 w，因为 *os.File 实现了 io.Writer 接口，所以赋值合法。赋值过程调用了一个 具体类型到接口类型 的隐式转换（变成 T 类型 T(type) ） io.Writer(os.Stdout) 接口的 value 持有 os.Stdout 的拷贝，这是一个代表处理标准输出的 os.File 类型的指针。 调用一个包含 *os.File 类型指针的接口值的 Write 方法，得 (*os.File).Write 方法被调用。这个调用输出 “hello”。 当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用 fmt 包的 %T 动作，在 fmt 包内部，使用反射来获取接口动态类型的名称。 ⚠️一个包含 Nil 指针的接口不是 Nil 接口一个不包含任何值的 nil 接口值： 一个刚好包含 nil 指针的接口值： 应用sort.Interface 接口在很多语言中，排序算法都是和序列数据类型关联，但 Go 语言的 sort.Sort 函数不会对具体的序列和它的元素做限定。它使用一个接口类型 sort.Interface 来指定通用的序列算法。 一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 sort.Interface 接口的三个方法： 排列字符串切片： http.Handler 接口net&#x2F;http ListenAndServe 函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的 Handler 接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。 使用不同的 URL 触发不同的行为 现在 handler 基于 URL 的路径部分（req.URL.Path）来决定执行什么逻辑。如果不能识别，调用 w.WriteHeader(http.StatusNotFound) 返回客户端一个 HTTP 404 错误。 http.ResponseWriter 是另一个接口。它在 io.Writer 上增加了发送 HTTP 相应头的方法。另外，还可以使用 http.Error 函数。 net&#x2F;http 包提供了一个请求多路器 ServeMux 来简化 URL 和 handlers 的联系（路由映射）。一个 ServeMux 将一批 http.Handler 聚集到一个单一 http.Handler 中。 所以 db.list 是一个实现了 handler 类似行为的函数，但是因为它没有方法，所以它不满足 http.Handler 接口并且不能直接传给 mux.Handle。 语句 http.HandlerFunc(db.list) 是一个转换而非一个函数调用，因为 http.HandlerFunc 是一个类型。它有如下的定义： 因为 handler 通过这种方式注册非常普遍，ServeMux 有一个方便的 HandleFunc 方法，它帮我们简化 handler 注册代码成这样： 为了方便，net&#x2F;http 包提供了一个全局的 ServeMux 实 DefaultServerMux 和包级别的 http.Handle 和 http.HandleFunc 函数。现在，为了使用 DefaultServeMux 作为服务器的主 handler，我们不需要将它传给 ListenAndServe 函数；nil 值就可以工作。 使用包级别的 http.HandleFunc 注册路由： 最后，web 服务器在一个新的协程 Goruntine 中调用每一个 handler，所以当 handler 获取其它协程的共享变量时一定要使用预防措施比如 锁机制。 Error 接口 创建一个 error 最简单的方法就是 error.New 函数，其实整个 error 包只有 4 行： 指针类型 *errorString 满足 error 接口而非 errorString 类型，承载 errorString 的类型是一个结构体而非一个字符串，所以每个 New 函数的调用都分配了一个独一无二的错误示例。 有一个方便的封装函数 fmt.Errorf，允许对错误信息进行字符串格式化 ： 详解 Go 语言的 rune 类型 建议当设计一个新的包时，小白 Gopher 总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。"},{"title":"Golang 学习笔记——method方法","date":"2022-05-06T13:54:48.000Z","url":"/golang/golang-method-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 方法面向对象编程 (OOP)一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。 G0 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集. 方法只是一个函数，它带有一个特殊的接收器类型，它是在 func 关键字和方法名之间编写的。接收器可以是 struct 类型或非 struct 类型。接收方可以在方法内部访问。 对比函数 意义方法：某个类别的行为功能，需要指定的接受者调用.函数：一段独立功能的代码，可以直接调用. 语法方法：方法名可以相同，只要接受者不同.函数：命名不能冲突. 方法可以模拟 class 继承结构. 定义一个方法Go 能够给任意类型定义方法，Go 和很多其它的面向对象的语言不太一样。因此在 Go 语言里，我们为一些简单的数值、字符串、slice、map 来定义一些附加行为。方法可以被声明到任意类型，只要不是一个指针或者一个 interface。 语法: 接收者为一个值 接收者为一个指针当调用一个方法时，会对其 每一个参数值进行拷贝，如果一个方法需要更新一个变量，或者方法的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下就需要用到指针了。 在现实的程序里，一般会约定如果 Point 这个类有一个指针作为接收器的方法，那么所有 Point 的方法都必须有一个指针接收器. 只有类型 (Point) 和指向他们的指针 (*Point)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的， 注意点 不管你的 method 的 receiver 是指针类型还是非指针类型，都是可以通过指针&#x2F;非指针类型进行调用的，编译器会帮你做类型转换。 在声明一个 method 的 receiver 该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个 对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为 receiver，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝,修改数据时总是会映射到原来的内存地址. 方法的继承性OOP 继承如果两个类 (struct) 存在继承关系，其中一个是子类，另一个作为父类，那么： 子类可以直接访问父类的属性和方法 子类可以新增自己的属性和方法 子类可以重写父类的方法 (就是将父类已有的方法，重新实现) 封装的最重要的优点，是阻止了外部调用方对 对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的 Counter 类型允许调用方来增加 counter 变量的值，并且允许将这个值 reset 为 0，但是不允许随便设置这个值。外部包根本访问不了 Counter.n 变量。 只用来访问或修改内部变量的函数被称为 setter 或者 getter 。 示例method 是可以继承的，如果匿名字段实现了一个 method,那么包含这个匿名字段的 struct 也能调用该 method"},{"title":"Golang 学习笔记——Pointer指针","date":"2022-05-02T10:17:48.000Z","url":"/golang/golang-pointer-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 指针*指针类型: 取指针地址对应的真实值. | 定义一个指针 *p1&amp;值: 取值的内存地址.var p *int: 定义一个指向 int 类型的指针 指针初步 数组指针“ 首先是一个指针,一个数组的地址.” 指针数组“ 首先是一个数组,存储的数据类型是指针.” 函数指针“ 一个指针,指向一个函数的指针.” 指针函数“ 一个函数,该函数的返回值是一个指针.” 普通函数的执行分析 指针函数的执行分析 指针作为参数普通函数的值传递 指针作为参数时的引用传递 应用 切片本来就是 引用类型,不必传递指针. output:切片地址都是一样的,切片发生的是引用传递 "},{"title":"Golang 学习笔记——func函数","date":"2022-05-01T18:17:48.000Z","url":"/golang/golang-function-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 函数 函数调用时，Go 语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。 实参通过值的方式传递，因此函数的 形参是实参的拷贝 。对形参进行修改不会影响实参。但是，如果实参包括 引用类型，如指针，slice(切片)、map、function、channel 等类型，实参可能会由于函数的简介引用被修改。 偶尔遇到没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。 Go 使用控制流机制（如 if 和 return）处理异常，这使得编码人员能更多的关注错误处理。 函数调用过程 函数的参数使用 实参和形参 函数传参 可变参数参数数量可变的函数称为为可变参数函数。需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。 在函数体中,vals 被看作是类型为 []int 的切片。sum 可以接收任意数量的 int 型参数： 如果原始参数已经是切片类型,在最后一个参数后加上省略符。 参数传递实参通过值的方式传递，因此函数的 形参是实参的拷贝 。对形参进行修改不会影响实参。但是，如果实参包括 引用类型，如指针，slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。 参数的值传递 参数的引用传递 函数的返回值 在定义参数返回值的时候已经初始化了. 函数多返回值如果一个函数将所有的返回值都显示的变量名，那么该函数的 return 语句可以省略操作数。这称之为 bare return。 Return 语句return 语句：词义 “ 返回 “ 一个函数有返回值，那么使用 return 将返回值返回给调用处 同时意味着结束了函数的执行 注意点: 一个函数定义了返回值，必须使用 return 语句将结果返回给调用处。return 后的数据必须和函数定义的一致：个数，类型，顺序。 可以使用 _,来舍弃多余的返回值 如果一个函数定义了有返回值，那么函数中有分支，循环，那么要保证，无论执行了哪个分支，都要有 return 语句被执行到. 如果一个函数没有定义返回值，那么函数中也可以使用 return,专门用于结束函数的执行。 函数中变量的作用域 随着函数的结束,函数内的变量自己会销毁. 全局变量和局部变量 全局变量 不支持简短定义的写法 递归函数 递归函数实现 fibonacci 数列 (斐波那契数列) defer(延迟函数)defer 的词义:&quot; 延迟&quot;,&quot; 推迟&quot;,在 go 语言中,使用 defer 关键字来延迟一个函数或者方法的执行. 你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。 defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。释放资源的 defer 应该直接跟在请求资源的语句后。 deferi 函数或方法：一个函数或方法的执行被延迟了。 defer 的用法:对象,close(),临时文件的删除.文件.open()defer close() 关闭文件 使用 Defer 记录函数defer 机制也常被用于记录何时进入和退出函数。 不要忘记 defer 语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。 语言中关于异常的处理虽然 Go 的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同。由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致.对于大部分漏洞，我们应该使用 Go 提供的错误机制，而不是 panic ，尽量避免程序的崩溃。 regexp 包提供了包装函数 regexp.MustCompile 检查输入的合法性。输入错误就立马 panic,函数名中的 Must 前缀是一种针对此类函数输入错误的立马 panic Runtime 输出堆栈信息 使用 panic() 和 recover()panic 函数用于引发恐慌，导致程序中断执行 recover 函数用于恢复程序的执行，recover() 语法上要求必须在 defer 中执行。 如果多个 defer 函数： defer 函数传递参数的时候： 如果在 deferred 函数中调用了内置函数 recover，并且定义该 defer 语句的函数发生了 panic 异常，recover 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 recover，recover 会返回 nil。 安全的做法是有选择性的 recover 。换句话说，只恢复应该被恢复的 panic 异常. 可以将 panic value 设置成特殊类型。在 recover 时对 panic value 进行检查，如果发现 panic value 是特殊类型，就将这个 panic 作为 error 处理，如果不是，则按照正常的 panic 进行处理. 栈的结构 (先进后出!后进先出!)当一个函数有多个延迟调用时，它们被添加到一个堆栈中，并 Last In First Out(LIFO) 先进后出!后进先出! 的顺序中执行。 Defer 注意点 当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。 当执行外围函数中的 return 语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。 当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。 函数的数据类型在 Go 中，函数被看作第一类值 (一等公民)（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。 strings.Map 对字符串中的每个字符 调用 add1 函数，并将每个 add1 函数的返回值组成一个新的字符串返回给调用者。 函数的类型：func(参数列表的数据类型)(返回值列表的数据类型) 基本类型回顾 函数的本质 “ 说到底,函数也是一种特殊类型的变量.” 匿名函数拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），，在任何表达式中表示一个函数值。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。 通过这种方式定义的函数可以访问 完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示： 在 squares 中定义的匿名内部函数可以访问和更新 squares 中的局部变量，匿名函数和 squares 中，存在变量引用。 变量的生命周期不由它的作用域决定：squares 返回后，变量 x 仍然隐式的存在于 f 中。 Go 使用闭包（closures）技术实现函数值，Go 程序员也把函数值叫做闭包。 回调函数 闭包Go 语言支持函数式编程函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。 函数类型的零值是 nil。调用值为 nil 的函数值会引起 panic 错误. 函数值之间是不可比较的，也不能用函数值作为 map 的 key。 支持将一个函数作为另一个函数的参数,也支持将一个函数作为另一个函数的返回值. strings.Map 对字符串中的每个字符调用 add1 函数，并将每个 add1 函数的返回值组成一个新的字符串返回给调用者。 闭包 (closure)一个外层函数中,有内层函数,该内层函数中,会操作外层函数的 局部变量 (外层函数中的参数，或者外层函数中直接定义的变量),并且该外层函数的返回值就是这个内层函数. 这个内层函数和外层函数的局部变量，统称为闭包结构。 局部变量的 生命周期 会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁 但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束销毁，因为内层函数还要继续使用。 捕获迭代变量 将介绍 Go 词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。 循环中的 d 函数值记录的是 循环变量的内存地址 ，不是循环变量某一时刻的值。for 循环结束时，d 指向循环最后一次迭代的值。而需要一个局部变量 dir 将 d 进行深拷贝保存作为循环变量的副本。 这个问题不仅存在基于 range 的循环，go 语句或者 defer 语句会经常遇到此类问题。这不是 go 或 defer 本身导致的，而是因为它们都会 等待循环结束后 ，再执行函数值。"},{"title":"Golang 学习笔记——map映射数据结构","date":"2022-05-01T10:30:48.000Z","url":"/golang/golang-map-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go Map 数据类型map: 映射&#x2F;哈希表，是一种转码用于存储键值对的结合，属于引用类型。 定义 Map 对象 存储值获取值 Map 的遍历 使用 sort 包进行排序. Map 和 Slice 结合使用 原理图: Map 是引用类型 总结"},{"title":"Golang 学习笔记——变量","date":"2022-04-25T10:30:48.000Z","url":"/golang/golang-variable-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Golang 变量变量是计算机语言中能储存计算结果或能表示值的抽象概念。不同的变量保存的数据类型可能会不一样。 声明变量G0 语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且 G0 语言的变量声明后必须使用。 声明变量的语法 e.g. 批量声明 变量的初始化G0 语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如：整型和浮点型变量的默认值为 0。字符串变量的默认值为空字符串 &quot;&quot;。布尔型变量默认为 false,切片、函数、指针变量的默认为 nil. 变量初始化语法 e.g. 类型推断 批量初始化 短变量声明在函数内部，可以使用 := 运算符对变量进行声明和初始化。 注意：这种方法只适合在函数内部，函数外面不能使用。 匿名变量如果我们接收到多个变量，有一些变量使用不到，可以使用下划线 _ 表示变量名称，这种变量叫做匿名变量。e.g. 函数定义 等价于： 接收函数返回值 "},{"title":"Golang 学习笔记——const常量","date":"2022-04-22T10:30:48.000Z","url":"/golang/golang-const-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 语言常量常量，就是在程序编译阶段就确定下来的值，而程序在运行时则无法改变该值。在 G0 程序中，常量可以是数值类型 (包括整型、浮点型和复数类型)、布尔类型、字符串类型等。 定义常量的语法定义一个常量使用 const 关键字，语法格式如下： 示例 iota 关键字iota 比较特殊，可以被认为是一个可被编译器修改的常量，它默认开始值是 0，每调用一次加 1。遇到 const 关键字时被重置为 0。e.g. 使用 _ 跳过某些值 iota 声明中间插队"},{"title":"Golang 学习笔记——数据类型","date":"2022-04-21T10:30:48.000Z","url":"/golang/golang-datatype-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 数据类型在 G0 编程语言中，数据类型用于 声明函数和变量，数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。 G0 语言按类别有以下几种数据类型： 布尔型布尔型的值只可以是常量 true 或者 false 。一个简单的例子：var b bool=true 数字类型整型 int 和浮点型 float32、float64,Go 语言支持整型和浮点型数字，并且支持复数，具中位的运算采用补码。 字符串类型字符串就是一串因定长度的字符连接起来的字符序列。G0 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本， 派生类型 指针类型 (Pointer) 数组类型 (c) 结构体类型 (struct) Channel: 类型 函数类型 切片类型 接口类型 Map 类型 格式化输出类型 输出: 布尔类型go 语言中的布尔类型有两个常量值：true 和 false。布尔类型经常用在条件判断语句，或者循环语句。也可以用在逻辑表达式中。 数值类型派生类型指针类型"},{"title":"Golang 学习笔记——标识符-关键字-命名规则","date":"2022-04-20T10:30:48.000Z","url":"/golang/golang-id-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 标识符 - 关键字 - 命名规则标识符标识符的英文是 identifier,通俗的讲，就是给变量、常量、函数、方法、结构体、数组、切片、接口起名字。 标识符的组成: 标识符由数字、字母和下划线 (_) 组成。123abc_ 只能以字母和下划线 (_) 开头。abc123_sysVar123abc 标识符区分大小写。nameName NAMET 标识符的命名 Go 关键字Go 语言命名规范Go 是一门区分大小写的语言。 命名规则涉及变量、常量、全局函数、结构、接口、方法等的命名。G0 语言从语法层面进行了以下限定：任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的则应该以小写字母开头。 Go 命名的可见性当命名 (包括常量、变量、类型、函数名、结构字段等等) 以一个大写字母开头，如：GetUserName,那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为 导出(像面向对象语言中的 public)；命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的 (像面向对象语言中的 private) 包名称保持 package 的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。 文件命名尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。customer_dao.go 结构体命名采用驼峰命名法，首字母根据访问控制大写或者小写 struct 申明和初始化格式采用多行，例如下面： 接口命名命名规则基本和上面的结构体类型单个函数的结构名以“er”作为后缀，例如 Reader,Writer. 变量命名和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：如果变量为私有，且特有名词为首个单词，则使用小写，如 appService 若变量类型为 bool 类型，则名称应以 Has,Is,Can 或 Allow 开头 "},{"title":"Golang 学习笔记——Go环境搭建","date":"2022-04-19T10:30:48.000Z","url":"/golang/golang-envbuild-note/","tags":[["Coding","/tags/Coding/"],["Golang","/tags/Golang/"]],"categories":[["Golang","/categories/Golang/"]],"content":"Go 环境搭建 安装完 Go,添加 bin 目录到环境变量. CMD 配置 go 环境 Vscode 安装 Go Run code 插件 Hello Go"},{"title":"服务器备忘录✨","date":"2022-03-20T11:37:48.000Z","url":"/server-all/","tags":[["Linux","/tags/Linux/"],["Server","/tags/Server/"]],"categories":[["Server","/categories/Server/"]],"content":"服务器备忘录 2022 年 3 月 19 日 Update. 落落家 X86服务器配置 运行内存 (RAM)：4GB（笔记本 ddr3 内存条） CPU：4 x Intel(R) Atom(TM) CPU D2550 @ 1.86GHz &#x2F; 512 KB cache 英特尔凌动® 处理器 D2550 (intel.cn) 2 核 4 线程 服务器系统：Ubuntu 18.04 Server Linux whalefall 4.15.0-171-generic #180-Ubuntu SMP Wed Mar 2 17:25:05 UTC 2022 x86_64 硬盘：​df -h 网络： ifconfig enp2s0：主网卡，跑 qBittorrent enp1s0：副网卡，docker network —— macnet （openwrt），网心云 docker 运行服务Nginx 配置文件：/etc/nginx/conf.d; /etc/nginx/sites-enabled 默认配置：Nginx默认配置 Port: 80 Desc: 运行探针服务。 Path: /var/www/html Port: 86 Desc: python3-cookbook 3.0.0 文档。 Path: /www/openvpn_admin/ Port: 88 Desc: 可道云 Kodcloud. Path: /www/kodcloud Port: 89 Desc: AiraNg 下载器。（已反向代理 Aira2 6800）配置文件 Path: /www/kodcloud Docker Port：9090 Desc：Portainer web admin command：source Port：8989 Desc：qBittorrent download command：source Port：18888 Desc：网心云（容器魔方） command：source network：macnet ip：192.168.5.66 Desc：openwrt 软路由 command：source 部分配置文件Nginx_default_config AiraNg_download_config Run qBittorrent Command run_portainer_command run_wxedge_command -e NIC：指定网卡 run_openwrt_by_docker run_ttnode_by_docker"},{"title":"Linux 运维笔记(持续更新)","date":"2022-03-20T08:37:48.000Z","url":"/linux-note/","tags":[["Linux","/tags/Linux/"]],"categories":[["Linux","/categories/Linux/"]],"content":"Linux Operation Note​​ 分区管理和操作 (Partition)使用 cfdisk 代替 fdisk 实现可视化的硬盘分区. 有 GUI 环境可以使用 gparted. 分配扩展的空间可以使用 resize2fs 命令. 扩展虚拟机硬盘大小是, 记得要修改 swap(交换分区) 的 UUID Linux swap(交换分区) 是一种内存管理技术,用于在物理内存(RAM)不够用时,将部分内存数据临时存储到硬盘上的特殊分区(交换分区)中.它的主要作用包括: 1. 扩展内存容量 2. 支持休眠功能 3. 提高系统稳定性 4.内存清理swap 不可以完全删除, 因为部分软件会依赖于 swap 才可以正常运行. 硬盘操作 (Disk Operation)了解两个特殊的设备: &#x2F;dev&#x2F;null:回收站、无底洞. &#x2F;dev&#x2F;zero:产生字符. 格式化硬盘为 ETX4 格式 设置硬盘开机挂载 备份与目录迁移使用 tar.gz备份打包: 这将使用 tar 命令将指定目录打包成一个压缩文件 backup.tar.gz.你可以将 /path/to/directory 替换为要备份的目录路径.使用 -c 参数表示创建新的备份,-z 参数表示使用 gzip 压缩,-v 参数表示显示备份过程中的详细信息. 还原备份: 这将使用 tar 命令解压缩备份文件 backup.tar.gz 并将文件还原到目标目录 /path/to/destination.使用 -x 参数表示解压缩,-z 参数表示使用 gzip 解压缩,-v 参数表示显示还原过程中的详细信息,-C 参数指定还原到的目标目录. HDParm 硬盘休眠让你的硬盘冷静下来,不要让服务器呼噜呼噜! 硬盘自动挂载在 /etc/fstab 文件中为硬盘指定了 nofail 选项,系统将忽略找不到硬盘的错误,并继续启动过程. 如果不幸 /etc/fstab 没有正确设置时,Ubuntu 仍然会启动,但是文件系统变为只读 read-only,需要把文件系统重新挂载为读写将 /etc/fstab 设置正确后重启保存. 测试硬盘读写 查看实时硬盘速率SMB 文件共享 NOTE: Whenever you modify this file you should run the command testparm to check that you have not made any basic syntactic errors. 进程相关开机自启动某个脚本 网络相关ApacheBench AB 接口 QPS&#x2F;TPS 测试 并发数(concurrent):并发数只某个时间范围内.同时在使用系统的用户个数.从实际场景来看,并发数就是同时使用该服务器接口的客户端数,这些客户端可能调用不同的 API.严格意义上来说,并发数是指同时请求同一个 API 的用户个数. QPS:Queries Per Second 意思是”每秒查询率”,是接口每秒能够相应的查询次数,是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准. TPS:是 Transactions Per Second 的缩写,也就是事务数&#x2F;秒.它是软件测试结果的测量单位.一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程.客户机在发送请求时开始计时,收到服务器响应后结束计时,以此来计算使用的时间和完成的事务个数. QPS 基本类似于 TPS,但是不同的是,对于一个页面的一次访问,形成一个 Tps;但一次页面请求,可能产生多次对服务器的请求,服务器对这些请求,就可计入 QPS 之中. 例如:访问一个页面会请求服务器 3 次,一次访问, 产生一个”T”,产生 3 个”Q” OpenVPN 参考:窗口 - 使用 OpenVPN,我如何只能让局域网通过 VPN?- 服务器故障 (serverfault.com) 重要 ROUTE: route addition failed - lsgxeva - 博客园 (cnblogs.com) networking - How to route only subnet in OpenVPN and not internet traffic - Super User 安装脚本:Nyr&#x2F;openvpn-install 服务端:server.conf 客户端:client.conf 命令行测速使用南开大学的命令行测速: 南大测速 NJU Test使用命令行工具测速 | e-Science Document 查看实时网卡流量使用 nload 工具 iperf3 点对点网络测速 (内网)iperf&#x2F;iperf3 是一个强大的测试网络最大带宽工具.作为一个跨平台的工具,可以为任何网络提供标准化的性能测量.iperf&#x2F;iperf3 具有客户端和服务器功能,可以创建数据流来测量两端之间单向或双向的网络吞吐量. 并支持 TCP&#x2F;UDP, 反向连接. 测速网站 NJU 南大测速 支持命令行:南大测速 NJU Test 中科大测速:中国科学技术大学测速网站 电信宽带测速:10000.gd.cn&#x2F;#&#x2F;speed 台大测速(测海外):NTU Speed5 查看监听的端口 view listening ports FRP2023&#x2F;12&#x2F;3: 起猛了,FRP 更新到了 0.52.3 版本,2023&#x2F;12&#x2F;3 版本,使用 toml 文件配置. GitHub:GitHub - fatedier&#x2F;frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet. 完整配置示例:conf 服务端配置frps.toml 客户端frpc.toml 配置代理 configure proxy在 .bash 或 .zshrc 配置 alias: configure apt: Shell 相关SSH 链接超时设置修改 server 端的 /etc/ssh/sshd_config SSH 配置密钥登陆客户端运行 编辑 /etc/ssh/sshd_config 文件,进行如下设置: 重启 ssh 服务: 清除 ssh 所有登录日志适用于 Debian 系和 Centos 系等发行版. ZSH 终端美化安装 SSH 设置密钥登陆并添加 hacker account用于一键下毒远控. 使用 SCP(secure copy) 命令传输文件 Docker安装国内加速:  官方命令安装: Useful Command 开启 IPV6【有用的小知识】Docker-qBittorrent 开启 IPv6 笔记 | 我不是咕咕鸽 编辑 /etc/docker/daemon.json ,添加以下内容:(如果没有这个文件直接创建) 重启: 清除 docker build cache Image 各种镜像Portainer 管理 UI Frps 服务端 frps.ini Frpc 客户端docker frpc 中文文档 到服务器的网速测试 使用 html5-speedtest Docker 使用 HomeBox GitHub - XGHeaven&#x2F;homebox: A Toolbox for Home Local Networks FileBrowser 文件管理 NFS 文件共享 NFS,是 Network File System 的简写,即网络文件系统.网络文件系统是 FreeBSD 支持的文件系统中的一种,也被称为 NFS. NFS 允许一个系统在网络上与他人共享目录和文件. 通过使用 NFS,用户和程序可以像访问本地文件一样访问远端系统上的文件. docker hub: 在 UNIX 和类 UNIX 系统中,&#x2F;etc&#x2F;exports 是一个配置文件,用于指定可以通过 NFS 共享的文件系统和相关参数.该文件定义了服务器上可供客户端挂载的共享目录以及访问权限.以下是&#x2F;etc&#x2F;exports 文件的一般格式和作用: 每一行代表一个共享目录的定义,具有以下基本格式: ​&lt;目录路径&gt;​:指定要共享的目录的路径.可以是绝对路径或相对路径. ​&lt;允许访问的客户端&gt;​:指定被允许访问该共享目录的客户端.可以使用 IP 地址、域名或子网掩码来指定.也可以使用通配符进行模式匹配,如 *​ 表示允许所有客户端访问. ​(选项)​:可选项,用于指定共享选项.常用的选项包括: ​rw​:允许读写访问权限. ​ro​:只允许读取访问权限. ​noaccess​:禁止访问该共享目录. ​root_squash​:将客户端的 root 用户映射为匿名用户(通常是 nfsnobody),以增加安全性. ​all_squash​:将所有用户映射为匿名用户,用于增加安全性. ​async​:异步写入,提高性能但降低可靠性. ​sync​:同步写入,确保数据的可靠性但性能较低. ​insecure​:允许不安全的访问请求,如非特权端口. ​no_subtree_check​:不进行子树检查. &#x2F;etc&#x2F;exports 文件的作用是定义 NFS 共享的配置信息,以便服务器将指定的目录和选项提供给客户端进行挂载和访问.每当修改 &#x2F;etc&#x2F;exports 文件后,需要使用 exportfs​ 命令重新加载 NFS 服务器的配置,以使更改生效. 仅通过 NFSv4 连接,则只需使用 TCP 端口 2049​ performance-tuning: Set the **NFS_SERVER_THREAD_COUNT**​ environment variable to control how many server threads rpc.nfsd​ will use. A good minimum is one thread per CPU core, but 4 or 8 threads per core is probably better. The default is one thread per CPU core. Running the container with --network host​ might improve network performance by 10% - 20% on a heavily-loaded server [1,2], though this hasn’t been tested. 查看 CPU 内核数:cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq​ 问题:the problem is in the docker-machine. If you want to use nfs mounts you need to run modprobe nfs in the machine itself, not in container. Container uses kernel of the machine. Same with modprobe nfs and nfs server.问题出在码头工人机器上.如果你想使用 nfs 挂载,你需要在机器本身而不是容器中运行 modprobe nfs.容器使用机器的内核.与 modprobe nfs 和 nfs 服务器相同. 在 Windows 上配置 NFS 客户端:  DDNS-GO基于 Golang 语言开发的 DDNS 程序.GitHub - jeessy2&#x2F;ddns-go: 简单好用的 DDNS.自动更新域名解析到公网 IP(支持阿里云、腾讯云、Dnspod、Cloudflare、Callback、华为云、百度云、Porkbun、GoDaddy、Google Domain) AdGuardHome DNSDocker · AdguardTeam&#x2F;AdGuardHome Wiki · GitHub SmartDNSSmartDNS 国内用 UDP DNS 国外用 https tls 的 DNS 修改本机 DNS: QBittorent 种子下载GitHub - SuperNG6&#x2F;Docker-qBittorrent-Enhanced-Edition: Docker-qBittorrent-Enhanced-Edition 因为涉及大量 UDP 之类的链接,请使用 host 网络.用 id 命令确定用户 UID 或者不使用 IPV6,在后期设置 IPV6需要改成 51782 端口,因为 6881 端口已经被封禁 AlistHome | AList 文档 Homarr 导航页Official Document: 👋 Welcome to Homarr | Homarr Docs 另外,国产的 flare 特别轻量,只不过要编写 yaml 文件. GitHub - soulteary&#x2F;docker-flare: Flare ✨ Lightweight, high performance and fast self-hosted navigation pages, resource utilization rate is &lt;1% CPU, MEM &lt;30 M, Docker Image &lt; 10M Aria2 下载一个用 C++ 编写的全平台全协议兼容的下载器. 源 aria2 项目:GitHub - aria2&#x2F;aria2: aria2 is a lightweight multi-protocol &amp; multi-source, cross platform download utility operated in command-line. It supports HTTP&#x2F;HTTPS, FTP, SFTP, BitTorrent and Metalink. Docker Aria2 Pro Docker 优化版: Aria2 Pro - 更好用的 Aria2 Docker 容器镜像 - P3TERX ZONE WebGUI AriaNG Mariadb 数据库 V2ray &#x2F; Xray Server一个 代理工具,推荐使用 Xray 内核. Project X Official Docs 更新 geoip.dat geosite.datLoyalsoldier&#x2F;v2ray-rules-dat Nginxdocker running TODO: 这边的 Docker 部署还需要优化 调优 Performance Tuning在 server 字段下添加 反向代理 反向代理 ws. nginx docs 解决 WS 反向代理超时问题, 在 server 字段下添加 自动添加 /​ 在 server 字段下添加: 完整支持 WS 的反向代理模板: 添加证书使用 acme.sh 申请证书 Nginx 配置 跨域 自用完整的 nginx.confnginx file format:  github repo:  OpenWRTx86 官方源 PythonUpdate latest Python version 更新 Python 版本Upgrade Python to latest version (3.12) on Ubuntu Linux or WSL2 Network Tools WebShell 查杀工具:SHELLPUB.COM 专注查杀,永久免费 IP 纯净度查询 IP Fraud Check    Windowns 实用命令Restart Windows Explorerrestart-explorer.cmd Clear_Event_Viewer_Logs.bat清除 Windows 事件查看器日志 delete-history.cmd清除 Windows 历史记录 引用 Reference 感谢以下博客的作者和教程网站,如有侵权请及时联系博主删除. Golang 和 Linux 学习笔记合集  ‍"},{"title":"玩客云折腾日志","date":"2021-12-19T11:37:48.000Z","url":"/wky-help/","tags":[["Linux","/tags/Linux/"],["WKY","/tags/WKY/"]],"categories":[["Linux","/categories/Linux/"]],"content":"玩客云折腾日志重新烧写玩客云 带螺丝批，拆机短接，双公 ​​**USB** 连接一体机烧写 Armbian5.67直刷包带宝塔.7z 玩客云通过网线直连一体机，参考：树莓派使用网线直连电脑的方法 - 知乎 (zhihu.com) 手机开热点一体机连接 Win10 可以直接从【设置 -&gt;网络和 Internet-&gt;状态 -&gt;更改适配器设置】进入可以看到，我们的本地网络连接方式有 WLAN 无线连接 和 以太网有线连接 两种方式。 记录当前我们的网络连接状况：arp -a 共享 WLAN 网络给以太网 更改适配器设置 界面中选择修改 WLAN 属性。选择共享，设置共享网络给以太网。（其他选项全部选择） 查询树莓派的 IP 地址 将树莓派的网线插到一体机的 PC 端口后再查询一次：arp -a 利用 Putty 连接玩客云。 SSH 远程账号 root ：密码 1234宝塔账号 onecloud ：密码 123456 玩客云配置 换源 参考：玩客云刷armbian更新源报错The repository ‘ stretch Release‘ does not have a Release file 修改源配置文件 卸载自带的宝塔面板 部署 ​​**Frpc​​ 内网穿透** 下载并解压 拷贝配置文件： 配置 systemctl 服务并设置开机自启动 systemctl 配置文件夹在 /etc/systemd/system/frpc.service 目录下 配置文件： 启动： Python 调优 Python 更换国内 pip 源： 部署校园网自动登录 ​​**FRPC​​ 配置自动获取脚本** 项目地址：AdminWhaleFall&#x2F;rpi-ping: 树莓派自动上传信息工具. (github.com) 脚本设置为 systemctl 服务： 新建 /etc/systemd/system/rpi.service ： 玩客云网络配置（重要） 设置静态 ip： 我们学校的校园网没有 dhcp 服务器，要手动设置 IP，教学楼的网段是：192.168.5.0&#x2F;24 然后把玩客云插到讲台下面的网线处.访问 192.168.5.12 测试 永久修改 dns： 禁用 dhcp 分配的 dns 服务器： 在 Resolvconf 中设置永久 DNSNameservers ： "},{"title":"Flask Web 框架学习笔记","date":"2021-08-18T11:37:48.000Z","url":"/python/flask-web-note/","tags":[["Coding","/tags/Coding/"],["Python","/tags/Python/"],["Flask","/tags/Flask/"]],"categories":[["Python","/categories/Python/"]],"content":"Flask Web 框架学习笔记 1. Flask 初始化参数 Flask 程序实例在创建的时候，需要默认传入当前 Flask 程序所指定的包(模块). import name Flask 程序所在的包 (模块),传 __name__ 就可以 其可以决定 Flask 在访问静态文件时查找的路径 staticurlpath 静态文件访问路径，可以不传，默认为: &#x2F;+ 静态文件目录名 static_ folder 静态文件存储的文件夹，可以不传，默认为 static template_ folder 模板文件存储的文件夹，可以不传，默认为 templates Flask 基本编写 2. Flask 工程配置加载的方式使用方式Flask 将配置信息保存到了 app.config 属性中，该属性可以按照字典类型进行操作。 设置 从配置对象中加载 从配置文件中加载 在项目目录下新建 setting.py 文件，存放大写常量 在 Flask 程序文件中 从环境变量中加载 环境变量 (environment variables) 一般是指在操作系统中用来指定操作系统运行环境的一些参数，如: 临时文件夹位置和系统文件夹位置等。环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。 通俗的理解，环境变量就是我们设置在操作系统中，由操作系统代为保存的变量值: 在 Linux 系统中设置和读取环境变量的方式如下: Flask 使用环境变量加载配置的本质是通过环境变量值找到配置文件，再读取配置文件的信息，其使用方式为：app.config.from_ envvar(&#39;环境变量名&#39;) 环境变量的值为配置文件的绝对路径先在终端中执行如下命令： export PROJECT_ _SETTING= &#39;~/ setting. py&#39; 再运行如下代码 各配置方式优缺点 app.config.from _object(配置对象) 继承 - -&gt;优点复用 敏感数据暴露缺点 app.config.from_pyfile(配置文件) 优点 –&gt; 独立文件保护敏感数据 缺点 –&gt; 不能继承文件路径固定不灵活 app.config.from_envvar(&quot; 环境变量名&quot;) 优点 –&gt; 独立文件保护敏感数据文件路径不固定灵活 缺点 –&gt; 不方便要记得设置环境量 设置环境变量 终端 export pycharm 设置 利用工厂函数设置 3. Flask 运行方式直接运行 Py 文件启动可以指定运行的主机 IP 地址，端口，是否开启调试模式 关于DEBUG 调试模式： 程序代码修改后可以自动重启服务器 在服务器出现相关错误的时候可以直接将错误信息返回到前端进行展示 新版启动方式开发服务器启动方式：在 1.0 版本之后，Flask 调整了开发服务器的启动方式，由代码编写 app. run() 语句调整为命令启动 flask 终端启动： 说明环境变量 FLASK_APP 指明 flask 的启动实例： flask run -h 0.0.0.0 -p 8000 绑定地址端口 flask run --help 获取帮助 生产模式与开发模式的控制通过 FLASK_ENV 环境变量指明 export FLASK_ ENV=production 运行在生产模式，未指明则默认为此方式 export FLASK_ ENV=development 运行在开发模式 4. Flask 路由查询路由信息 命令行方式 在应用中的 url_ map 属性中保存着整个 Flask 应用的路由映射信息，可以通过读取这个属性获取路由信息。 print(app.url_map)如果想在程序中遍历路由信息，可以采用如下方式： 搭建一个返回所有路由信息的 json 接口 5. 路由 Options 限定请求方式 Methods请求方式 GET(自带) OPTIONS(自带) -&gt; 简化版的 GET 请求用于询问服务器接口信息的比如接口允许的请求方式允许的 CORS 跨域:&lt;www.meiduo.site&gt; -&gt; api.meiduo.site&#x2F;users&#x2F;1options api.meiduo.site&#x2F;uses&#x2F;1 HEAD(自带) -&gt; 简化版的 GET 请求 只返回 GET 请求处理时的响应头，不返回响应体。 指定接口请求方式 6. 蓝图引入在一个Flask 应用项目中，如果业务视图过多，可以用某种方式划分出的业务单元单独维护，将每个单元用到的视图、静态文件、模板文件等独立分开。 例如从业务角度上，可将整个应用划分为用户模块单元、商品模块单元、订单模块单元，分别开发这些不同单元，并最终整合到一个项目应用中。 蓝图在 Flask 中，使用蓝图 Blueprint来分模块组织管理。 蓝图实际可以理解为是一个存储一组视图方法的容器对象，其具有如下特点: 一个应用可以具有多个 Blueprint 可以将一个Blueprint 注册到任何一个未使用的URL下，比如“&#x2F;user”、 “&#x2F;godds”。 Blueprint可以单独具有自己的模板、静态文件或者其它的通用操作方法，它并不是必须要实现应用的视图和函数的 在一个应用初始化时，就应该要注册需要使用的 Blueprint。★ 但是一个Blueprint并不是一个完整的应用，它不能独立于应用运行，而必须要注册到某一个应用中。★ 定义蓝图 定义 在这个蓝图对象上进行操作,注册路由,指定静态文件夹,注册模版过滤器 在应用对象中注册这个蓝图对象 单文件蓝图可以将创建蓝图对象与定义视图函数放在一个文件中。 目录（包）蓝图对于一个打算包含多个文件的蓝图，通常将创建蓝图对象放到 Python 包的 __init__.py 文件中 循环引用问题 所以导入视图函数要放在 __init__.py 文件的最后 蓝图内部静态文件和应用对象不同，蓝图对象创建时不会默认注册静态目录的路由。需要我们在创建时指定 static_folder 参数。 下面的示例将蓝图所在目录下的 static_admin 目录设置为静态目录 现在就可以使用 /admin/static_admin/&lt;filename&gt; 访问 static_ admin 目录下的静态文件了。也可通过 static_url_path 改变访问路径 7. 处理请求 在视图编写中需要读取客户端请求携带的数据时，如何才能正确的取出数据呢?请求携带的数据可能出现在 HTTP 报文中的不同位置，需要使用不同的方法来获取参数。 "},{"title":"Python 迭代器生成器修饰器","date":"2021-08-18T11:37:48.000Z","url":"/python/python-generator-iterator-decorater/","tags":[["Coding","/tags/Coding/"],["Python","/tags/Python/"]],"categories":[["Python","/categories/Python/"]],"content":"Python-Generator-Iterator-Decorater迭代器 迭代器指的是迭代取值的工具，迭代是一个重复的过程，并且每次重复都是基于上一次的结果而继续的， 单纯的重复并不是迭代! 可迭代对象 元组; 列表; 字典; 集合; 字符串等 生成器. 用 for 循环迭代 验证一个东西是否可迭代 可迭代不一定是迭代对象 (列表不是可迭代对象,但是可迭代.) 生成器可迭代,但可以迭代的不一定是生成器 iter() 可以将列表变成可迭代对象 迭代器的作用迭代器是用来迭代取值的工具，而涉及到把多个值循环取出来的类型 有：列表、字符串、元组、字典、集合、打开文件 上述迭代取值的方式只适用于有索引的数据类型：列表、字符串、元组.为了解决基于索引迭代器取值的局限性python 必须提供一种能够不依赖于索引的取值方式，这就是迭代器. 迭代器详解但凡内置有 __iter__() 方法的对象都称之为可迭代的对象: 迭代器对象: 内置有 __next__ 方法并且内置有 __iter__ 方法的对象迭代器对象 __next()__：得到迭代器的下一个值.迭代器对象 __iter__()：得到迭代器的本身，调用和没调用相同. 常见数据类型的分类: 可迭代对象：字符串、列表、元组、字典、集合、文件对象迭代器对象：文件对象 创建一个迭代器把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 。 iter() 方法返回一个特殊的迭代器对象,这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。 next() 方法会返回下一个迭代器对象。 StopIteration StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 创建一个返回数字的迭代器，初始值为 1，逐步递增 1 For 循环的工作原理for 循环可以称之为叫迭代器循环 d.iter() 得到一个迭代器对象 迭代器对象.next() 拿到一个返回值，然后将该返回值赋值给 k 循环往复,直到抛出 StopIteration 异常for 循环会捕捉异常然后结束循环. 生成器在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 ​​**yield​​ 的值**, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 生成器的使用 实例: 使用 yield 实现斐波那契数列： yield 关键字yield 关键字的作用是函数与调用者的通信，它不光能够将值返回给调用者，它还可以接收调用者传过来的值，那么怎么实现呢？ 调用者通过 send() 函数将值传递给generator，generator通过 yield 前面的变量 (形如:n = yield) 来接收 可以发现，send 函数和 next 函数的区别就是 send 函数可以在执行 generator 的过程中，给generator发送消息。而 next 仅仅是接收 yield 右边的变量值。 send()​方法用法 send 过来的数值 &#x3D; yield next 出来的数值 它的主要作用是，当我需要手动更改生成器里面的某一个值并且使用它，则send 发送进去一个数据，然后保存到 yield 语句的返回值，以提供使用. send() 的返回值就是那个本来应该被迭代出来的那个值。这样既可以保证我能够传入新的值，原来的值也不会弄丢. 实例: throw() 方法用法 简单来说就是:向生成器扔去一个异常,使生成器停止. raise exception in generator，return next yielded value or StopIteration，即在生成器中抛出异常，并且这个 throw 函数会返回下一个要迭代的值或者是StopIteration。还是通过几个例子来看吧！ 生成器的启动与关闭 close 生成器的启动 方法 1：​**直接使用**​**next(g)**​**，这会**​直接开始迭代第一个元素（推荐使用这个启动） 方法 2：​**使用**​**g.send(None)**​**进行启动，注意**​第一次启动的时候只能传入​**None，如果传入其他具体的指则会报错**哦！ 生成器的关闭 如果一个生成器被中途关闭之后，在此调用 next() 方法，则会显示错误，如下： 生成器的终止迭代——​**StopIteration** 前面讲的手动关闭生成器，使用 close() 方法，后面的迭代会抛出 StopIteration 异常。 在一个生成器中，如果没有 return，则默认执行到函数完毕时返回 StopIteration: 如果遇到 return,如果在执行过程中 return，则直接抛出 StopIteration 终止迭代: 如果在 return 后返回一个值，那么这个值为 StopIteration 异常的说明，不是程序的返回值。 注意：​**生成器没有办法使用**​**return**​**来返回值。因为**​**return**​**返回的那个值是通过**​StopIteration 的异常信息返回的，所以没办法直接获取这个 return 返回的值。 当然上面所说的无法获取return 返回值，我们指的是没有办法通过 result=g3() 这种形式获取return 的返回值。实际上还是有手段获取这个return 的值的，有两种方法： 使用 yield from 语句 因为 return 返回的值是作为StopIteration 的一个 value 属性存在的，StopIteration 本质上是一个类，所以可以通过访问它的value 属性获取这个 return 返回的值。使用下面的代码： yield​实现协程在 Python 中，协程通过 yield 实现。因为当一个函数中有 yield 存在的时候，这个函数是生成器，那么当你调用这个函数的时候，你在函数体中写的代码并没有被执行，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次使用这个生成器的时候被执行。 前面讲过yield 表达式的两个关键作用：①返回一个值、②接收调用者的参数 “调用者”与“被调用者”之间的通信是通过 send() 进行联系的 正是因为 yield 实现的生成器具备“中断等待的功能”，才使得 yield 可以实现协程。 例子 1:生产者 - 消费者模型 协程其实就是一个可以暂停执行的函数，并且可以恢复继续执行。那么 yield 已经可以暂停执行了，如果在暂停后有办法把一些 value 发回到暂停执行的函数中，那么 Python 就有了『协程』。于是有了, “把东西发送到已经暂停的生成器中” 的方法，这个方法就是 send()。 yield from 的简单实现yield 是每次“惰性返回”一个值，其实从名字中就能看出，yield from 是 yield 的升级改进版本，如果将yield 理解成“返回”，那么 yield from 就是“从什么（生成器）里面返回”，这就构成了 yield from 的一般语法，即: 其实她等同于: 这样的形式。我们通过一个简单例子来看： yield from 后面可以跟的可以是 “ 生成器 、元组、 列表、range() 函数产生的序列等可迭代对象” 简单地说,yield from generator 。实际上就是返回另外一个生成器。而 yield 只是返回一个元素。从这个层面来说，有下面的等价关系：yield from iterable 本质上等于 for item in iterable: yield item 。 yield from 的高级应用1. 针对 Yield 无法获取生成器 return 的返回值 在使用yield 生成器的时候，如果使用for 语句去迭代生成器，则不会显式的发出StopIteration 异常，而是自动捕获 StopIteration 异常，所以如果遇到 return，只是会终止迭代，而不会触发异常，故而也就没办法获取 return 的值。如下： for 迭代语句不会显式触发异常，故而无法获取到return 的值，迭代到 2 的时候遇到 return 语句，隐式的触发了 StopIteration 异常，就终止迭代了，但是在程序中不会显示出来。 如果是使用 next()​一次一次迭代，则会显式触发异常，但要获取 return 的返回值，我需要如下操作： 现在我们使用 yield from 来完成上面的同样的功能： 从上面的比较可以看出，yield from 具有以下几个特点： 单独​**yield​时：的 my_generator 是原始的生成器，main 是调用方，使用 yield 的时候，只涉及到这两个函数，即“调用方”与“生成器（协程函数）”是直接进行交互的，不涉及其他方法，即“调用方——&gt;生成器函数 (协程函数)”；** 在使用​**yield from​的时：多了一个对原始 my_generator 的包装函数，然后调用方是通过这个包装函数（后面会讲到它专有的名词）来与生成器进行交互的，即“调用方——&gt;生成器包装函数——&gt;生成器函数 (协程函数)”**； yield from iteration 结构会在内部自动捕获 iteration 生成器的 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样。而且对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 return 返回的值或者是 StopIteration 的 value 属性的值变成 yield from 表达式的值，即上面的 result。 委派生成器：包含 yield from 表达式的生成器函数；即上面的 wrap_my_generator生成器包装函数 子生成器：从 yield from 表达式中 部分获取的生成器；即上面的 my_generator生成器函数 调用方：调用委派生成器的客户端代码；即上面的main 调用方函数 2. Yield from 的管道传输用法示例其实 yield from 最重要的作用就是提供了一个“数据传输的管道”，下面通过一个简单的例子加以说明为什么是管道： 从上面我们可以发现，调用方发送的数据是发给 wrap_average 的，怎么依然到了生成器函数 average 里面呢？这就是“数据传输管道的作用”。即主函数调用方 main 把各个 value 传给 grouper ，而这个传入的值最终到达 averager 函数中； grouper 并不知道传入的是什么值，因为从上面的代码看出，**wrap_average​里面完全没有处理这个值的任何代码！** 装饰器函数引用 什么是闭包 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这些函数以及用到的一些变量称之为闭包。 闭包的应用 多个修饰器，从下到上修饰 装饰是倒着装的，执行是顺着执行的。 装饰有参数的函数 对不定长参数的传递 装饰有返回值的参数 通用修饰器 带参数的修饰器 在函数中嵌套闭包函数 "},{"title":"Python Tkinter 框架学习","date":"2021-08-18T11:37:48.000Z","url":"/python/python-tkinter-gui/","tags":[["Coding","/tags/Coding/"],["Python","/tags/Python/"],["GUI","/tags/GUI/"]],"categories":[["Python","/categories/Python/"]],"content":"Tkinter 框架学习GUI Tkinter 框架结构 常用组件汇总列表 面向对象的方式写 GUI 框架的经典实例 具体实现代码 Label ( 标签 ) 用法 组件 Option 选项设置 选项大全 Button Anchor 位置控制 Entry StrinngVar 输入框 输入框接收变量的类型 属性的双向关联 "},{"title":"Python asyncio 异步协程百万并发","date":"2021-08-18T11:37:48.000Z","url":"/python/python-async/","tags":[["Coding","/tags/Coding/"],["Python","/tags/Python/"]],"categories":[["Python","/categories/Python/"]],"content":" Python Asyncio 异步协程百万并发协程（coroutine）本质就是一个 函数 事件循环——(event_loop)协程函数，不是像普通函数那样直接调用运行的，必须添加到事件循环中，然后由事件循环去运行，单独运行协程函数是不会有结果的，看一个简单的例子： 在 python3.6 版本中，如果我们单独像执行普通函数那样执行一个协程函数，只会返回一个 coroutine 对象（python3.7）如下所示： 获取事件循环对象的几种方式 它是 python3.7 中新添加的，获得一个事件循环，如果当前线程还没有事件循环，则创建一个新的事件循环 loop； 通过事件循环运行协程函数的两种方式 创建事件循环对象 loop，即 asyncio.get_event_loop()，通过事件循环运行协程函数. 直接通过 asyncio.run(function_name) 运行协程函数。 但是需要注意的是，首先 run 函数是 python3.7 版本新添加的，前面的版本是没有的； 其次，这个 run 函数总是 会创建一个新的事件循环并在 run 结束之后关闭事件循环，所以，如果在 同一个线程中已经有了一个事件循环，则不能再使用这个函数了，因为 同一个线程不能有两个事件循环，而且这个 run 函数不能同时运行两次，因为他已经创建一个了。即同一个线程中是不允许有多个事件循环 loop 的。 Task 任务创建任务（两种方法） task = asyncio.create_task(coro()) 这是 3.7 版本新添加的,可以传协程函数 task = asyncio.ensure_future(coro()) 也可以： 获取某一个任务的方法 task=asyncio.current_task(loop=None)返回在某一个指定的 loop 中，当前正在运行的任务，如果没有任务正在运行，则返回 None；如果 loop 为 None，则默认为在当前的事件循环中获取. asyncio.all_tasks(loop=None)返回某一个loop 中还没有结束的任务 异步函数的结果获取对于异步编程、异步函数而言，最重要的就是 异步函数调用结束之后，获取异步函数的返回值，我们可以有以下几种方式 来获取函数的返回值，第一是直接通过 Task.result() 来获取；第二种是 绑定一个回调函数 来获取，即函数执行完毕后调用一个函数来获取异步函数的返回值。 直接通过 result 来获取. 通过定义回调函数来获取 注意：所谓的回调函数，就是指协程函数 coroutine 执行结束时候会调用回调函数。并通过 参数 future 获取协程执行的结果。我们创建的task 和回调里的 future 对象，实际上是 同一个对象，因为 task 是 future 的子类。 Asyncio 异步编程的基本模板第一步：构造事件循环 loop = asyncio.get_running_loop()返回（获取）在当前线程中正在运行的事件循环，如果没有正在运行的事件循环，则会显示错误；它是python3.7 中新添加的 loop = asyncio.get_event_loop()获得一个事件循环，如果当前线程还没有事件循环，则创建一个新的事件循环 loop； loop=asyncio.set_event_loop(thread)设置一个事件循环为当前线程的事件循环； loop=asyncio.new_event_loop()创建一个新的事件循环 第二步：将一个或者是多个协程函数包装成任务 Task task = asyncio.create_task(coro(参数列表))这是 3.7 版本新添加的 task = asyncio.ensure_future(coro(参数列表))需要注意的是，在使用 Task.result() 获取 协程函数结果的 时候，使用 asyncio.create_task() 却会显示错，但是使用 asyncio.ensure_future 却正确 第三步：通过事件循环运行 loop.run_until_complete(asyncio.wait(tasks))通过 asyncio.wait()​整合多个 task loop.run_until_complete(asyncio.gather(tasks))通过 asyncio.gather()​整合多个 task loop.run_until_complete(task_1)单个任务则不需要整合 loop.run_forever()但是这个方法在新版本已经取消，不再推荐使用，因为使用起来不简洁 使用 gather 和 wait 整合 Task 注册多个服务 参数形式不一样 gather的参数为 coroutines_or_futures,即如这种形式： wait的参数为列表或者集合的形式，如下: 返回的值不一样 gather 返回的是每一个任务运行的结果： 要以传入一个列表可变参数 可变参数允许在调用参数的时候传入多个参数,这些参数在调用时被自动组装为一个 tuple results = await asyncio.gather(*[tasks]) results = await asyncio.gather(task1,task2,task3) wait 返回 dones 是已经完成的任务，pending 是未完成的任务，都是集合类型： done, pending = yield from asyncio.wait(fs) 简单来说：async.wait 会返回两个值:done 和 pending，done 为已完成的协程 Task，pending 为超时未完成的协程 Task，需通过 future.result 调用 Task 的 result。而 async.gather 返回的是已完成 Task 的 result。 第四步：关闭事件循环 注意协程阻塞问题异步方式依然会有阻塞的，当我们定义的很多个异步方法 彼此之间有一来 的时候，比如，我必须要等到函数 1 执行完毕，函数 2 需要用到函数 1 的返回值，就会造成阻塞，这也是异步编程的难点之一，如何合理配置这些资源，尽量减少函数之间的明确依赖，这是很重要的。 结论：在有很多个异步方式的时候，一定要尽量避免这种 异步函数的直接调用，这和同步是没什么区别的，一定要 通过事件循环 loop，“让事件循环在各个异步函数之间不停游走”，这样才不会造成阻塞。 代码片段使用 Gather 同时注册多个任务，实现并发 异步 + 多线程 Httpx Aiohttp 之异步请求 aiohttp 实现 httpx 实现 感觉总体上比较 aiohttp 写起来舒服多了，少写很多异步代码。 之前使用 aiohttp 中的 resp.status 来获取状态码的时候写了 status_code，应该是使用 requests 习惯了吧，这下好了使用 httpx 不用担心这个写错的问题了。 深入理解 Python 协程 参考: Python Asyncio 文档 协程 asyncio.create_task() 函数用来运行作为 asyncio 任务的多个协程。 可等待对象如果一个对象可以在 await 语句中使用，那么它就是 可等待 对象。 可等待对象有三种主要类型: 协程 coroutine, task 和 Future. 协程协程函数: 定义形式为 async def 的函数;协程对象: 调用 协程函数 所返回的对象。 任务任务: 被用来 “并行的” 调度协程当一个协程通过 asyncio.create_task(coro,*,name=None) 等函数被封装为一个任务，该协程会被 自动调度 执行: 该任务会在 get_running_loop() 返回的循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError。 task.add_done_callback(func) 设置任务完成的回调函数 create_task 会把可等待对象被封装为一个任务,该协程会被 自动调度 执行,所以不用 await FuturesFuture 是一种特殊的 低层级 可等待对象，表示一个异步操作的 最终结果。 通常情况下没有必要在应用层级的代码中创建 ​Future 对象。 运行 Asyncio 协程asyncio.run(coro, *, debug=False) 执行 coroutine coro 并返回结果。此函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。 当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。 如果 debug 为 True，事件循环将以调试模式运行。 此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。 并发运行任务asyncio.gather(*aws, return_exceptions=False) 并发运行 aws 序列中的可等待对象。如果 aws 中的某个可等待对象为协程，它将自动被作为一个任务 (asyncio.create_task) 调度。 如果 return_exceptions 为 False (默认)，所引发的首个异常会立即传播给等待 gather() 的任务。aws 序列中的其他可等待对象 不会被取消 并将继续运行。 如果 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。 如果 gather 本身被取消，则无论 return_exceptions 取值为何，消息都会被传播。 超时协程 (可等待对象) asyncio.wait_for(aw, timeout) 等待 aw 可等待对象 完成，指定 timeout 秒数后超时。如果 aw 是一个协程，它将自动被作为任务 ((asyncio.create_task)) 调度。timeout 可以为 None，也可以为 float 或 int 型数值表示的等待秒数。如果 timeout 为 None，则等待直到完成。 如果发生超时，任务将取消并引发 asyncio.TimeoutError. 要避免任务 取消，可以加上 shield()。 此函数将等待直到 Future 确实被取消，所以总等待时间可能超过 timeout。 如果在取消期间发生了异常，异常将会被传播。 如果等待被取消，则 aw 指定的对象也会被取消。 简单等待coroutine asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED) 并发地运行 aws 可迭代对象中的 可等待对象(不能直接传入协程对象需要转换为 Task) 并进入阻塞状态直到满足 return_when 所指定的条件。 return_when 指定此函数应在何时返回: FIRST_COMPLETED: 在第一个可等待对象运行完毕后返回 FIRST_EXCEPTION: 在任意可等待对象抛出异常后返回,不会结束其他可等待对象,并在程序结束最后抛出异常 ALL_COMPLETED(默认): 在所有可等待对象执行完毕后返回 aws 可迭代对象必须不为空。 返回两个 Task&#x2F;Future 集合: (done, pending) (done, panding): done: 已完成的协程;panding: 正在等待的协程; 支持通过 if 判断 (和男朋友出去喝奶茶了,未完待续,可能会继续写一些应用场景,或者和 Golang 的 Goruntine 进行对比)……..2022&#x2F;8&#x2F;24 18:34 所谓「异步 IO」，就是你发起一个 IO 操作，却不用等它结束，你可以继续做其他事情，当它结束时，你会得到通知。 Asyncio 是并发（concurrency）的一种方式。对 Python 来说，并发还可以通过线程（threading）和多进程（multiprocessing）来实现。 Asyncio 并不能带来真正的并行（parallelism）。当然，因为 GIL（全局解释器锁）的存在，Python 的多线程也不能带来真正的并行。 可交给 asyncio 执行的任务，称为协程（coroutine）。一个协程可以放弃执行，把机会让给其它协程（即 yield from 或 await）。&#96; 定义协程协程的定义，需要使用 async def 语句。 do_some_work 便是一个协程。准确来说，do_some_work 是一个协程函数，可以通过 asyncio.iscoroutinefunction 来验证： 这个协程什么都没做，我们让它睡眠几秒，以模拟实际的工作量 ： 在解释 await 之前，有必要说明一下协程可以做哪些事。协程可以： 等待一个 future 结束 等待另一个协程（产生一个结果，或引发一个异常） 产生一个结果给正在等它的协程 引发一个异常给正在等它的协程 asyncio.sleep 也是一个协程，所以 await asyncio.sleep(x) 就是等待另一个协程。可参见 asyncio.sleep 的文档： 运行协程调用协程函数，协程并不会开始运行，只是返回一个协程对象，可以通过 asyncio.iscoroutine 来验证： 此处还会引发一条警告： 要让这个协程对象运行的话，有两种方式： 在另一个已经运行的协程中用 await 等待它 通过 ensure_future 函数计划它的执行 简单来说，只有 loop 运行了，协程才可能运行。下面先拿到当前线程缺省的 loop ，然后把协程对象交给 loop.run_until_complete，协程对象随后会在 loop 里得到运行。 run_until_complete 是一个阻塞（blocking）调用，直到协程运行结束，它才返回。这一点从函数名不难看出。run_until_complete 的参数是一个 future，但是我们这里传给它的却是协程对象，之所以能这样，是因为它在内部做了检查，通过 ensure_future 函数把协程对象包装（wrap）成了 future。所以，我们可以写得更明显一些： 完整代码： 运行结果： Waiting 3&lt;三秒钟后程序结束&gt; 回调假如协程是一个 IO 的读操作，等它读完数据后，我们希望得到通知，以便下一步数据的处理。这一需求可以通过往 future 添加回调来实现。 多个协程实际项目中，往往有多个协程，同时在一个 loop 里运行。为了把多个协程交给 loop，需要借助 asyncio.gather 函数。 或者先把协程存在列表里： 运行结果： 这两个协程是并发运行的，所以等待的时间不是 1 + 3 &#x3D; 4 秒，而是以耗时较长的那个协程为准。 参考函数 gather 的文档： 发现也可以传 futures 给它： gather 起聚合的作用，把多个 futures 包装成单个 future，因为 loop.run_until_complete 只接受单个 future。 run_until_complete 和 run_forever我们一直通过 run_until_complete 来运行 loop ，等到 future 完成，run_until_complete 也就返回了。 输出： 现在改用 run_forever： 输出： 三秒钟过后，future 结束，但是程序并不会退出。run_forever 会一直运行，直到 stop 被调用，但是你不能像下面这样调 stop： run_forever 不返回，stop 永远也不会被调用。所以，只能在协程中调 stop： 这样并非没有问题，假如有多个协程在 loop 里运行： 第二个协程没结束，loop 就停止了——被先结束的那个协程给停掉的。要解决这个问题，可以用 gather 把多个协程合并成一个 future，并添加回调，然后在回调里再去停止 loop。 其实这基本上就是 run_until_complete 的实现了，run_until_complete 在内部也是调用 run_forever。 Close Loop?以上示例都没有调用 loop.close，好像也没有什么问题。所以到底要不要调 loop.close 呢？简单来说，loop 只要不关闭，就还可以再运行。： 但是如果关闭了，就不能再运行了： 建议调用 loop.close，以彻底清理 loop 对象防止误用。 Gather vs. waitasyncio.gather 和 asyncio.wait 功能相似。 具体差别可请参见 StackOverflow 的讨论：python - Asyncio.gather vs asyncio.wait - Stack Overflow)。 抓住异步的异常： TimerC++ Boost.Asio 提供了 IO 对象 timer，但是 Python 并没有原生支持 timer，不过可以用 asyncio.sleep 模拟。 "},{"title":"😭2021年广东数学中考体验","date":"2021-06-28T11:37:48.000Z","url":"/study/zhongkao-maths/","tags":[["Study","/tags/Study/"],["Maths","/tags/Maths/"]],"categories":[["Study","/categories/Study/"]],"content":"😭😭😭2021 年广东数学中考体验个人感受 不请自来，这张试卷太气人了。这几个月刷了那么多道题，做了那么多练习，根本没什么卵用，考的都是什么奇奇怪怪的东西，选择题不知道第几题开始，人都傻了，那个秦九韶老师都没讲过，也没做过相关练习，还有就是证明圆相切，最后压轴题就真的气人！！！本来想着冲一波高分，现在别说高分，及格都不一定，一大堆没写完。 试题可以接地气，不可以接地府. “出题人是神经病” 数学最后一题，深圳 18 年高三一模原题 好吧。当我见到答题卡的时候，简单的图形，没有圆，尺规作图在第二十题（因为那里是个孤零零的直角三角形），二十四题貌似是个手拉手，二十五题没有图。 等到试卷发下来，通览全卷，问题感觉不大。考试开始….. 发下答题卡，25 没图？？？24 没圆？？？ 我察觉到了危险。 发下试卷，翻到最后，25 最后一小问平行四边形存在性问题，还好是送分。 问题是第一问是什么？！二次不等式？！ 我深吸一口气，决定这次做快点。 翻回去，考前五分钟做会选择。 第三题概率是我做概率选择题最久的一题（因为一般都是在几个中选几个，这次绕了点），这足以说明试卷的水平不简单。 第九题海伦公式,听说过,不会写,跳! 第十题类型题我刷过，那个 AB 会过定点，辅助线是三垂直，但是没有记的情况是定点 (0,1)，当时为了赶时间（别问为什么这么赶，只有 90 分钟啊，90 分钟！！！）我跳了这题。 第十五题为什么不是 $x^{2}+\\frac{1}{x^{2}}$ 而是 $x^{2}-\\frac{1}{x^{2}}$完了，硬算很费时间，跳了。 第十六题暴力三角函数相似勾股，有点费。但是算对了. 第十七题，定弦对等角出隐圆，作等腰直角三角形顶点就是圆心，挺简单的。 到大题了，第十八题居然不是算术，感觉不对劲。 第二十一题做着感觉没问题，出答案的时候 k 值有两个？！完了我漏解没了。。。 当我做二十三折叠题的时候，抬了下头，不到 30 分钟了？？？！！！ 不行了，后面还有道证明题，这折叠题算了,写了几个可能的步骤.跳! 时间还剩 20 分钟…… 证明题二十四题第一问还行，送分。 第二问我圆呢？自己作？算了这题跳了，写下取 AD 中点 M，设半径，不知道有没有分。 第三问我标了下长度，发现了三角形的面积可以通过等积变形转换,又有两个三角函数,求出底和高,搞定!。 时间还剩10 分钟左右… 最后一道压轴题，第一问我满脸问号？？？这什么玩意儿？？ 我求下导，画下草图，这形式有点像夹逼定理！（只是看着像而已） 一番惊奇过后，我认真思考下，要求不等式两边函数的切点，我求了，然后满脑空白，不知道接下来要做什么。。。 抬头看了时间，我苦笑了下，五分钟不到了。 于是我就开始蒙 a 的值，太大怕和上面的抛物线相交，太小又怕和下面那条直线相交。 我痛定思痛，就蒙 a&#x3D;2（然而答案是 1），把抛物线求了出来，仅此而已。 我跳回去，选择第十题蒙 C（答案是 A，而且图里也没有 30° 之类的东西，不可能出现这种数，大意了，但都快要收卷了谁还会管呀），填空第十五题蒙了。 打铃，收卷。 网上看到的一个关于 广东中考 的段子 我站在望北哨所，手里拿着红绸带，脑中思索着隐圆计算，收到了 2kg 荔枝，但是我只想吃豆沙粽和猪肉粽。恍惚间，我看到一辆跑车超速驶来，我连忙用超声波计算，制止了他的行为。我郑重的说:“ 先生，你这样不利于实现碳达峰和碳中和。他的眼中饱含泪水，注视着我，大喊一声:“这才是少年应有的模样!” 2021 年 广东中考数学 (今年) 题目 + 解析 附: 2020年 广东中考数学 (去年的,对比一下) "},{"title":"Kali 平台渗透教程","date":"2021-06-18T14:16:49.000Z","url":"/kali-linux-tutorial/","tags":[["Linux","/tags/Linux/"],["Kali","/tags/Kali/"]],"categories":[["Linux","/categories/Linux/"]],"content":" Kali Linux 漏洞审计 批量扫描 弱密码撞库 教程Nmap 端口扫描安装sudo apt-get install nmap 语法nmap [扫描类型] [扫描参数] [hosts 地址与范围] 扫描类型 -sT TCP connect() 扫描，这是最基本的 TCP 扫描方式。这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。 -sS TCP 同步扫描 (TCP SYN)，因为不必全部打开一个 TCP 连接，所以这项技术通常称为半开扫描 (half-open)。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要 root 权限来定制 SYN 数据包。 -sF,-sX,-sN 秘密 FIN 数据包扫描、圣诞树 (Xmas Tree)、空 (Null) 扫描模式。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应 RST 包，而打开的端口必需忽略有问题的包（参考 RFC 793 第 64 页）。 -sP ping 扫描，用 ping 方式检查网络上哪些主机正在运行。当主机阻塞 ICMP echo 请求包是 ping 扫描是无效的。nmap 在任何情况下都会进行 ping 扫描，只有目标主机处于运行状态，才会进行后续的扫描。 -sU UDP 的数据包进行扫描，如果你想知道在某台主机上提供哪些 UDP（用户数据报协议，RFC768) 服务，可以使用此选项。 -sA ACK 扫描，这项高级的扫描方法通常可以用来穿过防火墙。 -sW 滑动窗口扫描，非常类似于 ACK 的扫描。 -sR RPC 扫描，和其它不同的端口扫描方法结合使用。 -b FTP 反弹攻击 (bounce attack)，连接到防火墙后面的一台 FTP 服务器做代理，接着进行端口扫描。 扫描参数 -P0 在扫描之前，不 ping 主机。 -PT 扫描之前，使用 TCP ping 确定哪些主机正在运行。 -PS 对于 root 用户，这个选项让 nmap 使用 SYN 包而不是 ACK 包来对目标主机进行扫描。 -PI 设置这个选项，让 nmap 使用真正的 ping(ICMP echo 请求）来扫描目标主机是否正在运行。 -PB 这是默认的 ping 扫描选项。它使用 ACK(-PT) 和 ICMP(-PI) 两种扫描类型并行扫描。如果防火墙能够过滤其中一种包，使用这种方法，你就能够穿过防火墙。 -O 这个选项激活对 TCP&#x2F;IP 指纹特征 (fingerprinting) 的扫描，获得远程主机的标志，也就是操作系统类型。 -I 打开 nmap 的反向标志扫描功能。 -f 使用碎片 IP 数据包发送 SYN、FIN、XMAS、NULL。包增加包过滤、入侵检测系统的难度，使其无法知道你的企图。 -v 冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。 -S 在一些情况下，nmap 可能无法确定你的源地址 (nmap 会告诉你）。在这种情况使用这个选项给出你的 IP 地址。 -g port 设置扫描的源端口。一些天真的防火墙和包过滤器的规则集允许源端口为 DNS(53) 或者 FTP-DATA(20) 的包通过和实现连接。显然，如果攻击者把源端口修改为 20 或者 53，就可以摧毁防火墙的防护。 -oN 把扫描结果重定向到一个可读的文件 logfilename 中。 -oS 扫描结果输出到标准输出。 –host_timeout 设置扫描一台主机的时间，以毫秒为单位。默认的情况下，没有超时限制。 –max_rtt_timeout 设置对每次探测的等待时间，以毫秒为单位。如果超过这个时间限制就重传或者超时。默认值是大约 9000 毫秒。 –min_rtt_timeout 设置 nmap 对每次探测至少等待你指定的时间，以毫秒为单位。 -M count 置进行 TCP connect() 扫描时，最多使用多少个套接字进行并行的扫描。 端口状态 Open（开放的）意味着目标机器上的应用程序正在该端口监听连接 &#x2F; 报文。 filtered（被过滤的） 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap 无法得知 它是 open（开放的） 还是 closed（关闭的）。 closed（关闭的） 端口没有应用程序在它上面监听，但是他们随时可能开放。 unfiltered（未被过滤的）当端口对 Nmap 的探测做出响应，但是 Nmap 无法确定它们是关闭还是开放时 open filtered 开放或者被过滤的 closed filtered 关闭或者被过滤的 扫描实例 阿里云服务器网段大全：CSDN博客 CSDN-eagle_min大佬 腾讯云 ip 段：CSDN-eagle_min大佬 用 nmap 扫描该网段开放的 888 端口保存在 pma.txt 文件 格式要求：ip:portnmap -vv -n --open -p 888 网段 | awk -F&#39;[ /]&#39; &#39;/Discovered open port/&#123;print $NF&quot;:&quot;$4&#125;&#39; &gt;&gt; pma.txt Hydra 弱密码破解安装sudo apt-get install hydra Hydra 是一款非常强大的暴力破解工具，它是由著名的黑客组织 THC 开发的一款开源暴力破解工具。Hydra 是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。 常见参数 -R: 继续从上一次进度接着破解 -S: 大写，采用 SSL 链接 -s ： 小写，可通过这个参数指定非默认端口 -l ： 指定破解的用户，对特定用户破解 -L ： 指定用户名字典 p ： 小写，指定密码破解，少用，一般是采用密码字典 -P ： 大写，指定密码字典 -e ： 可选选项，n：空密码试探，s：使用指定用户和密码试探 -C ： 使用冒号分割格式，例如“登录名: 密码”来代替 -L&#x2F;-P 参数 -M ： 指定目标列表文件一行一条 o ： 指定结果输出文件 -f ： 在使用 -M 参数以后，找到第一对登录名或者密码的时候中止破解 -t ： 同时运行的线程数，默认为 16 -w ： 设置最大超时的时间，单位秒，默认是 30s -v &#x2F; -V： 显示详细过程 server： 目标 ip service： 指定服务名，支持的服务和协议 OPT： 可选项 实例分析1.破解 Sshhydra -M sship.txt ssh -L user.txt -P passwd.txt -e ns -f -vV -t 4 -o ssh.txt -M 指定目标列表文件 一条一行 -L 指定用户字典 -P 指定密码字典 -e ns 空密码试探 -f 当破解一个成功密码就停止 -o 把成功的输出到 ssh.txt 文件 -vV 显示详细信息 2.破解 3389 远程登录hydra -M rdpip.txt rdp -L user.txt -P passwd.txt -e ns -f -vV -t 16 -o rdp.txt 3.破解 MySQL 数据库hydra -M mysqlip.txt rdp -L user.txt -P passwd.txt -e ns -f -vV -t 16 -o mysql.txt"},{"title":"抑郁症用药大全对照表","date":"2021-06-18T11:37:48.000Z","url":"/depression-medicine/","tags":[["Depression","/tags/Depression/"],["Medicine","/tags/Medicine/"]],"categories":[["Depression","/categories/Depression/"]],"content":"抑郁症常用药物对照表利用 Python 爬取,项目地址:WhaleFell&#x2F;dxyMedicineSpider 正文 药物名称 (俗名) 主治 圣·约翰草提取物片 (路优泰) 抑郁症，焦虑和&#x2F;或烦躁不安。 马来酸氟伏沙明片 (兰释) 抑郁发作。强迫症 (OCD)。 盐酸氟西汀分散片 (百优解) 抑郁症强迫症 (OCD) 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 劳拉西泮片 (罗拉) 适用于焦虑障碍的治疗或用于缓解焦虑症状以及与抑郁症状相关的焦虑的短期治疗。与日常生活压力相关的焦虑或紧张，通常不需要抗焦虑药的治疗。劳拉西泮长期应用的效果即应用 4 个月以上的效果还未经系统的临床研究评估。医师应定期重新评估该药对个体患者的有效性。 阿戈美拉汀片 (维度新) 治疗成人抑郁症。本品适用于成人。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期 预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经 痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症， 可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 米氮平片 (瑞美隆®) 抑郁症的发作 盐酸度洛西汀肠溶胶囊 (欣百达) 用于治疗抑郁症； 用于治疗广泛性焦虑障碍； 用于治疗慢性肌肉骨骼疼痛。 氢溴酸西酞普兰片 (氢溴酸西酞普兰片) 治疗抑郁症。 噻奈普汀钠片 (达体朗) 抑郁发作 (即典型性)。 圣·约翰草提取物片 (路优泰) 抑郁症，焦虑和&#x2F;或烦躁不安。 马来酸氟伏沙明片 (兰释) 抑郁发作。强迫症 (OCD)。 盐酸氟西汀分散片 (百优解) 抑郁症强迫症 (OCD) 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 劳拉西泮片 (罗拉) 适用于焦虑障碍的治疗或用于缓解焦虑症状以及与抑郁症状相关的焦虑的短期治疗。与日常生活压力相关的焦虑或紧张，通常不需要抗焦虑药的治疗。劳拉西泮长期应用的效果即应用 4 个月以上的效果还未经系统的临床研究评估。医师应定期重新评估该药对个体患者的有效性。 阿戈美拉汀片 (维度新) 治疗成人抑郁症。本品适用于成人。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期 预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经 痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症， 可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 米氮平片 (瑞美隆®) 抑郁症的发作 盐酸度洛西汀肠溶胶囊 (欣百达) 用于治疗抑郁症； 用于治疗广泛性焦虑障碍； 用于治疗慢性肌肉骨骼疼痛。 氢溴酸西酞普兰片 (氢溴酸西酞普兰片) 治疗抑郁症。 噻奈普汀钠片 (达体朗) 抑郁发作 (即典型性)。 盐酸阿米替林片 (阿密替林) 用于治疗各种抑郁症，本品的镇静作用较强，主要用于治疗焦虑性或激动性抑郁症。 盐酸帕罗西汀片 (赛乐特) 本品用于治疗抑郁症、强迫症、伴有或不伴有广场恐怖的惊恐障碍、社交恐怖症&#x2F;社交焦虑症。 疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。 盐酸文拉法辛缓释胶囊 (怡诺思) 本品用于治疗抑郁症（包括伴有焦虑的抑郁症）及广泛性焦虑障碍。 草酸艾司西酞普兰片 (来士普) 治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。 盐酸舍曲林片 (左洛复) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止强迫症初始症状的复发。 阿戈美拉汀片 (维度新) 治疗成人抑郁症。br&#x2F;&gt;br&#x2F;&gt;本品适用于成人。 盐酸度洛西汀肠溶胶囊 (欣百达) 用于治疗抑郁症；br&#x2F;&gt;br&#x2F;&gt;用于治疗广泛性焦虑障碍。 盐酸帕罗西汀肠溶缓释片 (赛乐特) 用于治疗成人抑郁症。 在两项对符合美国精神障碍诊断统计手册（第四版）标准的抑郁症门诊患者进行的 12 周对照临床试验中，确立了盐酸帕罗西汀肠溶缓释片治疗抑郁症发作的有效性。尚未充分研究帕罗西汀对住院抑郁患者的抗抑郁作用。尚未在对照临床试验中对帕罗西汀肠溶缓释片超过 12 周的疗效安全性进行系统的评价；可是，在对照临床试验中证实了帕罗西汀速释片对抑郁症患者的长达 1 年维持治疗的有效性（参见【临床试验】）。 医生如果选择帕罗西汀肠溶缓释片进行长期治疗，应该定期对药物用于个体患者的长期有效性进行再评估。 盐酸氟西汀胶囊 (艾旭) 各种抑郁性精神障碍、包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 米氮平口腔崩解片 (瑞美隆®) 抑郁症的发作。对症状如快感缺乏，精神运动性抑制，睡眠欠佳（早醒），以及体重减轻均有疗效。也可用于其它症状如：对事物丧失兴趣，自杀念头以及情绪波动（早上好，晚上差）。本药在用药 1-2 周后起效。 盐酸文拉法辛胶囊 (博乐欣) 抑郁症。 盐酸多塞平片 (多虑平片) 用于治疗抑郁症及焦虑性神经症。 氢溴酸西酞普兰片 (氢溴酸西酞普兰片) 各种类型的抑郁症。 米氮平片 (瑞美隆) 用于抑郁症的治疗。 盐酸帕罗西汀片 (乐友) 治疗各种类型的抑郁症。包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力，睡眠障碍，对日常活动缺乏兴趣和愉悦感，食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象，从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸，出汗，气短，胸痛，恶心，麻刺感和濒死感。治疗社交恐怖症&#x2F;社交焦虑症。常见的社交焦虑的症状：心悸，出汗，气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。 米氮平片 (派迪生) 抑郁症。 氢溴酸西酞普兰片 (喜普妙) 治疗抑郁症。 草酸艾司西酞普兰片 (百适可) 治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。 盐酸帕罗西汀片 (舒坦罗) 本品用于治疗抑郁症、强迫症、伴有或不伴有广场恐怖的惊恐障碍、社交恐怖症&#x2F;社交焦虑症。 疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。 盐酸度洛西汀肠溶片 (奥思平) 用于治疗抑郁症。 盐酸氟西汀胶囊 (优克) 各种抑郁性精神障碍，包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 盐酸氟西汀片 (开克) 各种抑郁性精神障碍。包括轻性或重性抑郁症,双相情感性精神障碍的抑郁相,心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 吗氯贝胺片 (吗氯贝胺片) 抑郁症。 舒必利片 (舒必利片) 对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕 盐酸氟西汀胶囊 (奥麦伦) 各种抑郁性精神障碍、包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 舒必利片 (舒必利片) 对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 盐酸氟西汀胶囊 (百优解) 抑郁症; 强迫症; 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 舒必利片 (舒必利片) 对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其它用途有止呕。 盐酸阿米替林片 (盐酸阿米替林片) 用于治疗各种抑郁症，本品的镇静作用较强，主要用于治疗焦虑性或激动性抑郁症。 盐酸舍曲林片 (快五优) 盐酸舍曲林用于治疗抑郁症的相关症状.包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用盐酸舍曲林可有效地防止抑郁症的复发和再发。盐酸舍曲林也用于治疗强迫症，初始治疗有反应后，盐酸舍曲林在治疗强迫症二年的时间内、仍保持它的有效性，安全性和耐受性。 盐酸氟西汀肠溶片 (金开克) 本品适用于抑郁症缓解期，用于巩固期治疗和维持期疗效。 盐酸马普替林片 (路滴美) 抑郁症内源性抑郁症，迟发性抑郁症（更年期性抑郁症）。精神性抑郁症，反应性和神经性抑郁症、耗竭性抑郁症。 卡马西平片 (卡马西平片) 复杂部分性发作 (亦称精神运动性发作或颞叶癫癎)、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。不宁腿综合征 (Ekbom 综合征)，偏侧面肌痉孪。酒精癖的戒断综合征。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 舒必利片 (舒必利片) 对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 甲磺酸瑞波西汀胶囊 (甲磺酸瑞波西汀胶囊) 用于治疗成人抑郁症。 氯普噻吨片 (氯普噻吨片) 用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。 盐酸甲氯芬酯胶囊 (特维知®) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 卡马西平片 (卡马西平片) 1、癫痫：部分性发作：复杂部分性发作。全身性发作：强直、阵挛、强直阵挛发作。 2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3、预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5、酒精癖的戒断综合征。 阿戈美拉汀片 (阿美宁) 治疗成人抑郁症。本品适用于成人。 盐酸米安色林片 (盐酸米安色林片) 适用于药物治疗的各型抑郁症患者，能解除其抑郁症状。 盐酸氯米帕明注射液 (氯丙米嗪) 用于治疗严重抑郁症及难治性抑郁症。 盐酸安非他酮片 (乐孚亭) 用于治疗抑郁症。 甲磺酸瑞波西汀片 (甲磺酸瑞波西汀片) 用于治疗成人抑郁症。 盐酸文拉法辛缓释片 (盐酸文拉法辛缓释片) 本品适用于治疗各种类型抑郁症（包括伴有焦虑的抑郁症）及广泛性焦虑症。 甲磺酸瑞波西汀片 (佐乐辛) 用于治疗成人抑郁症。 盐酸舍曲林片 (唯他停) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 米氮平片 (米尔宁) 用于抑郁症的治疗。 氢溴酸西酞普兰片 (迈克伟) 各种类型的抑郁症。 卡马西平片 (卡马西平片) 1．癫痫： （1）部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。 （2）全身性发作：强直、阵挛、强直阵挛发作。 2．三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。3．预防或治疗躁狂 - 抑郁症：对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4．中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5．酒精癖的戒断综合征。 匹莫林片 (匹莫林片) 用于治疗儿童多动症、轻度抑郁症及发作性睡病。也可用于遗传性过敏性皮炎。 莫达非尼片 (莫达非尼片) 抑郁症患者。特发性嗜睡或发作性睡眠症 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 盐酸舍曲林片 (乐元) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (西同静) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 马来酸氟伏沙明片 (瑞必乐) 抑郁症及相关症状的治疗 ；强迫症症状的治疗。 氯普噻吨片 (氯普噻吨片) 用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。 阿普唑仑胶囊 (阿普唑仑胶囊) 催眠镇静药。适用于治疗焦虑症、抑郁症、失眠、恐惧。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 碳酸锂缓释片 (碳酸锂缓释片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 氯普噻吨片 (氯普噻吨片) 用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 卡马西平片 (卡马西平片) （1）癫癎：部分性发作，复杂部分性发作，简单部分性发作和继发性全身发作，全身性发作，全身性发作，强直、阵挛、强直阵挛发作。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂 - 抑郁症；对锂或抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）酒精癖的戒断综合征。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。 全身性发作：强直、阵挛、强直阵挛发作。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂一抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂一抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 酒精癖的戒断综合征。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂 - 抑郁症：对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 酒精癖的戒断综合征。 卡马西平片 (宁新宝) （1）癫痫：部分性发作：复杂部分性发作、简单部分发作和继发性全身发作。全身性发作：强直、阵挛、强制性挛发作。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）酒精癖的戒断综合征。 卡马西平片 (卡马西平片) 1.癫痫。部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 2.三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3.预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4.中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5.酒精癖的戒断综合征。 卡马西平片 (卡马西平片) 1.癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 2.三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3.预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4.中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5.酒精癖的戒断综合征。 舒必利片 (舒必利片) 对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 卡马西平胶囊 (卡马西平胶囊) 复杂部分性发作 (亦称精神运动性发作或颞叶癫痫)、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合症（Ekbom 综合征），偏侧面肌痉孪。 酒精癖的戒断综合征。 卡马西平片 (卡马西平片) （1）复杂部分性发作（亦称精神运动性发作或颞叶癫痫）、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 （6）不宁腿综合征（Ekbom 综合征），偏侧面肌痉孪。 （7）酒精癖的戒断综合征。 卡马西平片 (卡马西平片) 复杂部分性发作（亦称精神运动性发作或颞叶癫癎）、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合征（Ekbom 综合征），偏侧面肌痉挛。 酒精癖的戒断综合征。 卡马西平片 (卡马西平片) 复杂部分性发作（亦称精神运动性发作或颞叶癫痫）、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合征（Ekbom 综合征），偏侧面肌痉孪。 酒精癖的戒断综合征。 盐酸舍曲林分散片 (盐酸舍曲林分散片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑，有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 吗氯贝胺片 (恬泰) 抑郁症。 吗氯贝胺片 (亚正) 抑郁症 米氮平片 (派迪生) 抑郁症。 吗氯贝胺胶囊 (贝苏) 抑郁症。 盐酸氯米帕明注射液 (盐酸氯米帕明注射液) 用于治疗严重抑郁症及难治性抑郁症。 盐酸米那普仑片 (盐酸米那普仑片) 治疗抑郁症。 氢溴酸西酞普兰胶囊 (多弗) 治疗抑郁症。 氢溴酸西酞普兰片 (一泰纳) 治疗抑郁症。 氢溴酸西酞普兰口服溶液 (氢溴酸西酞普兰口服溶液) 各种类型的抑郁症。 盐酸安非他酮缓释片 (盐酸安非他酮缓释片) 用于治疗抑郁症。 盐酸安非他酮片 (盐酸安非他酮片) 用于治疗抑郁症。 氢溴酸西酞普兰片 (望悠) 各种类型的抑郁症。 氢溴酸西酞普兰片 (氢溴酸西酞普兰片) 各种类型的抑郁症。 盐酸安非他酮缓释片 (盐酸安非他酮缓释片) 用于治疗抑郁症。 盐酸安非他酮缓释片 (盐酸安非他酮缓释片) 用于治疗抑郁症。 氢溴酸西酞普兰片 (优乐喜) 各种类型的抑郁症。 氢溴酸西酞普兰片 (易特安) 各种类型的抑郁症。 盐酸氟西汀胶囊 (聚立能) 用于各种抑郁症的治疗。 盐酸安非他酮缓释片 (宏发) 用于治疗抑郁症。 盐酸安非他酮片 (盐酸安非他酮片) 用于治疗抑郁症。 盐酸度洛西汀肠溶胶囊 (奥思平) 用于治疗抑郁症。 氢溴酸西酞普兰口服溶液 (氢溴酸西酞普兰口服溶液) 各种类型的抑郁症。 米氮平片 (米尔宁®) 用于治疗抑郁症。 氢溴酸西酞普兰片 (望悠) 各种类型的抑郁症。 氢溴酸西酞普兰片 (氢溴酸西酞普兰片) 各种类型的抑郁症。 米氮平片 (米氮平片) 用于抑郁症的治疗。 草酸艾司西酞普兰 (草酸艾司西酞普兰) 治疗抑郁障碍 盐酸安非他酮缓释片 (盐酸安非他酮缓释片) 用于治疗抑郁症。 氢溴酸西酞普兰片 (特林那) 各种类型的抑郁症。 盐酸度洛西汀肠溶胶囊 (奥思平) 用于治疗抑郁症。 甲磺酸瑞波西汀片 (叶洛抒) 用于治疗成人抑郁症。 噻奈普汀钠片 (达体朗) 抑郁发作（即典型性） 盐酸舍曲林片 (盐酸舍曲林片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止强迫症初始症状的复发。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于各种类型抑郁症。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于各种类型抑郁症。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于各种类型抑郁症。 噻奈普汀片 (达体朗) 抑郁发作 (即典型性)。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于治疗各种类型抑郁症。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于各种类型抑郁症 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于各种类型抑郁症。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于各种类型抑郁症 盐酸文拉法辛片 (盐酸文拉法辛片) 适用于治疗各种类型抑郁症。 吗氯贝胺片 (吗氯贝胺片) 本品用于治疗抑郁症。 盐酸安非他酮缓释片 (Ⅱ)(盐酸安非他酮缓释片 (Ⅱ)) 本品用于治疗抑郁症。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于治疗各种类型抑郁症。 氢溴酸伏硫西汀片 (心达悦 Brintellix) 本品用于治疗成人抑郁症。 盐酸舍曲林胶囊 (联环优定) 舍曲林用于治疗 a class&#x3D;’J-redirect’ data-type&#x3D;’18’ data-id&#x3D;’127’ field-id&#x3D;’2325’&gt;抑郁症&#x2F;a&gt;的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。br&#x2F;&gt;br&#x2F;&gt;舍曲林也用于治疗 a class&#x3D;’J-redirect’ data-type&#x3D;’18’ data-id&#x3D;’129’ field-id&#x3D;’2329’&gt;强迫症&#x2F;a&gt;，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林胶囊 (盐酸舍曲林胶囊) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。br&#x2F;&gt;br&#x2F;&gt;舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸文拉法辛片 (盐酸文拉法辛片) 适用于治疗各种类型抑郁症。 盐酸舍曲林胶囊 (愈朗) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。 疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林胶囊 (郁洛欣) ​舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林分散片 (盐酸舍曲林分散片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (盐酸舍曲林片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (盐酸舍曲林片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊) 适用于治疗各种类型抑郁症。 盐酸舍曲林片 (申安) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (贝玉) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (盐酸舍曲林片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性，安全性和耐受性。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 盐酸舍曲林胶囊 (盐酸舍曲林胶囊) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林胶囊 (盐酸舍曲林胶囊) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (盐酸舍曲林片) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (彼迈乐) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (应思调) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸舍曲林片 (伊素明) 舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。 盐酸多塞平片 (天平) 用于治疗抑郁症及焦虑性神经症。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 盐酸多塞平片 (盐酸多塞平片) 用于治疗抑郁症及焦虑性神经症。 盐酸曲唑酮片 (舒绪) 本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。 盐酸曲唑酮片 (宏发) 本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。 盐酸氟西汀分散片 (盐酸氟西汀分散片) 抑郁症、强迫症、神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 盐酸马普替林片 (盐酸马普替林片) 用于各型抑郁症。对精神分裂症后抑郁也有效。 盐酸安非他酮缓释片 (盐酸安非他酮缓释片) 1、用于治疗抑郁症。2、用于辅助戒烟。 盐酸氟西汀分散片 (盐酸氟西汀分散片) 抑郁症; 强迫症; 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年 盐酸马普替林片 (盐酸马普替林片) 用于各型抑郁症。对精神分裂症后抑郁也有效。 草酸艾司西酞普兰片 (百洛特) 治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。 盐酸曲唑酮片 (舒绪) 本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。 盐酸帕罗西汀片 (盐酸帕罗西汀片) 治疗各种类型的抑郁症，包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力、睡眠障碍、对日常活动缺乏兴趣和愉悦感、食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象，从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸、出汗、气短、胸痛、恶心、麻刺感和濒死感。治疗社交恐怖症&#x2F;社交焦虑症。常见的社交焦虑的症状：心悸、出汗、气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。 盐酸马普替林片 (盐酸马普替林片) 用于各型抑郁症。对精神分裂症后抑郁也有效。 草酸艾司西酞普兰片 (草酸艾司西酞普兰片) 治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。 盐酸度洛西汀肠溶胶囊 (盐酸度洛西汀肠溶胶囊) 用于治疗抑郁症；用于治疗广泛性焦虑障碍。 盐酸度洛西汀肠溶胶囊 (盐酸度洛西汀肠溶胶囊) 抑郁症；广泛性焦虑障碍；慢性肌肉骨骼疼痛。 富马酸喹硫平缓释片 (富马酸喹硫平缓释片) 本品用于治疗精神分裂症和双相情感障碍的抑郁发作。 盐酸帕罗西汀片 (盐酸帕罗西汀片) 治疗各种类型的抑郁症，包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力、睡眠障碍、对日常活动缺乏兴趣和愉悦感、食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象、从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸、出汗、气短、胸痛、恶心、麻刺感和濒死感。治疗社交恐怖症&#x2F;社交焦虑症。常见的社交焦虑的症状：心悸、出汗、气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。 草酸艾司西酞普兰片 (草酸艾司西酞普兰片) 治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。 草酸艾司西酞普兰片 (草酸艾司西酞普兰片) 治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。 草酸艾司西酞普兰片 (草酸艾司西酞普兰片) 治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。 盐酸氟西汀胶囊 (盐酸氟西汀胶囊) 抑郁发作。强迫症。精神性贪食症：可作为心理治疗的补充，用于减少贪食和导泻行为。 氯普噻吨片 (氯普噻吨片) 用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。 氯普噻吨片 (氯普噻吨片) 用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。 富马酸喹硫平缓释片 (思瑞康) 用于治疗精神分裂症。 用于双相情感障碍的抑郁发作。 盐酸氯普噻吨注射液 (盐酸氯普噻吨注射液) 用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。 盐酸帕罗西汀肠溶缓释片 (盐酸帕罗西汀肠溶缓释片) 用于治疗成人抑郁症。 在两项对符合美国精神障碍诊断统计手册（第四版）标准的抑郁症门诊患者进行的 12 周对照临床试验中，确立了盐酸帕罗西汀肠溶缓释片治疗抑郁症发作的有效性。尚未充分研究帕罗西汀对住院抑郁患者的抗抑郁作用。 尚未在对照临床试验中对帕罗西汀肠溶缓释片超过 12 周的疗效安全性进行系统的评价；可是，在对照临床试验中证实了帕罗西汀速释片对抑郁症患者的长达 1 年维持治疗的有效性（参见【临床试验】）。医生如果选择帕罗西汀肠溶缓释片进行长期治疗，应该定期对药物用于个体患者的长期有效性进行再评估。 富马酸喹硫平缓释片 (富马酸喹硫平缓释片) 本品用于治疗精神分裂症和双相情感障碍的抑郁发作。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其它用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利注射液 (舒必利注射液) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 盐酸丙米嗪片 (盐酸丙米嗪片) 用于各种抑郁症。因具有振奋作用，适用于迟钝型抑郁，但不宜用于激越型抑郁或焦虑性抑郁。亦可用于小儿遗尿症。 巴戟天寡糖胶囊 (巴戟天寡糖胶囊) 温补肾阳。用于轻中度抑郁症中医辨证属于肾阳虚证者，症见抑郁情绪、心绪低落、失眠多梦、疲倦乏力等。 盐酸丙米嗪片 (盐酸丙米嗪片) 用于各种抑郁症。因具有振奋作用，适用于迟钝型抑郁，但不宜用于激越型抑郁或焦虑性抑郁。亦可用于小儿遗尿症。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 舒必利片 (舒必利片) 用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。 盐酸氟西汀胶囊 (盐酸氟西汀胶囊) 抑郁症：盐酸氟西汀胶囊用于治疗抑郁症状，伴有或不伴有焦虑症状，尤其是不需要镇静作用时。 强迫症。 神经性贪食症：盐酸氟西汀胶囊用于减少贪食和导泻行为。 惊恐障碍：盐酸氟西汀胶囊用于治疗伴有或不伴有广场恐怖症的惊恐障碍。 槟榔十三味丸 (槟榔十三味丸) 调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 奥氮平片 (奥氮平片) 精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。 盐酸文拉法辛缓释胶囊 (盐酸文拉法辛缓释胶囊) 本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版 (修订版)(DSM-III-R) 或诊断与统计手册第四版 (DSM-IV) 诊断标准的门诊成年抑郁症患者的疗效已在 8 周和 12 周的对照研究中得到确定。 一次抑郁发作 (DSM-IV) 是指明显和相对持久 (在 2 周时间内的几乎每一天) 的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在 2 周的时间内具有以下 9 项症状中的 5 项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症 (GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期 8 周和 6 个月的安慰剂对照研究证实本品对符合 DSM-IV 诊断标准的 GAD 患者有效。 广泛性焦虑症 (DSM-IV) 是指维持至少 6 个月难以控制的过分焦虑和担心 (预期)。 至少具有以下 6 项症状中的 3 项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期 6 个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效 (见 [用法用量])。 卡马西平片 (卡马西平片) 1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br&#x2F;&gt;br&#x2F;&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br&#x2F;&gt;br&#x2F;&gt;3、预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其他抗抑郁药合用。br&#x2F;&gt;br&#x2F;&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br&#x2F;&gt;br&#x2F;&gt;5、酒精癖的戒断综合征。 盐酸甲氯芬酯胶囊 (盐酸甲氯芬酯胶囊) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 盐酸甲氯芬酯胶囊 (健瑙素) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 槟榔十三味丸 (槟榔十三味丸) 调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 奥氮平片 (奥氮平片) 精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。 盐酸文拉法辛缓释胶囊 (盐酸文拉法辛缓释胶囊) 本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版 (修订版)(DSM-III-R) 或诊断与统计手册第四版 (DSM-IV) 诊断标准的门诊成年抑郁症患者的疗效已在 8 周和 12 周的对照研究中得到确定。 一次抑郁发作 (DSM-IV) 是指明显和相对持久 (在 2 周时间内的几乎每一天) 的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在 2 周的时间内具有以下 9 项症状中的 5 项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症 (GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期 8 周和 6 个月的安慰剂对照研究证实本品对符合 DSM-IV 诊断标准的 GAD 患者有效。 广泛性焦虑症 (DSM-IV) 是指维持至少 6 个月难以控制的过分焦虑和担心 (预期)。 至少具有以下 6 项症状中的 3 项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期 6 个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效 (见 [用法用量])。 卡马西平片 (卡马西平片) 1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br&#x2F;&gt;br&#x2F;&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br&#x2F;&gt;br&#x2F;&gt;3、预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其他抗抑郁药合用。br&#x2F;&gt;br&#x2F;&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br&#x2F;&gt;br&#x2F;&gt;5、酒精癖的戒断综合征。 盐酸甲氯芬酯胶囊 (盐酸甲氯芬酯胶囊) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 盐酸甲氯芬酯胶囊 (健瑙素) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 槟榔十三味丸 (槟榔十三味丸) 调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 奥氮平片 (奥氮平片) 精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。 盐酸文拉法辛缓释胶囊 (盐酸文拉法辛缓释胶囊) 本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版 (修订版)(DSM-III-R) 或诊断与统计手册第四版 (DSM-IV) 诊断标准的门诊成年抑郁症患者的疗效已在 8 周和 12 周的对照研究中得到确定。 一次抑郁发作 (DSM-IV) 是指明显和相对持久 (在 2 周时间内的几乎每一天) 的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在 2 周的时间内具有以下 9 项症状中的 5 项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症 (GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期 8 周和 6 个月的安慰剂对照研究证实本品对符合 DSM-IV 诊断标准的 GAD 患者有效。 广泛性焦虑症 (DSM-IV) 是指维持至少 6 个月难以控制的过分焦虑和担心 (预期)。 至少具有以下 6 项症状中的 3 项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期 6 个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效 (见 [用法用量])。 卡马西平片 (卡马西平片) 1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br&#x2F;&gt;br&#x2F;&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br&#x2F;&gt;br&#x2F;&gt;3、预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其他抗抑郁药合用。br&#x2F;&gt;br&#x2F;&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br&#x2F;&gt;br&#x2F;&gt;5、酒精癖的戒断综合征。 盐酸甲氯芬酯胶囊 (盐酸甲氯芬酯胶囊) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 盐酸甲氯芬酯胶囊 (健瑙素) 用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。 碳酸锂片 (碳酸锂片) 主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。 卡马西平片 (卡马西平片) 癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。 "},{"title":"😃 树莓派折腾手册 (一)——准备系统 😃","date":"2021-06-18T11:37:48.000Z","url":"/raspberrypi-note-1/","tags":[["Linux","/tags/Linux/"],["Respi","/tags/Respi/"]],"categories":[["Linux","/categories/Linux/"]],"content":"😃 树莓派折腾手册 (一)——准备系统 😃烧录官方 Debian 10 buster 系统镜像先用 SDFormatter 格式化一下内存卡叭: 1. 烧写镜像用到的软件： Win32 Disk Image 然后在 U 盘的根目录建立一个空白的 ssh 文件 方便 ssh 远程连接 用 Windows PowerShell 连接树莓派 sshshift+右键 呼出Windows PowerShell完整连接语法: 树莓派默认的用户名 pi 密码 raspberry 树莓派扩展 TF 卡分区:sudo raspi-config –&gt; Advanced options –&gt;Expand Filesystem, 确认重启 2. 启动树莓派 HDMI 功能 编辑 config.txt 文件，修改以下参数:sudo nano &#x2F;boot&#x2F;config.txt 把下面#注释符号去掉hdmi_force_hotplug&#x3D;1 #启用HDMI热插拔功能config_hdmi_boost&#x3D;4 #启用加强HDMI信号 不出意外的话应该可以接上，但是我的没有声音输出诶注：如果还是不能的话，找到#hdmi_group&#x3D;1 这句话，把前面的#注释符号去掉，把数字改成 2 强行指定显示器类型：1 是连接老式电视，2 代表连接新电视。 树莓派 Debian 10 buster 换清华源 更新源列表: sudo apt-get update 更新软件版本，升级软件包: sudo apt-get upgrade 树莓派 rasp-config 相关设置1. 设置 pi，root 用户密码，并解锁 2. respi 本地化操作 安装中文字体，提供几个 Linux 中文字体库: 设置终端中文显示: sudo raspi-config:选择 change_locale，在 Default locale for the system environment: 中选择 zh_CN.UTF-8。往下翻一会儿直到找到 zh_CN UTF-8 把光标移动到前面，然后按下空格键打上 * 改变键盘布局: sudo dpkg-reconfigure keyboard-configuration 3. 设置 Vnc 桌面 连接 注: 这里放弃了树莓派自带的 realvnc 因为不支持网页 novnc 且功能很少，所以用 Tightvnc 代替 安装Tightvncserver: sudo apt-get install tightvncserver 安装好之后设置一个VNC 密码: vncpasswd 注: 先输入操作密码两次，然后会询问是否设置一个查看 (view-only) 密码，按自己喜欢，一般没必要。 设置开机自启动 : 设置开机启动，需要在 &#x2F;etc&#x2F;init.d&#x2F; 中创建一个文件。例如tightvncserver: (启动脚本的名称，有和程序名一致的习惯) 然后给tightvncserver 文件加执行权限： 并更新开机启动列表： 一些service 命令 : 附: vnc 客户端下载vnc官网 连接成功惹~:编辑 .&#x2F;vnc&#x2F;xstartup 配置文件使其能与 windown 共享剪贴板 4.部署novnc 网页 方便在网页上控制树莓派屏幕，但是不支持 realvnc 安装 git 支持 克隆 novnc 项目: 在中国大陆听说加上 ​​**​​ 就可以加速 ​​克隆​​ 速度丫 改口 应换成  运行 novnc 并设置开机自启动: 尝试访问:  可 一些高级设置 : 连接速度太慢可以安装 Python 的 numpy 库解决 设置开机启动： 5.安装 cockpit Web 可视化管理 安装的依赖有 一丢丢多 默认是用 https 访问，需要修改配置文件使其能 http 访问 配置开机启动 页面 Python 设置概况 树莓派默认安装了两个版本的Python 树莓派 Pip 换源 pip更换为国内源，可以大大的提高安装成功率和速度。不管你用的是pip3 还是 pip，方法都是一样的 更新 pip 版本 树莓派指定 Python 版本安装模块 部署 Zsh"},{"title":"😏 树莓派折腾手册（三）——搭建离线下载器 👀","date":"2021-06-18T11:37:48.000Z","url":"/raspberrypi-note-2/","tags":[["Linux","/tags/Linux/"],["Respi","/tags/Respi/"]],"categories":[["Linux","/categories/Linux/"]],"content":"😏 树莓派折腾手册（三）——搭建离线下载器 👀1.挂载硬盘&#x2F;U 盘 注意：开始之前先把存储设备格式化成 fat32 文件系统 树莓派 4B Debian10 系统插上储存设备后默认自动挂载到 /media 目录我们先卸载 U 盘： 查询硬盘状态: sudo fdisk -l 编辑 /etc/fstab 中添加像下面这样的挂载配置： 重启 ，不出意外的话开机 应该 会自动挂载，且有写权限，用户是 pi：如图挂载至 /home/pi/disk 目录，有777 权限 2.部署 Aria2 离线下载器 下载安装 Aria2: 安装 nginx： 上面已经安装过的小可爱可以跳过 配置 Aria2， 创建配置文件： 编辑 Aria2配置 文件: 创建systemd文件在 /lib/systemd/system/aria2.service 为如下: 启动Aria2: 配置nginx+ariaNg可视化管理页面： 到 AriaNG​开源项目页面 获取最新版版本 把源码克隆到 /website/AriaNg/： 为了方便使用，我把AriaNg和jsonrpc都配置在了 80 端口，利用 nginx 的代理功能，把本机 6800 端口隐藏,对外只暴露 80 端口. 尝试访问 http:&#x2F;&#x2F;树莓派ip&#x2F;aria2 ，设置参数 "},{"title":"😜 树莓派折腾手册 (二)——手动搭建LNMP网站服务器环境 🙏","date":"2021-06-18T11:37:48.000Z","url":"/raspberrypi-note-3/","tags":[["Linux","/tags/Linux/"],["Respi","/tags/Respi/"]],"categories":[["Linux","/categories/Linux/"]],"content":"😜 树莓派折腾手册 (二)——手动搭建 LNMP 网站服务器环境 🙏 前言：这个东西我折腾了很久，试过一键部署脚本:  但是我想在局域网 +frp 穿透的外网，访问树莓派的网站，但是只能绑定一个域名，反正用多了就出各种问题，可能我不会用 1.安装 PHP7.3 这里跳了很多坑，后来查文档才发现 Debian 10 buster 只能安装 PHP7.0 以上的版本 通过命令 php -v 能够看到 PHP 版本号 7.3，说明安装完成: 输出显示配置文件在&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;cli&#x2F;php.ini。注意，实际上配置文件有两个，另外一个在&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;fpm&#x2F;php.ini。通过命令行调用 php 时，会使用第一个配置文件；通过 fpm 调用 php（例如 nginx）会使用第二个配置文件。 php-fpm 常用管理命令: 2.安装 nginx: 安装完成后，会自动开启 nginx。在浏览器输入树莓派的 IP 地址，可以看到“Welcome to nginx!” nginx 常用管理命令： 3.配置 Nginx 解析 Php (关键) 编辑配置 nginx 文件: 找到 # pass PHP scripts to FastCGI server 后面的 location ，删除注释。修改后如下： PHP 的默认路径转发有问题导致的,因为很多 nginx 的默认 PHP 配置文件的写法为 location ~ ​​php 要改成 location~.​php(​.​)*$ 保存后重启 nginx： 重启无报错则修改成功啦: 在网站根目录创建一个 php 文件： 写入以下 php 代码并保存： 在浏览器中输入树莓派的 IP 地址即可看到 phpinfo: 4.安装 mariaDB 数据库 使用以下命令安装 mariadb: 执行数据库初始化安装: 根据提示设置数据库 root用户密码、是否允许外网访问 等，建议用翻译软件，一步步翻译。 回车 n Y n Y Y 尝试用普通用户 pi登录数据库:mysql -u root -p输入上一步设置的密码，发现无法登录，错误提示如下: ERROR 1698 (28000): Access denied for user ‘root’@’localhost’ 原因: 数据库默认使用特权用户 root 登录，需要修改为普通用户使用密码登录 尝试用特权用户 root登录数据库: 再次使用普通用户 pi mysql -u root -p 即可通过密码登录数据库，无需 root 权限执行: 设置数据库密码依次执行以下 SQL： 设置mariaDB 数据库 外部网络访问权限 根据官方的说法， MariaDB 为了提高安全性，默认只监听 127.0.0.1 中的 3306 端口并且禁止了远程的 TCP 链接，我们可以通过下面两步来开启MySQL 的远程服务 打开文件 sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf，注释掉 bind-address 项，如下: 开启了MySQL 监听远程连接的选项，接下来需要给对应的MySQL 账户分配权限，允许使用该账户远程连接到 MySQL:查看用户账号信息： root 账户中的 host 项是localhost表示该账号只能进行本地登录，我们需要修改权限，执行 MySQL 命令: 这个时候发现相比之前多了一项，它的host 项是%，这个时候说明配置成功了，我们可以用该账号进行远程访问了 mariadb 配置文件保存在多个位置: mariadb 常用命令: 连接 MySQL数据库命令: (注:u 与 root 可以不用加空格，其它也一样) 5.安装 phpmyadmin 可视化 MySQL 管理工具 官方网站: phpmyadmin官网 用wget下载源码包包到 web 目录(请自行到官网获取最新下载链接)，截至 2020&#x2F;8&#x2F;4 版本为:phpMyAdmin-5.0.2-all-languages.zip 解压 zip 格式源码包包到web 目录 若 unzip 不受支持请安装sudo apt-get install unzip 重命名文件夹并修改参数 编辑 config.inc.php 文件，修改密钥字段: 修改blowfish_secret字段，后面的密钥无仅仅用于加密而已，尽量足够长。当然偷偷插入​**喜欢的女孩子​名字也是可以的哦** 把config.inc.php 文件权限修改为 744 尝试访问 http:&#x2F;&#x2F;你的树莓派ip&#x2F;phpmyadmin启动高级功能 会新建一个 phpmyadmin 数据库安装成功！ 6.搭建多个 nginx 虚拟主机 有时候我们要在主机的不同端口搭建不同用处的web 服务，这时就需要多个新建多个 nginx 虚拟主机的啦~ 打开 nginx 主配置文件 找到 include 字段就是每个虚拟主机配置文件，为了方便管理，我们在用户家目录新建一个 nginx-conf 存放我们的nginx 虚拟主机文件 写入以下内容: (贴出一份完整的 nginx 虚拟主机配置，需要自行修改两个参数) 重启 nginx，愿一切安好: 7. 树莓派 PHP 调优 lnmp 默认环境部署完成后，进行调优以应对多并发，复杂任务的情景 部署PHP 探针以测试 部署服务器探针推荐 X 探针，GitHub 项目地址： GitHub X刘海探针 尝试访问 http://树莓派ip : 可以看到这些参数都是好 鸡肋的 修改php.ini 仔细看好喽~ 修改 **post 方式提交的数据大小**，查找：post_max_size 酌情修改为 2000M 修改 运行超时秒数 ，查找：max_execution_time 酌情修改为 3600s 修改 上传文件限制 ，查找：upload_max_filesize 酌情修改为 2000M 修改 运行内存限制 ，查找：memory_limit 酌情修改为 2000M 开启 文件上传 ,查找：file_uploads 更改为 On 更改完成后重启 nginx+php-fpm 更改后的探针页面： 8.搭建 kodbox 云私有云盘 下载安装即刻下载，开启私有云盘之旅**官网:**​**** 下载源码 尝试访问 **** : 除了 PHP 版本外其他都可以通过哒~ 安装系统缓存 Redis redis 服务会自动运行自动添加开机启动项，省心！！！ 编辑​sudo nano /etc/php/7.3/fpm/php.ini 文件加入： 数据库选择MySQL，填入自己的密码系统缓存类型选择 Redis"},{"title":"Python 并发编程笔记","date":"2021-06-18T11:37:48.000Z","url":"/python/python-concurrent/","tags":[["Coding","/tags/Coding/"],["Python","/tags/Python/"]],"categories":[["Python","/categories/Python/"]],"content":"Python 并发编程各并发技术 1. 多线程 Thread（threading） 优点：相比进程，更轻量级、占用资源少. 缺点： 相比进程：多线程只能并发执行，不能利用多 CPU（GIL） 相比协程：启动数目有限制，占用内存资源，有线程切换开销 适用于：IO 密集型计算、同时运行的任务数目要求不多 多进程普通写法 利用线程池技术 好处: 新建线程系统需要分配资源、终止线程系统需要回收资源,线程池可以重用线程，则可以减去新建&#x2F;终止的开销 原理 代码实现 map 方式提交 map 的结果和入参是顺序对应的,且 map 传入函数参数时要传入参数列表 Python Zip()函数 zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。 我们可以使用 list() 转换来输出列表。 元素个数与最短的列表一致. 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 submit 方式提交 future 模式，更强大,注意如果用 as_completed 顺序是不定的 Python3 字典 items方法 Python 字典 items() 方法以列表返回视图对象，是一个可遍历的 key&#x2F;value 对。 将: &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7&#125; 变为: [(&#39;Age&#39;, 7), (&#39;Name&#39;, &#39;Runoob&#39;)] 方法一 方法二 适合需要与某一个量一一对应建立联系 生产者消费者模型 ( Producer, Consumer) 多组件的 Pipeline 技术架构 复杂的事情一般都不会一下子做完，而是会分很多中间步骤一步步完成 多线程数据通信的​**queue.Queue** queue.Queue 可以用于多线程之间的、线程安全的数据通信 多个线程 可以 同时 读取 同一个队列 实例: 2. 多进程 (MultiProcess)全局解释器锁 (Python 的大缺点) 任何时刻仅有一个线程在执行。 在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程 GIL 目的：为了解决多线程之间数据完整性和状态同步问题 GIL 带来的问题 即使使用了多线程，同一时刻也只有单个线程使用 CPU，导致多核 CPU 的浪费 GIL 只会对CPU 密集型的程序产生影响 如果程序主要是在做I&#x2F;O 操作，比如处理网络连接，那么多线程技术常常是一个明智的选择 规避 GIL的方法 规避方法 2： 使用 multiprocessing 多进程，对 CPU 密集型计算，单独启动子进程解释器去执行 规避方法 2： 将计算密集型的任务转移到C 语言中，因为 C 语言比 Python 快得多，注意要在 C 语言中自己释放 GIL 多进程适用于 CPU 密集型计算多进程的 API 与 多线程的实现十分类似 语法条目 多线程 多进程 引入模块 from threading import Thread from multiprocessing import Process 新建 启动 等待结束 t&#x3D;Thread(target&#x3D;func, args&#x3D;(100, )) t.start() t.join() p &#x3D; Process(target&#x3D;f, args&#x3D;(‘bob’,)) p.start() p.join() 数据通信 import queue q &#x3D; queue.Queue() q.put(item) item &#x3D; q.get() from multiprocessing import Queue q &#x3D; Queue() q.put([42, None, ‘hello’]) item &#x3D; q.get() 线程安全加锁 from threading import Lock lock &#x3D; Lock() with lock: # do something from multiprocessing import Lock lock &#x3D; Lock() with lock: # do something 池化技术 from concurrent.futures import ThreadPoolExecutor with ThreadPoolExecutor() as executor: # 方法 1 results &#x3D; executor.map(func, [1,2,3]) # 方法 2 future &#x3D; executor.submit(func, 1) result &#x3D; future.result() from concurrent.futures import ProcessPoolExecutor with ProcessPoolExecutor() as executor: # 方法 1 results &#x3D; executor.map(func, [1,2,3]) # 方法 2 future &#x3D; executor.submit(func, 1) result &#x3D; future.result() 利用进程池技术实现多进程 3. 并发锁 (Concurrent Lock) 线程安全指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。 由于线程的执行随时会发生切换，就造成了不可预料的结果，出现线程不安全(简单来说就是程序串行) 用法 1: try-finally 模式 用法 2: with 模式 (推荐这种方式) 什么时候需要上锁 多人读,不需要|一读一写要加|多人写要加 只是操作共享变量部分的代码要上锁,而不是多线程中所有代码都要上锁,并不影响多线程的执行效果. 4. 异步协程原理 同步：执行 IO 操作时，必须等待执行完成才得到返回结果。异步：执行 IO 操作时，不必等待执行就能得到返回结果。 注意：要用在异步 IO 编程中,依赖的库必须支持异步 IO 特性. 爬虫引用中：requests 不支持异步|需要用 aiohttp 补充1. 什么是协程、异步举个例子：假设有 1 个洗衣房，里面有 10 台洗衣机，有一个洗衣工在负责这 10 台洗衣机。那么洗衣房就相当于 1 个进程，洗衣工就相当1 个线程。如果有 10 个洗衣工，就相当于10 个线程，1 个进程是可以开多线程的。这就是多线程！ 那么协程呢？先不急。大家都知道，洗衣机洗衣服是需要等待时间的，如果 10 个洗衣工，1 人负责 1 台洗衣机，这样效率肯定会提高，但是不觉得浪费资源吗？明明 1 个人能做的事，却要 10 个人来做。只是把衣服放进去，打开开关，就没事做了，等衣服洗好再拿出来就可以了。就算很多人来洗衣服，1 个人也足以应付了，开好第一台洗衣机，在等待的时候去开第二台洗衣机，再开第三台，……直到有衣服洗好了，就回来把衣服取出来，接着再取另一台的（哪台洗好先就取哪台，所以协程是无序的）。这就是计算机的协程！洗衣机就是执行的方法。 当你程序中方法需要等待时间的话，就可以用协程，效率高，消耗资源少。 洗衣房 &#x3D;&#x3D;&gt; 进程 | 洗衣工 &#x3D;&#x3D;&gt; 线程 | 洗衣机 &#x3D;&#x3D;&gt; 方法 (函数) 2. async \\ await 的使用正常的函数在执行时是不会中断的，所以你要写一个能够中断的函数，就需要添加 async 关键字。 async 用来声明一个函数为异步函数，异步函数的特点是能在函数执行过程中挂起，去执行其他异步函数，等到挂起条件（假设挂起条件是 sleep(5)）消失后，也就是 5 秒到了再回来执行。 await 用来用来声明程序挂起，比如异步程序执行到某一步时需要等待的时间很长，就将此挂起，去执行其他的异步程序。await 后面只能跟 异步函数 或有 __await__ 属性的对象，因为异步程序与一般程序不同。 假设有两个异步函数 async a，async b，a 中的某一步有 await，当程序碰到关键字 await b() 后，异步程序挂起后去执行另一个异步 b 程序，就是从函数内部跳出去执行其他函数，当挂起条件消失后，不管 b 是否执行完，要马上从 b 程序中跳出来，回到原程序执行原来的操作。如果 await 后面跟的b 函数不是异步函数，那么操作就只能等 b 执行完再返回，无法在b 执行的过程中返回。如果要在b 执行完才返回，也就不需要用 await 关键字了，直接调用 b 函数就行。所以这就需要 await 后面跟的是异步函数了。在一个异步函数中，可以不止一次挂起，也就是可以用多个 await。 基本实现: 在普通的函数前面加 async 关键字； await 表示在这个地方等待子函数执行完成，再往下执行。（在并发操作中，把程序控制权交给主程序，让他分配其他协程执行。） await 只能在带有 async 关键字的函数中运行。 利用 aiohttp 模块发送网络请求 利用 aiofile 异步操作文件"},{"title":"博客写作规范约束","date":"2018-12-11T07:51:48.000Z","url":"/hexo-blog-log/","tags":[["Hexo","/tags/Hexo/"],["Blog","/tags/Blog/"]],"categories":[["Hexo","/categories/Hexo/"]],"content":"博客写作规范约束头注 reference: Fluid 主题文档 头注必须注明 title 、data 、categories(分类)、tags(标签)，其中分类和标签需要统一使用英文字符，post_/ 目录下的 Markdown 文件名需要使用英文，hexo 会根据文件名生成路径。 md 文件名遵从 Key-Word.md 格式，单词之间用 - 分隔，每个单词需要首字母大写。 categories 有且只有一个,tags 可以有多个. 根据时间排序文章. 该参数可以设置置顶文章，sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。 Blog Banner Img 生成使用 CoverView 设计博客 banner 图片，统一头图风格！ MarkDown 语法严格遵循 markdown 语法,不使用任何不是标准 MD 兼容的语法,避免迁移时出现问题. 图床已经部署在 OneDrive 上了，速度快，简洁，方便： 使用的是自制的 onedrive 直连提取 python 程序(base on fastapi)，并部署到 vercel 上，使用方法： vercel 感觉对 FastAPI 的支持不是很好，所以用 render.com 上也部署了一个： 本地部署"},{"title":"博客写作规范约束","date":"2018-12-11T07:51:48.000Z","url":"/hexo-blog-standard/","tags":[["Hexo","/tags/Hexo/"],["Blog","/tags/Blog/"]],"categories":[["Hexo","/categories/Hexo/"]],"content":"博客写作规范约束头注 reference: Fluid 主题文档 头注必须注明 title 、data 、categories(分类)、tags(标签)，其中分类和标签需要统一使用英文字符，post_/ 目录下的 Markdown 文件名需要使用英文，hexo 会根据文件名生成路径。 md 文件名遵从 Key-Word.md 格式，单词之间用 - 分隔，每个单词需要首字母大写。 categories 有且只有一个,tags 可以有多个. 根据时间排序文章. 该参数可以设置置顶文章，sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。 Blog Banner Img 生成使用 CoverView 设计博客 banner 图片，统一头图风格！ MarkDown 语法严格遵循 markdown 语法,不使用任何不是标准 MD 兼容的语法,避免迁移时出现问题. 图床已经部署在 OneDrive 上了，速度快，简洁，方便： 使用的是自制的 onedrive 直连提取 python 程序(base on fastapi)，并部署到 vercel 上，使用方法： vercel 感觉对 FastAPI 的支持不是很好，所以用 render.com 上也部署了一个： 使用正则进行本地图片替换: 本地部署"},{"title":"找不到頁面","date":"2024-08-23T18:42:35.623Z","url":"/404.html","categories":[[" ",""]]},{"title":"About","date":"2021-07-28T17:43:47.000Z","url":"/about/index.html","categories":[[" ",""]],"content":"About Me喵唔…. 唔…这里是 落落。 零落，孤独，不遇合，人生起起落落落。也指鲸落海底，哺暗界众生十五年，如星辰入海，侵万鲸成宇宙。 06 &#x2F; 高三休学 &#x2F; 理科生中的美术牲 &#x2F; Python &#x2F; Golang &#x2F; Web &#x2F; Developer &#x2F; Ham &#x2F; QTH GZ &#x2F; 折腾各种小玩意 想做一只小猫咪 &#x2F; 铲屎官 &#x2F; 地球猫猫教 INTJ-T &#x2F; 喜欢读书 &#x2F; 轻百控 &#x2F; 文氓 &#x2F; 喜欢民谣 &#x2F; 想去拉萨 &#x2F; 悲观的理想主义者 友跨🏳️‍⚧️ &#x2F; 重抑4年 &#x2F; 吃药治疗ing &#x2F; 内向 &#x2F; 摆烂 &#x2F; 社恐人 &#x2F; 割手手 &#x2F; 不时掉落负能 Languages🌏: 简中 &#x2F; 繁中 &#x2F; EN 人群太吵闹了，我要去有风的地方。 Catch Me GitHub WhaleFell Email: &#x77;&#x68;&#97;&#x6c;&#x65;&#x66;&#97;&#108;&#x6c;&#x39;&#x34;&#x32;&#x30;&#x40;&#x6f;&#117;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#x6f;&#109; "},{"title":"主题","date":"2024-08-23T18:42:35.963Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"Blog 大事记","date":"2018-12-11T07:51:48.000Z","url":"/event/index.html","categories":[[" ",""]],"content":"Blog 大事记2023&#x2F;12&#x2F;17将博客整体迁移到了 vercel 上,全面弃用七牛云的 OSS 图片储存,使用 OneDrive 作为图床,由自写的 API 程序作为中转,提供直链服务. Blog:  博客主域名，由 vercel 提供静态托管。  博客 永久域名,由 GitHub Pages 提供静态托管。（好处是域名不会过期，大概我死了也可以访问） API Gateway: [] 搭建在 vercel 的 API 服务，提供各种功能。 [] 搭建在 render.com，作为备份。数据、日志互通。 2023&#x2F;4&#x2F;11因为原域名 lskyl.xyz 到期了,故把博客域名和 oss 域名整体迁移到 whaleluo.top 取鲸（Whale 英）落（Luo 中）之意.其中带 www 前缀 www.whaleluo.top 经过 cloudflare 加速，用于某些不能直接访问到 github pages 的场景。同时搭建在 vercel /vɜː&#39;sel/ 上的 https:&#x2F;blog.whaleluo.top) 作为备份。 2023&#x2F;2&#x2F;102023&#x2F;2&#x2F;10 更换了更快的博客主题 Card Card.主题文档 2022&#x2F;12&#x2F;11重新拾起荒废已久的 Hexo 博客，就当是给自己的笔记、想法一个家。规范了博客的写作格式，方便索引和查找。"},{"date":"2024-08-23T18:42:35.963Z","url":"/friends/back.json","categories":[[" ",""]],"content":"{\"layout\":\"links\",\"title\":\"友链 | Friends Link\",\"links\":[{\"name\":\"zikin\",\"desc\":\"中学生 / 偶尔拍拍照片\",\"url\":\"\",\"avatar\":\"\"},{\"name\":\"沐の空间\",\"desc\":\"缘，妙不可言\",\"url\":\"\",\"avatar\":\"\"},{\"name\":\"冷曦云\",\"desc\":\"无法追溯的过去，让ta成为回忆\",\"url\":\"\",\"avatar\":\"\"},{\"name\":\"萌小志のBlog\",\"desc\":\"去你妈的现实\",\"url\":\"\",\"avatar\":\"\"},{\"name\":\"九弦之屋\",\"desc\":\"随着风和光来的旅行者，欢迎来到九弦之屋\",\"url\":\"\",\"avatar\":\"\"},{\"name\":\"安小歪 Blog\",\"desc\":\"记住你！自己！\",\"url\":\"\",\"avatar\":\"\"}]}"},{"title":"友链 | Friends Link","date":"2024-08-23T18:42:35.963Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"搜索","date":"2024-08-23T18:42:35.963Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"标签","date":"2024-08-23T18:42:35.963Z","url":"/tags/index.html","categories":[[" ",""]]}]