<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico"><title>TypeScript 快速入门☞北 | 😊落落のBlog😊</title><meta name="keywords" content="Vue, TypeScript, TS, Javascript, 编程,博客,记录,技术,生活,前端,摄影,LGBT,计算机,网络安全,Life,Cybersecurity,Python,Golang,Vue,Javascript,Java,Linux"><meta name="description" content="TypeScript 快速入门 ☞ 北因为在学习 Vue Framework 的过程中,碰到了很多 TypeScript 之类的知识和语法以及 Vue 源码也是通过 ts 写的,所以有必要去了解一下 TypeScript 这个语言语法. reference:  TypeScript 教程 | 菜鸟教程 最近发现一本好书:TypeScript 入门教程 阮一峰 ES6 入门教程:ES6 入门教程 2"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 快速入门☞北"><meta property="og:url" content="https://www.whaleluo.top/javascript/typescript-fast-start/index.html"><meta property="og:site_name" content="😊落落のBlog😊"><meta property="og:description" content="TypeScript 快速入门 ☞ 北因为在学习 Vue Framework 的过程中,碰到了很多 TypeScript 之类的知识和语法以及 Vue 源码也是通过 ts 写的,所以有必要去了解一下 TypeScript 这个语言语法. reference:  TypeScript 教程 | 菜鸟教程 最近发现一本好书:TypeScript 入门教程 阮一峰 ES6 入门教程:ES6 入门教程 2"><meta property="og:locale"><meta property="og:image" content="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start.png&webp=true"><meta property="og:image" content="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-1.png&webp=true"><meta property="og:image" content="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-2.png&webp=true"><meta property="og:image" content="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-3.png&webp=true"><meta property="article:published_time" content="2023-09-01T13:51:14.000Z"><meta property="article:modified_time" content="2023-09-01T13:51:14.000Z"><meta property="article:author" content="WhaleFall"><meta property="article:tag" content="Vue"><meta property="article:tag" content="TypeScript"><meta property="article:tag" content="TS"><meta property="article:tag" content="Javascript"><meta name="twitter:card" content="images&#x2F;favicon.ico"><meta name="twitter:image" content="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start.png&webp=true"><link rel="stylesheet" href="/css/style/main.css"><link rel="stylesheet" id="hl-default-theme" href="https://api.whaleluo.top/file/?url=https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/atom-one-light.css" media="none"><link rel="stylesheet" id="hl-dark-theme" href="https://api.whaleluo.top/file/?url=https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/atom-one-dark.css" media="none"><link rel="stylesheet" href="/css/style/dark.css"><script src="/js/darkmode.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="google-site-verification" content="bka9Mdyvo7g1v-jQq8CzqcaY9zE2QGltMwsvO63rAUw"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="😊落落のBlog😊" type="application/atom+xml"></head><body><div id="app" tabindex="-1"><header class="header"><div class="header__left"><a href="/" class="button"><span class="logo__text">落落のBlog</span></a></div><div class="header__right"><div class="navbar__menus"><a href="/" class="navbar-menu button">首页</a> <a href="/tags/" class="navbar-menu button">标签</a> <a href="/archives/" class="navbar-menu button">归档</a> <a href="/categories/" class="navbar-menu button">主题</a> <a href="/friends/" class="navbar-menu button">友链</a> <a href="/about/" class="navbar-menu button">关于</a> <a href="/event/" class="navbar-menu button">大事记</a> <a href="/atom.xml" class="navbar-menu button">RSS</a></div><a href="/search/" id="btn-search"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg> </a><a href="javaScript:void(0);" id="btn-toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> </a><a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="24" height="24" fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a><div class="dropdown-menus" id="dropdown-menus"><a href="/" class="dropdown-menu button">首页</a> <a href="/tags/" class="dropdown-menu button">标签</a> <a href="/archives/" class="dropdown-menu button">归档</a> <a href="/categories/" class="dropdown-menu button">主题</a> <a href="/friends/" class="dropdown-menu button">友链</a> <a href="/about/" class="dropdown-menu button">关于</a> <a href="/event/" class="dropdown-menu button">大事记</a> <a href="/atom.xml" class="dropdown-menu button">RSS</a></div></div></header><main class="main"><div class="post-title"><h1 class="post-title__text">TypeScript 快速入门☞北</h1><div class="post-title__meta"><a href="/archives/2023/09/" class="post-meta__date button">2023-09-01</a> <span class="separate-dot"></span><a href="/categories/JavaScript/" class="button">JavaScript</a> <span id="busuanzi_container_page_pv" hidden><span class="separate-dot"></span> <span></span> <span id="busuanzi_value_page_pv"></span> <span>Views</span></span></div></div><aside class="post-side"><div class="post-side__toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#INSTALL"><span class="toc-number">1.</span> <span class="toc-text">INSTALL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">数据类型的层级关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E5%92%8C-object"><span class="toc-number">2.2.</span> <span class="toc-text">Object 和 object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B-array"><span class="toc-number">2.3.</span> <span class="toc-text">数组类型 array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B-tuple"><span class="toc-number">2.4.</span> <span class="toc-text">元组类型 tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enumerate"><span class="toc-number">2.5.</span> <span class="toc-text">枚举类型 enumerate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.6.</span> <span class="toc-text">类型推断和类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Never-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">Never 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">Symbol 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.9.</span> <span class="toc-text">联合类型 类型断言 交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TS-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.10.</span> <span class="toc-text">TS 内置对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">Function 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">Interface 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">5.1.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">Interface 接口定义函数类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">Class 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">类实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Vue-Virtual-Dom-%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">6.2.</span> <span class="toc-text">实现一个 Vue Virtual Dom 虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84-getter-%E5%92%8C-setter"><span class="toc-number">6.3.</span> <span class="toc-text">类的 getter 和 setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E5%9F%BA%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">抽象类 基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialization-Order-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">Initialization Order 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-confusing-this-%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84-this"><span class="toc-number">6.6.</span> <span class="toc-text">The confusing this (容易混淆的 this)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Explicitly-Declared-this-parameters-%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E-class-%E4%B8%AD%E7%9A%84-this"><span class="toc-number">6.7.</span> <span class="toc-text">Explicitly Declared this parameters 显式声明 class 中的 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor-Signature-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">6.8.</span> <span class="toc-text">Constructor Signature 构造函数签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dock-Typing-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">Dock Typing 鸭子类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">8.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">Module 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">生成器 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-generic"><span class="toc-number">11.</span> <span class="toc-text">泛型 generic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">11.1.</span> <span class="toc-text">泛型约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tsconfig-json-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">tsconfig.json 配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Namespace-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">13.</span> <span class="toc-text">Namespace 命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4"><span class="toc-number">14.</span> <span class="toc-text">三斜线指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6-declare-d-ts"><span class="toc-number">15.</span> <span class="toc-text">声明文件 declare d.ts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mixins-%E6%B7%B7%E5%85%A5"><span class="toc-number">16.</span> <span class="toc-text">Mixins 混入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E6%B7%B7%E5%85%A5"><span class="toc-number">16.1.</span> <span class="toc-text">Object 混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E7%B1%BB%E7%9A%84%E6%B7%B7%E5%85%A5"><span class="toc-number">16.2.</span> <span class="toc-text">Class 类的混入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E5%8E%9F%E5%9E%8B%E9%93%BE-JS-prototype-chain"><span class="toc-number">17.</span> <span class="toc-text">JS 原型链 (JS prototype chain)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">17.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype-Attribute"><span class="toc-number">17.2.</span> <span class="toc-text">prototype Attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto-Attribute"><span class="toc-number">17.3.</span> <span class="toc-text">__proto__ Attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">17.4.</span> <span class="toc-text">Constructor 构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">17.5.</span> <span class="toc-text">原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90Experiment%E3%80%91%E8%A3%85%E9%A5%B0%E5%99%A8-Decorator"><span class="toc-number">18.</span> <span class="toc-text">【Experiment】装饰器 Decorator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-decorator"><span class="toc-number">18.1.</span> <span class="toc-text">Class decorator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-decorator-%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">18.2.</span> <span class="toc-text">Method decorator 方法装饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Rollup-%E6%9E%84%E5%BB%BA-TS-%E9%A1%B9%E7%9B%AE"><span class="toc-number">19.</span> <span class="toc-text">通过 Rollup 构建 TS 项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.</span> <span class="toc-text">TS 实现发布订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E6%96%B0%E7%B1%BB%E5%9E%8B-weakMap-weakSet-set-map"><span class="toc-number">21.</span> <span class="toc-text">ES6 新类型 weakMap weakSet set map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">21.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">21.2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet-WeakMap"><span class="toc-number">21.3.</span> <span class="toc-text">WeakSet WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">Function 函数的二义性 箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-Arrow-Function"><span class="toc-number">22.1.</span> <span class="toc-text">箭头函数 Arrow Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E8%BF%9B%E9%98%B6%E4%BB%A3%E7%90%86-%E5%8F%8D%E5%B0%84-proxy-Reflect"><span class="toc-number">23.</span> <span class="toc-text">TS 进阶代理&amp;反射 proxy &amp; Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect"><span class="toc-number">23.1.</span> <span class="toc-text">Reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-mobx-observer-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.2.</span> <span class="toc-text">实现 mobx observer 观察者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Guards-%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">24.</span> <span class="toc-text">Type Guards 类型守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Typeof-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%BC%A9"><span class="toc-number">24.1.</span> <span class="toc-text">Typeof 类型收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instanceof"><span class="toc-number">24.2.</span> <span class="toc-text">Instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Guard-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%88%E5%8D%AB"><span class="toc-number">24.3.</span> <span class="toc-text">Custom Guard 自定义守卫</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-compatible-k%C9%99m%CB%88paet%C9%99bl-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9"><span class="toc-number">25.</span> <span class="toc-text">Type compatible[&#x2F;kəmˈpætəbl&#x2F;] 类型兼容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%8B%E5%8F%98-%E5%8D%8F%E5%8F%98-%E9%80%86%E5%8F%98-Duck-Type-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.1.</span> <span class="toc-text">型变 (协变&#x2F;逆变) &amp; Duck Type 鸭子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98"><span class="toc-number">25.2.</span> <span class="toc-text">逆变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E6%B3%9B%E5%9E%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">26.</span> <span class="toc-text">TS 泛型工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-adj-%E5%B1%80%E9%83%A8%E7%9A%84-%E5%92%8C-Required-adj-%E5%BF%85%E9%A1%BB%E7%9A%84"><span class="toc-number">26.1.</span> <span class="toc-text">Partial(adj. 局部的) 和 Required(adj. 必须的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pick-%E9%80%89%E5%8F%96-%E5%92%8C-Exclude-%E6%8E%92%E9%99%A4"><span class="toc-number">26.2.</span> <span class="toc-text">Pick(选取) 和 Exclude(排除)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Omit"><span class="toc-number">26.3.</span> <span class="toc-text">Omit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Record"><span class="toc-number">26.4.</span> <span class="toc-text">Record</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReturnType"><span class="toc-number">26.5.</span> <span class="toc-text">ReturnType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D"><span class="toc-number">27.</span> <span class="toc-text">类型体操</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extands-%E6%89%A9%E5%B1%95"><span class="toc-number">27.1.</span> <span class="toc-text">Extands (扩展)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Infer-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">27.2.</span> <span class="toc-text">Infer 类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">27.3.</span> <span class="toc-text">类型条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never-%E4%BB%8E%E4%B8%8D-unknown-%E6%9C%AA%E7%9F%A5-any-%E4%BB%BB%E6%84%8F-%E5%AF%B9%E5%AF%B9%E7%A2%B0"><span class="toc-number">27.4.</span> <span class="toc-text">never(从不) unknown(未知) any(任意) 对对碰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B-Map-Type"><span class="toc-number">27.5.</span> <span class="toc-text">映射类型 (Map Type)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8F%96-Type-Extraction"><span class="toc-number">27.6.</span> <span class="toc-text">类型提取 (Type Extraction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86-recursion-processing"><span class="toc-number">27.7.</span> <span class="toc-text">递归处理 (recursion processing)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#End"><span class="toc-number">28.</span> <span class="toc-text">End</span></a></li></ol></div></aside><a class="btn-toc button" id="btn-toc" tabindex="0"><svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg"><path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path></svg></a><div class="toc-menus" id="toc-menus"><div class="toc-title">Article Directory</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#INSTALL"><span class="toc-number">1.</span> <span class="toc-text">INSTALL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">数据类型的层级关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E5%92%8C-object"><span class="toc-number">2.2.</span> <span class="toc-text">Object 和 object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B-array"><span class="toc-number">2.3.</span> <span class="toc-text">数组类型 array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B-tuple"><span class="toc-number">2.4.</span> <span class="toc-text">元组类型 tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enumerate"><span class="toc-number">2.5.</span> <span class="toc-text">枚举类型 enumerate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.6.</span> <span class="toc-text">类型推断和类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Never-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">Never 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">Symbol 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.9.</span> <span class="toc-text">联合类型 类型断言 交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TS-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.10.</span> <span class="toc-text">TS 内置对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">Function 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interface-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">Interface 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">5.1.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">Interface 接口定义函数类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">Class 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">类实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Vue-Virtual-Dom-%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">6.2.</span> <span class="toc-text">实现一个 Vue Virtual Dom 虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84-getter-%E5%92%8C-setter"><span class="toc-number">6.3.</span> <span class="toc-text">类的 getter 和 setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E5%9F%BA%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">抽象类 基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialization-Order-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">Initialization Order 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-confusing-this-%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84-this"><span class="toc-number">6.6.</span> <span class="toc-text">The confusing this (容易混淆的 this)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Explicitly-Declared-this-parameters-%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E-class-%E4%B8%AD%E7%9A%84-this"><span class="toc-number">6.7.</span> <span class="toc-text">Explicitly Declared this parameters 显式声明 class 中的 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor-Signature-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">6.8.</span> <span class="toc-text">Constructor Signature 构造函数签名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dock-Typing-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">Dock Typing 鸭子类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">8.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">Module 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">生成器 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-generic"><span class="toc-number">11.</span> <span class="toc-text">泛型 generic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">11.1.</span> <span class="toc-text">泛型约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tsconfig-json-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">tsconfig.json 配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Namespace-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">13.</span> <span class="toc-text">Namespace 命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4"><span class="toc-number">14.</span> <span class="toc-text">三斜线指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6-declare-d-ts"><span class="toc-number">15.</span> <span class="toc-text">声明文件 declare d.ts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mixins-%E6%B7%B7%E5%85%A5"><span class="toc-number">16.</span> <span class="toc-text">Mixins 混入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E6%B7%B7%E5%85%A5"><span class="toc-number">16.1.</span> <span class="toc-text">Object 混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E7%B1%BB%E7%9A%84%E6%B7%B7%E5%85%A5"><span class="toc-number">16.2.</span> <span class="toc-text">Class 类的混入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E5%8E%9F%E5%9E%8B%E9%93%BE-JS-prototype-chain"><span class="toc-number">17.</span> <span class="toc-text">JS 原型链 (JS prototype chain)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">17.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype-Attribute"><span class="toc-number">17.2.</span> <span class="toc-text">prototype Attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto-Attribute"><span class="toc-number">17.3.</span> <span class="toc-text">__proto__ Attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">17.4.</span> <span class="toc-text">Constructor 构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">17.5.</span> <span class="toc-text">原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90Experiment%E3%80%91%E8%A3%85%E9%A5%B0%E5%99%A8-Decorator"><span class="toc-number">18.</span> <span class="toc-text">【Experiment】装饰器 Decorator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-decorator"><span class="toc-number">18.1.</span> <span class="toc-text">Class decorator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-decorator-%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">18.2.</span> <span class="toc-text">Method decorator 方法装饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Rollup-%E6%9E%84%E5%BB%BA-TS-%E9%A1%B9%E7%9B%AE"><span class="toc-number">19.</span> <span class="toc-text">通过 Rollup 构建 TS 项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.</span> <span class="toc-text">TS 实现发布订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E6%96%B0%E7%B1%BB%E5%9E%8B-weakMap-weakSet-set-map"><span class="toc-number">21.</span> <span class="toc-text">ES6 新类型 weakMap weakSet set map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">21.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">21.2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet-WeakMap"><span class="toc-number">21.3.</span> <span class="toc-text">WeakSet WeakMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">Function 函数的二义性 箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-Arrow-Function"><span class="toc-number">22.1.</span> <span class="toc-text">箭头函数 Arrow Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E8%BF%9B%E9%98%B6%E4%BB%A3%E7%90%86-%E5%8F%8D%E5%B0%84-proxy-Reflect"><span class="toc-number">23.</span> <span class="toc-text">TS 进阶代理&amp;反射 proxy &amp; Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect"><span class="toc-number">23.1.</span> <span class="toc-text">Reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-mobx-observer-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.2.</span> <span class="toc-text">实现 mobx observer 观察者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Guards-%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">24.</span> <span class="toc-text">Type Guards 类型守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Typeof-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%BC%A9"><span class="toc-number">24.1.</span> <span class="toc-text">Typeof 类型收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instanceof"><span class="toc-number">24.2.</span> <span class="toc-text">Instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Guard-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%88%E5%8D%AB"><span class="toc-number">24.3.</span> <span class="toc-text">Custom Guard 自定义守卫</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-compatible-k%C9%99m%CB%88paet%C9%99bl-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9"><span class="toc-number">25.</span> <span class="toc-text">Type compatible[&#x2F;kəmˈpætəbl&#x2F;] 类型兼容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%8B%E5%8F%98-%E5%8D%8F%E5%8F%98-%E9%80%86%E5%8F%98-Duck-Type-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.1.</span> <span class="toc-text">型变 (协变&#x2F;逆变) &amp; Duck Type 鸭子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98"><span class="toc-number">25.2.</span> <span class="toc-text">逆变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-%E6%B3%9B%E5%9E%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">26.</span> <span class="toc-text">TS 泛型工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-adj-%E5%B1%80%E9%83%A8%E7%9A%84-%E5%92%8C-Required-adj-%E5%BF%85%E9%A1%BB%E7%9A%84"><span class="toc-number">26.1.</span> <span class="toc-text">Partial(adj. 局部的) 和 Required(adj. 必须的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pick-%E9%80%89%E5%8F%96-%E5%92%8C-Exclude-%E6%8E%92%E9%99%A4"><span class="toc-number">26.2.</span> <span class="toc-text">Pick(选取) 和 Exclude(排除)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Omit"><span class="toc-number">26.3.</span> <span class="toc-text">Omit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Record"><span class="toc-number">26.4.</span> <span class="toc-text">Record</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReturnType"><span class="toc-number">26.5.</span> <span class="toc-text">ReturnType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D"><span class="toc-number">27.</span> <span class="toc-text">类型体操</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extands-%E6%89%A9%E5%B1%95"><span class="toc-number">27.1.</span> <span class="toc-text">Extands (扩展)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Infer-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">27.2.</span> <span class="toc-text">Infer 类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">27.3.</span> <span class="toc-text">类型条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never-%E4%BB%8E%E4%B8%8D-unknown-%E6%9C%AA%E7%9F%A5-any-%E4%BB%BB%E6%84%8F-%E5%AF%B9%E5%AF%B9%E7%A2%B0"><span class="toc-number">27.4.</span> <span class="toc-text">never(从不) unknown(未知) any(任意) 对对碰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B-Map-Type"><span class="toc-number">27.5.</span> <span class="toc-text">映射类型 (Map Type)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8F%96-Type-Extraction"><span class="toc-number">27.6.</span> <span class="toc-text">类型提取 (Type Extraction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86-recursion-processing"><span class="toc-number">27.7.</span> <span class="toc-text">递归处理 (recursion processing)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#End"><span class="toc-number">28.</span> <span class="toc-text">End</span></a></li></ol></div><article class="post post__with-toc content-card"><div class="post__header"><div class="post__expire" id="post-expired-notify"><p>This article was last updated on &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; days ago, the information described in the article may be outdated.</p></div><script>(() => {
            var update = Date.parse("2023-09-01"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();</script></div><div class="post__content"><h1 id="TypeScript-快速入门-☞-北"><a href="#TypeScript-快速入门-☞-北" class="headerlink" title="TypeScript 快速入门 ☞ 北"></a>TypeScript 快速入门 ☞ 北</h1><p>因为在学习 Vue Framework 的过程中,碰到了很多 TypeScript 之类的知识和语法以及 Vue 源码也是通过 ts 写的,所以有必要去了解一下 TypeScript 这个语言语法.</p><p>reference:</p><ol><li><a target="_blank" rel="noopener" href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程</a></li><li>最近发现一本好书:<a target="_blank" rel="noopener" href="http://ts.xcatliu.com/">TypeScript 入门教程</a></li><li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/">阮一峰</a> ES6 入门教程:<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class">ES6 入门教程</a></li><li>2024&#x2F;1&#x2F;21 更:最近又发现一个宝藏 up 主的视频 <strong>小满 zc</strong>:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wR4y1377K">小满 zc 自残 TypeScript 基础教程全集(完结)</a></li></ol><hr><ol><li>TypeScript &#x3D;&#x3D;&gt; JavaScript 的一个 <strong>超集</strong>,支持 ECMAScript 6 标准</li><li>TypeScript 由 <strong>微软</strong> 爸爸开发.</li><li>TypeScript 设计目标是开发大型应用,它可以 <strong>编译成纯 JavaScript</strong>,编译出来的 JavaScript 可以运行在任何浏览器上.</li></ol><p>TypeScript 是一种给 JavaScript 添加特性的语言扩展,他主要添加了 对 JS <strong>类型</strong> 的支持 ,相当于 Python 的 <code>function hint</code> (函数暗示) <code>Pydantic BaseModel</code>、<code>typing</code> 等给弱类型的动态语言 <strong>提供类型支持</strong>.</p><h2 id="INSTALL"><a href="#INSTALL" class="headerlink" title="INSTALL"></a>INSTALL</h2><p>TS 基于 NodeJS</p><pre><code class="hljs shell">npm config set registry https://registry.npmmirror.com # 换 npm 源
npm install -g typescript

tsc -v # 查看 version</code></pre><p>编写 main.ts</p><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Hello World&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)</code></pre><p>然后执行以下命令将 TypeScript 转换为 JavaScript 代码:</p><pre><code class="hljs shell">tsc main.ts
node main.js # 执行编译完成的 JS 文件</code></pre><p>TypeScript &#x3D;&#x3D;&gt; TypeScript Compiler &#x3D;&#x3D;&gt; JavaScript</p><p>安装 <code>ts-node</code> 可以直接运行 ts 文件</p><pre><code class="hljs shell">npm install ts-node -g
ts-node index.ts</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">anywhere</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span> <span class="hljs-comment">// any 任何类型</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">decLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span> <span class="hljs-comment">// 数字类型</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Runoob&quot;</span> <span class="hljs-comment">// 字符串</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 布尔</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">array</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">// 数组</span>
<span class="hljs-comment">// 元组</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]
x = [<span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-number">1</span>]

<span class="hljs-comment">// enumerate 枚举</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;
  <span class="hljs-title class_">Red</span>,
  <span class="hljs-title class_">Green</span>,
  <span class="hljs-title class_">Blue</span>
&#125;
<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c) <span class="hljs-comment">// 输出 2</span>

<span class="hljs-comment">// void 空的 用于标记方法返回值的类型,表示没有返回值</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello Runoob&quot;</span>)
&#125;
<span class="hljs-comment">// never 是其它类型(包括 null 和 undefined)的子类型,代表从不会出现的值.</span>
<span class="hljs-comment">// 函数中它通常表现为抛出异常或无法执行到终止点 例如无限循环</span>
<span class="hljs-built_in">never</span>
<span class="hljs-comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;
&#125;

<span class="hljs-comment">// 可以用 | 来支持多种类型</span>
<span class="hljs-comment">// 启用 --strictNullChecks</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>
x = <span class="hljs-number">1</span> <span class="hljs-comment">// 编译正确</span>
x = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 编译正确</span>
x = <span class="hljs-literal">null</span> <span class="hljs-comment">// 编译正确</span></code></pre><h3 id="数据类型的层级关系"><a href="#数据类型的层级关系" class="headerlink" title="数据类型的层级关系"></a>数据类型的层级关系</h3><ol><li>顶级类型 (top type) :any unknown (<strong>unknown 只能赋值给自身或者 Any 且如果赋值给对象不能读取其 attr</strong>)</li><li>Object 所有对象的基类</li><li>Number String Boolean 对象</li><li>number string boolean (instantiation object 实例化对象)</li></ol><p><img src="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start.png&webp=true" class="lazy" data-srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start.png&webp=true" srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/loading.gif"></p><h3 id="Object-和-object"><a href="#Object-和-object" class="headerlink" title="Object 和 object"></a>Object 和 object</h3><p>object 表示引用类型,常用于<strong>泛型约束</strong>.</p><pre><code class="hljs javascript"><span class="hljs-comment">// Object 是 TS 中的基类,任何类型都可以是一个 Object 常常用于泛型约束</span>
<span class="hljs-attr">a</span>: <span class="hljs-title class_">Object</span> = <span class="hljs-string">&quot;123&quot;</span>
<span class="hljs-attr">a</span>: <span class="hljs-title class_">Object</span> = &#123;<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-string">&quot;12&quot;</span>&#125;
<span class="hljs-comment">// 也可以用 &#123;&#125; 空对象表示</span>
<span class="hljs-attr">a</span>: &#123;&#125; = <span class="hljs-string">&quot;123&quot;</span>
<span class="hljs-comment">// &#123;&#125; 类型不可更改,少用为好</span>

<span class="hljs-comment">// object 只能用于引用类型不能用于原始类型</span>
<span class="hljs-attr">a</span>: object = <span class="hljs-string">&quot;2121&quot;</span> <span class="hljs-comment">// error:string not reference object</span>
<span class="hljs-attr">a</span>: object = [<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-comment">// correct list is reference object</span></code></pre><h3 id="数组类型-array"><a href="#数组类型-array" class="headerlink" title="数组类型 array"></a>数组类型 array</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-comment">// 使用泛型约束</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">array</span>: <span class="hljs-title class_">Array</span>&lt;boolean&gt; = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]
<span class="hljs-comment">// 定义多维数组</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: number[][] = [[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]]
<span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Array</span>&lt;number&gt;&gt; = [[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]]

<span class="hljs-comment">// es6 多参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">mutil</span>(<span class="hljs-params">...args: any[]</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)
&#125;</code></pre><p>在函数内部有一个特殊的 value —— <strong>arguments</strong>,用于记录传入参数的列表,但不是一个常规的 array 类型.</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">...args</span>)&#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)
 <span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">IArguments</span> = <span class="hljs-variable language_">arguments</span>
&#125;
<span class="hljs-comment">// arguments 其实是一个 object 内部实现了这样一个 interface:</span>

interface <span class="hljs-title class_">Arguments</span> &#123;
 <span class="hljs-attr">callee</span>: <span class="hljs-title class_">Function</span>
 <span class="hljs-attr">length</span>: number
 [<span class="hljs-attr">index</span>:number]: any
&#125;
</code></pre><h3 id="元组类型-tuple"><a href="#元组类型-tuple" class="headerlink" title="元组类型 tuple"></a>元组类型 tuple</h3><p>元组(tuple) 是固定数量的不同类型的元素组合.</p><p>元组和数组的不同之处,元组中的 <strong>元素类型是可以不同的,且数量固定</strong>.元组的好处在于可以把 <strong>多个元素作为一个单元传递</strong>.如果一个 function 需要返回多个值,可以把这多个值作为元组返回,而不需要创建额外的类来表示.</p><pre><code class="hljs typescript"><span class="hljs-comment">// 元组</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span>]

arr[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>
<span class="hljs-keyword">const</span> lst = arr[<span class="hljs-number">2</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>)

<span class="hljs-comment">// 使用 readonly 修饰符,可以将元组中的元素设置为只读</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">arrReadonly</span>: <span class="hljs-keyword">readonly</span> [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">string</span>] = [<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;str&quot;</span>]

<span class="hljs-keyword">let</span> <span class="hljs-attr">xyz</span>: <span class="hljs-keyword">readonly</span> [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

<span class="hljs-keyword">let</span> <span class="hljs-attr">excel</span>: [<span class="hljs-attr">no</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>][] = [
  [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">20</span>]
]

<span class="hljs-keyword">type</span> first = (<span class="hljs-keyword">typeof</span> excel)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]</code></pre><h3 id="枚举类型-enumerate"><a href="#枚举类型-enumerate" class="headerlink" title="枚举类型 enumerate"></a>枚举类型 enumerate</h3><pre><code class="hljs typescript"><span class="hljs-comment">// enumeration 枚举类型</span>
<span class="hljs-comment">// auto increment 自增序列枚举</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;
  <span class="hljs-title class_">Red</span> = <span class="hljs-number">0</span>,
  <span class="hljs-title class_">Green</span> = <span class="hljs-number">1</span>,
  <span class="hljs-title class_">Blue</span> = <span class="hljs-number">2</span>
&#125;

<span class="hljs-comment">// enum Color &#123;</span>
<span class="hljs-comment">//     DarkRed = &quot;DarkRed&quot;,</span>
<span class="hljs-comment">//     DarkGreen = &quot;DarkGreen&quot;,</span>
<span class="hljs-comment">//     DarkBlue = &quot;DarkBlue&quot;,</span>
<span class="hljs-comment">// &#125;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Color.Red&quot;</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>)

<span class="hljs-comment">// enum 反射 only support number</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">red</span>: <span class="hljs-built_in">number</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>
<span class="hljs-keyword">let</span> key = <span class="hljs-title class_">Color</span>[red]
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`key: <span class="hljs-subst">$&#123;key&#125;</span> value: <span class="hljs-subst">$&#123;red&#125;</span>`</span>)</code></pre><h3 id="类型推断和类型别名"><a href="#类型推断和类型别名" class="headerlink" title="类型推断和类型别名"></a>类型推断和类型别名</h3><p>TS 在定义变量的时候天然支持推导其类型,如果不确定的话,会被推断成 <code>Any</code>.</p><pre><code class="hljs typescript"><span class="hljs-comment">// 类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">WFtype</span> = <span class="hljs-built_in">number</span>[] | <span class="hljs-built_in">string</span>[]

<span class="hljs-comment">// extends 继承 左边的值会作为右边的子类型</span>
<span class="hljs-keyword">type</span> num = <span class="hljs-number">1</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span></code></pre><h3 id="Never-类型"><a href="#Never-类型" class="headerlink" title="Never 类型"></a>Never 类型</h3><p>never 类型来表示不应该存在的状态.<strong>表示永远不能达到</strong>:</p><p>never 是最底层的类型,</p><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>): nerver &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;error&quot;</span>)
&#125;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;diediedie&quot;</span>)
  &#125;
&#125;</code></pre><p>never 用于 switch 兜底的场景:</p><pre><code class="hljs typescript"><span class="hljs-comment">// never 用于 switch 兜底的场景</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-string">&quot;sing&quot;</span> | <span class="hljs-string">&quot;dance&quot;</span> | <span class="hljs-string">&quot;rap&quot;</span> | <span class="hljs-string">&quot;basketball&quot;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ikun</span>(<span class="hljs-params">value: A</span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">never</span> &#123;
  <span class="hljs-keyword">switch</span> (value) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sing&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;唱歌&quot;</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;dance&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;跳舞&quot;</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;rap&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;rap&quot;</span>
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">const</span> <span class="hljs-attr">check</span>: <span class="hljs-built_in">never</span> = value <span class="hljs-comment">// 不能将类型&quot;string&quot;分配给类型&quot;never&quot;.</span>
      <span class="hljs-keyword">return</span> check
  &#125;
&#125;</code></pre><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>象征、标志,是 es5 新增的一个数据类型.</p><p>应用:在一个对象中,key 值如果相同,就会被覆盖.如果 key 是一个 Symbol(name) 则 name 相同也不会覆盖.</p><pre><code class="hljs typescript"><span class="hljs-comment">// symbol 应用</span>
<span class="hljs-keyword">let</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;WF&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
  <span class="hljs-comment">// [age]: 27, 相同的 key 会覆盖</span>
  [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;age&quot;</span>)]: <span class="hljs-number">27</span> <span class="hljs-comment">// 不能被覆盖</span>
&#125;

<span class="hljs-comment">// for in 不能遍历到 symbol</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)
&#125;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) <span class="hljs-comment">// 也不能遍历到 symbol</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj) <span class="hljs-comment">// 也不能遍历到 symbol</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj) <span class="hljs-comment">// 只可以遍历到 symbol</span>
<span class="hljs-comment">// es6 新增的方法反射 Reflect.ownKeys(obj) 可以遍历到 symbol</span>
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)</code></pre><h3 id="联合类型-类型断言-交叉类型"><a href="#联合类型-类型断言-交叉类型" class="headerlink" title="联合类型 类型断言 交叉类型"></a>联合类型 类型断言 交叉类型</h3><p>联合类型</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">phone</span>: number | string = <span class="hljs-string">&#x27;020-12123&#x27;</span>

<span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params">type: number | boolean</span>): boolean &#123;
  <span class="hljs-keyword">return</span> !!type <span class="hljs-comment">// 将类型强行转成 boolean 类型,比如 0=&gt;false 1=&gt;true</span>
&#125;</code></pre><p>交叉类型</p><pre><code class="hljs javascript">interface <span class="hljs-title class_">Pople</span> &#123;
 <span class="hljs-attr">name</span>: string
 <span class="hljs-attr">age</span>: number
&#125;

<span class="hljs-comment">// Man 继承自 Pople</span>
interface <span class="hljs-title class_">Man</span> extands <span class="hljs-title class_">Pople</span> &#123;
 <span class="hljs-attr">sex</span>: number | string
&#125;

<span class="hljs-comment">// 使用 &amp;</span>
<span class="hljs-keyword">const</span> wf = (<span class="hljs-attr">man</span>: <span class="hljs-title class_">Pople</span> &amp; <span class="hljs-title class_">Man</span>):<span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(man);
&#125;

<span class="hljs-title function_">wf</span>(&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;hyy&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;famale&quot;</span>&#125;)</code></pre><p><strong>类型断言</strong>:在联合类型的参数中,用 as 指明是哪个类型.类型断言只能欺骗 ts 的 <strong>静态类型检查</strong>,以编译成功,但无法规避运行时的类型错误.</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params">num: number | string</span>):<span class="hljs-keyword">void</span> &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((num <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>)
 <span class="hljs-comment">// another way...</span>
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&lt;string&gt;num.<span class="hljs-property">length</span>)
&#125;
<span class="hljs-title function_">fn</span>(<span class="hljs-string">&quot;1234&quot;</span>)

<span class="hljs-comment">// 任何东西都可以断言成 any 类型</span>
(windows <span class="hljs-keyword">as</span> any).<span class="hljs-property">adc</span> = <span class="hljs-number">123</span></code></pre><h3 id="TS-内置对象"><a href="#TS-内置对象" class="headerlink" title="TS 内置对象"></a>TS 内置对象</h3><p>JavaScript 中有很多内置对象,它们可以直接在 TypeScript 中当作定义好的类型.</p><pre><code class="hljs javascript"><span class="hljs-comment">// new 实例化一个对象,返回的值的类型就是这个对象</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-title class_">Number</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> <span class="hljs-attr">xhr</span>: <span class="hljs-title class_">XMLHttpRequest</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()

<span class="hljs-comment">// HTML(Input)Element</span>
<span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;footer&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>
<span class="hljs-comment">// 选择的 HTML dom 元素不确定时</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">div</span>: <span class="hljs-title class_">NodeListOf</span>&lt;<span class="hljs-title class_">HTMLDivElement</span> | <span class="hljs-title class_">HTMLElement</span>&gt; =  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorALL</span>(<span class="hljs-string">&#x27;div&#x27;</span>)

<span class="hljs-comment">// browser 里面的类型</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">local</span>: <span class="hljs-title class_">Storage</span> = <span class="hljs-variable language_">localStorage</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">lo</span>:<span class="hljs-title class_">Location</span> = location
<span class="hljs-keyword">let</span> <span class="hljs-attr">promise</span>:<span class="hljs-title class_">Promise</span>&lt;string&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> <span class="hljs-title function_">r</span>(<span class="hljs-string">&quot;WF&quot;</span>))
promise.<span class="hljs-title function_">than</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;
 res.<span class="hljs-title function_">replace</span>()
&#125;)

<span class="hljs-comment">// Math 数学运算 Math.random() 生成 0-1 的随机数</span>
<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>( (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">100</span>) / screen.<span class="hljs-property">width</span>)</code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>TypeScript 还支持 for…of 、forEach、every 和 some 循环.</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> someArray = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">false</span>]

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> someArray) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry) <span class="hljs-comment">// 1, &quot;string&quot;, false</span>
&#125;

<span class="hljs-keyword">let</span> list = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx, array</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// val: 当前值</span>
  <span class="hljs-comment">// idx:当前index</span>
  <span class="hljs-comment">// array: Array</span>
&#125;)

<span class="hljs-keyword">let</span> list = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
list.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">val, idx, array</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// val: 当前值</span>
  <span class="hljs-comment">// idx:当前index</span>
  <span class="hljs-comment">// array: Array</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// Continues</span>
  <span class="hljs-comment">// Return false will quit the iteration</span>
&#125;)</code></pre><h2 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function 函数"></a>Function 函数</h2><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">function_name</span>(<span class="hljs-params"></span>): return_type &#123;
  <span class="hljs-comment">// 语句</span>
  <span class="hljs-keyword">return</span> value
&#125;

<span class="hljs-comment">// 带参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;
  <span class="hljs-keyword">return</span> x + y
&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))

<span class="hljs-comment">// parameter? 可选参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) &#123;
  <span class="hljs-keyword">if</span> (lastName) <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + lastName
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> firstName
&#125;

<span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>) <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>, <span class="hljs-string">&quot;Sr.&quot;</span>) <span class="hljs-comment">// 错误,参数太多了</span>
<span class="hljs-keyword">let</span> result3 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>) <span class="hljs-comment">// 正确</span>

<span class="hljs-comment">// set default parameter</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate_discount</span>(<span class="hljs-params">price: <span class="hljs-built_in">number</span>, rate: <span class="hljs-built_in">number</span> = <span class="hljs-number">0.5</span></span>) &#123;
  <span class="hljs-keyword">var</span> discount = price * rate
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;计算结果: &quot;</span>, discount)
&#125;
<span class="hljs-title function_">calculate_discount</span>(<span class="hljs-number">1000</span>)
<span class="hljs-title function_">calculate_discount</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">0.3</span>)

<span class="hljs-comment">// 剩余参数 ...parameter 得到一个参数 list Array</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, ...restOfName: <span class="hljs-built_in">string</span>[]</span>) &#123;
  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + restOfName.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>)
&#125;

<span class="hljs-keyword">let</span> employeeName = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Joseph&quot;</span>, <span class="hljs-string">&quot;Samuel&quot;</span>, <span class="hljs-string">&quot;Lucas&quot;</span>, <span class="hljs-string">&quot;MacKinzie&quot;</span>)

<span class="hljs-comment">// Lambda 函数 箭头函数</span>
<span class="hljs-keyword">var</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) =&gt; <span class="hljs-number">10</span> + x
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-number">100</span>)) <span class="hljs-comment">//输出结果为 110</span></code></pre><p><strong>ts 可以定义 object 内 this 的类型</strong>,但在 origin JS 中无法使用,必须是 method 的第一个参数定义 this 的类型,传参时不用传 this ,和 Python 中 class 的 self 一样.</p><pre><code class="hljs javascript">interface <span class="hljs-title class_">Obj</span>&#123;
 <span class="hljs-attr">user</span>: number[]
 <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Obj, num: number</span>) =&gt;</span> <span class="hljs-keyword">void</span>
&#125;

<span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Obj</span> = &#123;
 <span class="hljs-attr">user</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
 <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: Obj, num: number</span>) &#123;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-title function_">push</span>(num)
 &#125;
&#125;</code></pre><p><strong>函数重载</strong>:重载函数传入和返回的数据类型,在<strong>实现函数</strong>内部判断所属的类型进行操作</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>:<span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

<span class="hljs-keyword">function</span> <span class="hljs-title function_">findNum</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">number</span>[] <span class="hljs-comment">// 如果没有传入东西就是全部</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findNum</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] <span class="hljs-comment">// 如果传入了 id 就是单个查询</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findNum</span>(<span class="hljs-params">ids?:<span class="hljs-built_in">number</span> | <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] &#123;
 <span class="hljs-comment">// 实现函数</span>
 <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ids == <span class="hljs-string">&#x27;number&#x27;</span>)&#123; <span class="hljs-comment">// 判断传入了一个 id</span>
  <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v == ids) <span class="hljs-comment">// array filter 返回符合 true 的数组</span>
 &#125; eles <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(ids)) &#123; <span class="hljs-comment">// 判断传入了一个 array</span>
  user.<span class="hljs-title function_">push</span>(...ids)
  <span class="hljs-keyword">return</span> user
 &#125; eles &#123; <span class="hljs-comment">// 判断什么都没传入</span>
  <span class="hljs-keyword">return</span> user
 &#125;
&#125;</code></pre><h2 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h2><p>对象实现接口.类是对象的构造器.</p><p>与 Golang 接口的概念一样,接口是 <strong>method</strong> 和 <strong>attribute</strong> 的集合,需要有对应的类去实现,如果类实现了接口中的所有 methods 就可以说这个类实现了这个接口.</p><p><strong>interface 接口来实现一种约束</strong>,让 对象&#x2F;类 的结构满足约束的格式.</p><p>interface 接口命名 <strong>第一个字母要大写</strong>.</p><p>遇到重名 interface 时,会自动进行合并.</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">sayHi</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>
&#125;

<span class="hljs-comment">// customer 类实现了 IPerson 接口</span>
<span class="hljs-keyword">var</span> <span class="hljs-attr">customer</span>: <span class="hljs-title class_">IPerson</span> = &#123;
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Tom&quot;</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Hanks&quot;</span>,
  <span class="hljs-attr">sayHi</span>: (): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hi there&quot;</span>
  &#125;
&#125;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Customer 对象 &quot;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(customer.<span class="hljs-property">firstName</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(customer.<span class="hljs-property">lastName</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(customer.<span class="hljs-title function_">sayHi</span>())</code></pre><p>interface 中使用 union type</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunOptions</span> &#123;
  <span class="hljs-attr">program</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-comment">// commandline 可以是一个 字符串列表,可以是一个字符串,也可以是一个 return 字符串的函数</span>
  <span class="hljs-attr">commandline</span>: <span class="hljs-built_in">string</span>[] | <span class="hljs-built_in">string</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>)
  <span class="hljs-comment">// 只读</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">callback</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">boolean</span>
&#125;

<span class="hljs-comment">// commandline 是字符串</span>
<span class="hljs-keyword">var</span> <span class="hljs-attr">options</span>: <span class="hljs-title class_">RunOptions</span> = &#123; <span class="hljs-attr">program</span>: <span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-attr">commandline</span>: <span class="hljs-string">&quot;Hello&quot;</span> &#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">commandline</span>)

<span class="hljs-comment">// commandline 是字符串数组</span>
options = &#123; <span class="hljs-attr">program</span>: <span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-attr">commandline</span>: [<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>] &#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">commandline</span>[<span class="hljs-number">0</span>])
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">commandline</span>[<span class="hljs-number">1</span>])

<span class="hljs-comment">// commandline 是一个函数表达式</span>
options = &#123;
  <span class="hljs-attr">program</span>: <span class="hljs-string">&quot;test1&quot;</span>,
  <span class="hljs-attr">commandline</span>: <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;**Hello World**&quot;</span>
  &#125;
&#125;

<span class="hljs-keyword">var</span> <span class="hljs-attr">fn</span>: <span class="hljs-built_in">any</span> = options.<span class="hljs-property">commandline</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>())</code></pre><p><strong>索引签名</strong>:接口中可以为数组的 index 和 content 设置类型</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ages &#123;
  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-keyword">var</span> <span class="hljs-attr">agelist</span>: ages
<span class="hljs-comment">// 类型正确</span>
agelist[<span class="hljs-string">&quot;runoob&quot;</span>] = <span class="hljs-number">15</span>

<span class="hljs-comment">// 类型错误,输出  error TS2322: Type &#x27;&quot;google&quot;&#x27; is not assignable to type &#x27;number&#x27;.</span>
<span class="hljs-comment">// agelist[2] = &quot;google&quot;</span></code></pre><p>可选的值加 <code>?</code></p><pre><code class="hljs javascript">interface <span class="hljs-title class_">Animal</span> &#123;
 <span class="hljs-attr">name</span>: string
 <span class="hljs-attr">age</span>: number
 type?: string
&#125;</code></pre><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>接口可以通过其他接口来扩展自己,可以继承多个接口,使用 <code>extends</code> 语句</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-comment">// Musician 继承了 Person 接口,有 Person 接口的所有 methods 和 attribute</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Musician</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;
  <span class="hljs-attr">instrument</span>: <span class="hljs-built_in">string</span>
&#125;

<span class="hljs-keyword">var</span> drummer = &lt;<span class="hljs-title class_">Musician</span>&gt;&#123;&#125;
drummer.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>
drummer.<span class="hljs-property">instrument</span> = <span class="hljs-string">&quot;Drums&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;年龄:  &quot;</span> + drummer.<span class="hljs-property">age</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;喜欢的乐器:  &quot;</span> + drummer.<span class="hljs-property">instrument</span>)</code></pre><p>允许多继承:</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IParent1</span> &#123;
  <span class="hljs-attr">v1</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IParent2</span> &#123;
  <span class="hljs-attr">v2</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IParent1</span>, <span class="hljs-title class_">IParent2</span> &#123;&#125;
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Iobj</span>: <span class="hljs-title class_">Child</span> = &#123; <span class="hljs-attr">v1</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">v2</span>: <span class="hljs-number">23</span> &#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;value 1: &quot;</span> + <span class="hljs-title class_">Iobj</span>.<span class="hljs-property">v1</span> + <span class="hljs-string">&quot; value 2: &quot;</span> + <span class="hljs-title class_">Iobj</span>.<span class="hljs-property">v2</span>)</code></pre><h3 id="Interface-接口定义函数类型"><a href="#Interface-接口定义函数类型" class="headerlink" title="Interface 接口定义函数类型"></a>Interface 接口定义函数类型</h3><pre><code class="hljs javascript">interface <span class="hljs-title class_">Fn</span> &#123;
  (<span class="hljs-attr">name</span>: string): number[];
&#125;

<span class="hljs-keyword">const</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Fn</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name: string</span>) &#123;
  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
&#125;</code></pre><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>Class 类是对象的构造器:与 JS 的使用方法相同</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;
  <span class="hljs-comment">// 字段</span>
  <span class="hljs-attr">engine</span>: <span class="hljs-built_in">string</span>

  <span class="hljs-comment">// 构造函数</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">engine: <span class="hljs-built_in">string</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">engine</span> = engine
  &#125;

  <span class="hljs-comment">// 方法</span>
  <span class="hljs-title function_">disp</span>(): <span class="hljs-built_in">void</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;函数中显示发动机型号:&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">engine</span>)
  &#125;
&#125;

<span class="hljs-comment">// 创建一个对象</span>
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;XXSY1&quot;</span>)

<span class="hljs-comment">// 访问字段</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取发动机型号:&quot;</span> + obj.<span class="hljs-property">engine</span>)

<span class="hljs-comment">// 访问方法</span>
obj.<span class="hljs-title function_">disp</span>()</code></pre><p>类的继承:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;
  <span class="hljs-title class_">Area</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 指定 attribute 的 type</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Area</span> = a
  &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> &#123;
  <span class="hljs-title function_">disp</span>(): <span class="hljs-built_in">void</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;圆的面积:  &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">Area</span>)
  &#125;
&#125;

<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">223</span>)
obj.<span class="hljs-title function_">disp</span>()</code></pre><p>需要注意的是 <strong>子类只能继承一个父类</strong>,TypeScript <strong>不支持继承多个类</strong>,但支持多重继承:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Root</span> &#123;
  <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Root</span> &#123;&#125;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Child</span> &#123;&#125; <span class="hljs-comment">// 多重继承,继承了 Child 和 Root 类</span>

<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>()
obj.<span class="hljs-property">str</span> = <span class="hljs-string">&quot;hello&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">str</span>)</code></pre><p>static 静态 methods 、attribute,可直接通过类名来调用,不需要 <code>New</code></p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticMem</span> &#123;
  <span class="hljs-keyword">static</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">disp</span>(): <span class="hljs-built_in">void</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;num 值为 &quot;</span> + <span class="hljs-title class_">StaticMem</span>.<span class="hljs-property">num</span>)
  &#125;
&#125;

<span class="hljs-title class_">StaticMem</span>.<span class="hljs-property">num</span> = <span class="hljs-number">12</span> <span class="hljs-comment">// 初始化静态变量</span>
<span class="hljs-title class_">StaticMem</span>.<span class="hljs-title function_">disp</span>() <span class="hljs-comment">// 调用静态方法</span></code></pre><p>instanceof [&#x2F;ˈɪnstəns&#x2F;] 运算符,用于判断对象是否为指定类:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()
<span class="hljs-keyword">var</span> isPerson = obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj 对象是 Person 类实例化来的吗? &quot;</span> + isPerson)</code></pre><p>类的访问控制:</p><ul><li><strong>public(默认)</strong> : 公有,可以在任何地方被访问.</li><li><strong>protected</strong> : 受保护,可以被其 <strong>自身</strong> 以及其 <strong>子类</strong> 访问.</li><li><strong>private</strong> : <strong>私有</strong>,只能被其定义所在的类访问.</li></ul><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Encapsulate</span> &#123;
  <span class="hljs-attr">str1</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>
  <span class="hljs-keyword">private</span> <span class="hljs-attr">str2</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;world&quot;</span>
&#125;

<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encapsulate</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">str1</span>) <span class="hljs-comment">// 可访问</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">str2</span>) <span class="hljs-comment">// 编译错误, str2 是私有的</span></code></pre><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p><strong>对象实现接口.类是对象的构造器.</strong></p><p>使用 implements [英 &#x2F;ˈɪmplɪment&#x2F; vt. 使生效 n.用具] 关键字</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILoan</span> &#123;
  <span class="hljs-attr">interest</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AgriLoan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILoan</span> &#123;
  <span class="hljs-attr">interest</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">rebate</span>: <span class="hljs-built_in">number</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">interest: <span class="hljs-built_in">number</span>, rebate: <span class="hljs-built_in">number</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interest</span> = interest
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rebate</span> = rebate
  &#125;
&#125;

<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgriLoan</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;利润为 : &quot;</span> + obj.<span class="hljs-property">interest</span> + <span class="hljs-string">&quot;,抽成为 : &quot;</span> + obj.<span class="hljs-property">rebate</span>)</code></pre><h3 id="实现一个-Vue-Virtual-Dom-虚拟-DOM"><a href="#实现一个-Vue-Virtual-Dom-虚拟-DOM" class="headerlink" title="实现一个 Vue Virtual Dom 虚拟 DOM"></a>实现一个 Vue Virtual Dom 虚拟 DOM</h3><pre><code class="hljs typescript"><span class="hljs-comment">// 1. class 的基本用法,继承和类型约束 implements</span>
<span class="hljs-comment">// 2. class 的修饰符 public private protected readonly static</span>
<span class="hljs-comment">// 3. super() 调用父类的构造函数</span>
<span class="hljs-comment">// 4. static 静态属性和方法</span>
<span class="hljs-comment">// 5. getter 和 setter</span>
<span class="hljs-comment">// private 只能在类的内部访问,子类和实例化类也不能访问</span>
<span class="hljs-comment">// protected 只能在类的内部和子类中访问,实例化类不能访问</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Options</span> &#123;
  <span class="hljs-attr">el</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">HTMLElement</span>
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">VueCls</span> &#123;
  <span class="hljs-attr">options</span>: <span class="hljs-title class_">Options</span>
  <span class="hljs-title function_">init</span>(): <span class="hljs-built_in">void</span>
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vnode</span> &#123;
  <span class="hljs-attr">tag</span>: <span class="hljs-built_in">string</span>
  text?: <span class="hljs-built_in">string</span>
  children?: <span class="hljs-title class_">Vnode</span>[]
&#125;

<span class="hljs-comment">// virtual dom 虚拟 DOM 简单实现</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom</span> &#123;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Dom constructor&quot;</span>)
  &#125;

  <span class="hljs-comment">// 静态方法 只能通过 Dom.version() 调用</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">version</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.0.1&quot;</span>
  &#125;

  <span class="hljs-comment">// 创建元素</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-attr">el</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">HTMLElement</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(el)
  &#125;
  <span class="hljs-comment">// 填充文本</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setText</span>(<span class="hljs-attr">el</span>: <span class="hljs-title class_">HTMLElement</span>, <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> &#123;
    el.<span class="hljs-property">textContent</span> = text
  &#125;
  <span class="hljs-comment">// 渲染函数</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">render</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">Vnode</span>): <span class="hljs-title class_">HTMLElement</span> &#123;
    <span class="hljs-keyword">let</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createElement</span>(data.<span class="hljs-property">tag</span>)
    <span class="hljs-keyword">if</span> (data.<span class="hljs-property">children</span> &amp;&amp; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data.<span class="hljs-property">children</span>)) &#123;
      data.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;
        <span class="hljs-keyword">let</span> child = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>(item) <span class="hljs-comment">// 递归渲染子节点</span>
        root.<span class="hljs-title function_">appendChild</span>(child)
      &#125;)
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setText</span>(root, data.<span class="hljs-property">text</span> ? data.<span class="hljs-property">text</span> : <span class="hljs-literal">null</span>)
    &#125;
    <span class="hljs-keyword">return</span> root
  &#125;
&#125;

<span class="hljs-comment">// Vue 类 继承 Dom 类 实现 VueCls 接口</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Dom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VueCls</span> &#123;
  <span class="hljs-attr">options</span>: <span class="hljs-title class_">Options</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options: Options</span>) &#123;
    <span class="hljs-variable language_">super</span>() <span class="hljs-comment">// 调用父类的构造函数 prototype.constructor.call(this)</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>()
  &#125;
  <span class="hljs-title function_">init</span>(): <span class="hljs-built_in">void</span> &#123;
    <span class="hljs-comment">// 虚拟 dom 就是通过 js 渲染真实的 dom HTML</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">Vnode</span> = &#123;
      <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;div&quot;</span>,
      <span class="hljs-attr">children</span>: [
        &#123;
          <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;p&quot;</span>,
          <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;I am child 1&quot;</span>
        &#125;,
        &#123;
          <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;p&quot;</span>,
          <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;I am child 2&quot;</span>
        &#125;
      ]
    &#125;
    <span class="hljs-keyword">let</span> app =
      <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">el</span> === <span class="hljs-string">&quot;string&quot;</span>
        ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">el</span>)
        : <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">el</span>
    app?.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>(data))
  &#125;
&#125;

<span class="hljs-keyword">let</span> vue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span> &#125;)</code></pre><h3 id="类的-getter-和-setter"><a href="#类的-getter-和-setter" class="headerlink" title="类的 getter 和 setter"></a>类的 getter 和 setter</h3><pre><code class="hljs typescript"><span class="hljs-comment">// 类 get set 方法</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span> &#123;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">_value</span>: <span class="hljs-built_in">any</span> <span class="hljs-comment">// 维护一个内部变量</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value
  &#125;

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get value&quot;</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get value: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>
  &#125;

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue: <span class="hljs-built_in">any</span></span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set value&quot;</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-string">&quot;set value: &quot;</span> + newValue
  &#125;
&#125;

<span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ref</span>(<span class="hljs-string">&quot;hyy&quot;</span>)
ref.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;hyy&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ref.<span class="hljs-property">value</span>)</code></pre><h3 id="抽象类-基类"><a href="#抽象类-基类" class="headerlink" title="抽象类 基类"></a>抽象类 基类</h3><p><code>abstract</code> 定义抽象类,<strong>抽象类不能被实例化</strong>,只能被继承,<strong>子类需要实现抽象类中的抽象方法</strong>.</p><p><code>abstract</code> 所定义的方法,<strong>都只能描述,不能实现</strong>.</p><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span> &#123;
  <span class="hljs-attr">_name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name
  &#125;
  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">say</span>(<span class="hljs-attr">word</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>
  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">string</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>
  &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">animal</span> &#123;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;
    <span class="hljs-variable language_">super</span>(name)
  &#125;
  <span class="hljs-title function_">say</span>(<span class="hljs-attr">word</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>._name&#125;</span> say <span class="hljs-subst">$&#123;word&#125;</span>`</span>)
  &#125;
&#125;

<span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;tom&quot;</span>)
cat.<span class="hljs-title function_">say</span>(<span class="hljs-string">&quot;hello&quot;</span>)</code></pre><h3 id="Initialization-Order-初始化顺序"><a href="#Initialization-Order-初始化顺序" class="headerlink" title="Initialization Order 初始化顺序"></a>Initialization Order 初始化顺序</h3><p>In some case, 继承类会出现 <strong>反人类</strong> 的行为:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;
  name = <span class="hljs-string">&quot;base&quot;</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)
  &#125;
&#125;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> &#123;
  name = <span class="hljs-string">&quot;derived&quot;</span>
&#125; <span class="hljs-comment">// Prints &quot;base&quot;, not &quot;derived&quot;const d = new Derived();</span></code></pre><p>What happened here? The order of class initialization, as defined by JavaScript(由JS定义), is:</p><ol><li>Initialize base class fields (初始化基类字段)</li><li>Run base class constructor (运行基类构造函数)</li><li>Initialize derived(v.得到 n.源于) class fields (初始化派生类字段)</li><li>Run derived class constructor (运行派生类构造函数)</li></ol><h3 id="The-confusing-this-容易混淆的-this"><a href="#The-confusing-this-容易混淆的-this" class="headerlink" title="The confusing this (容易混淆的 this)"></a>The confusing <code>this</code> (容易混淆的 <code>this</code>)</h3><p>JavaScript’s handling of this is indeed unusual (JS 对于 This 的处理的确很不寻常)</p><p>调用函数时, 函数内 this 的值取决于函数的 <strong>调用方式</strong>.在此示例中,由于该函数是通过 obj 引用调用的,因此其 this 的值为 obj 而不是类实例.</p><p>由谁调用的函数, this 就是谁.</p><p>当使用箭头函数(arrow function)时, <code>this</code> 的值取决于函数的<strong>定义位置</strong>. 箭头函数不会绑定 this,而是从定义时的作用域中继承 <code>this</code>.</p><p>使用了箭头函数, 就不能在派生类(derived class) 中使用 super 调用定义的 箭头函数. 因为 <strong>原型链</strong> 中没有箭头函数的定义. (可能是没有绑定到基类的 this)</p><blockquote><p>You can’t use <code>super.getName()</code> in a derived class, because there’s no entry in the prototype chain(原型链) to fetch the base class method from.</p></blockquote><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;
  name = <span class="hljs-string">&quot;MyClass&quot;</span>
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>
  &#125;
&#125;
<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>()
<span class="hljs-keyword">const</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span>,
  <span class="hljs-attr">getName</span>: c.<span class="hljs-property">getName</span> <span class="hljs-comment">// bind this to the nearest object when be called</span>
&#125;

<span class="hljs-comment">// called by obj, `this` is obj.</span>
<span class="hljs-comment">// Prints &quot;obj&quot;, not &quot;MyClass&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getName</span>())

<span class="hljs-comment">// use arrow function to void this confusion</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;
  name = <span class="hljs-string">&quot;MyClass&quot;</span>
  getName = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>
  &#125;
&#125;
<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>()
<span class="hljs-keyword">const</span> g = c.<span class="hljs-property">getName</span>
<span class="hljs-comment">// Prints &quot;MyClass&quot; instead of crashing</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">g</span>())</code></pre><h3 id="Explicitly-Declared-this-parameters-显式声明-class-中的-this"><a href="#Explicitly-Declared-this-parameters-显式声明-class-中的-this" class="headerlink" title="Explicitly Declared this parameters 显式声明 class 中的 this"></a>Explicitly Declared <code>this</code> parameters 显式声明 class 中的 this</h3><p>在方法或函数定义中,名为 this 的初始参数在 TypeScript 中具有特殊含义.这些参数在编译期间被删除.</p><pre><code class="hljs typescript"><span class="hljs-comment">// TypeScript input with &#x27;this&#x27; parameter</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: SomeType, x: <span class="hljs-built_in">number</span></span>) &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;
<span class="hljs-comment">// JavaScript output</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x</span>) &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;</code></pre><p>TypeScript 会检查函数是否以指定的 this 上下文调用, 可以在方法定义中添加一个 this 参数来静态强制(statically enforce) 调用该方法, 而不是使用箭头函数:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;
  name = <span class="hljs-string">&quot;MyClass&quot;</span>
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: MyClass</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>
  &#125;
&#125;
<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>()
<span class="hljs-comment">// OK</span>
c.<span class="hljs-title function_">getName</span>()

<span class="hljs-comment">// Error, would crash:</span>
<span class="hljs-comment">// The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable(adj. 可分配的) to method&#x27;s &#x27;this&#x27; of type &#x27;MyClass&#x27;.</span>
<span class="hljs-keyword">const</span> g = c.<span class="hljs-property">getName</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">g</span>())</code></pre><p>这样, 函数也可以正确的在 派生类(derived class) 中使用 super 调用.</p><h3 id="Constructor-Signature-构造函数签名"><a href="#Constructor-Signature-构造函数签名" class="headerlink" title="Constructor Signature 构造函数签名"></a>Constructor Signature 构造函数签名</h3><p>JavaScript 类使用 new 运算符进行实例化. 给定类本身的类型, 使用 <code>InstanceType</code> 实用程序类型(utility type models) 获取实例类型.</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;
  <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y
  &#125;
&#125;

<span class="hljs-comment">// get class instance type</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">PointInstance</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Point</span>&gt;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">moveRight</span>(<span class="hljs-params">point: PointInstance</span>) &#123;
  point.<span class="hljs-property">x</span> += <span class="hljs-number">5</span>
&#125;

<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-title function_">moveRight</span>(point)
point.<span class="hljs-property">x</span> <span class="hljs-comment">// =&gt; 8</span></code></pre><h2 id="Dock-Typing-鸭子类型"><a href="#Dock-Typing-鸭子类型" class="headerlink" title="Dock Typing 鸭子类型"></a>Dock Typing 鸭子类型</h2><p>鸭子类型(英语:duck typing)是动态类型的一种风格,是多态 (polymorphism [英 &#x2F;ˌpɒlɪ’mɔːfɪz(ə)m&#x2F;]) 的一种形式.</p><blockquote><p>“ 当看到一只鸟 <strong>走</strong> 起来像鸭子、<strong>游泳</strong> 起来像鸭子、<strong>叫</strong> 起来也像鸭子,那么这只鸟就可以被称为 <strong>鸭子</strong>.” ——&lt;落落前传&gt;</p></blockquote><p>在 <strong>鸭子类型</strong> 中,关注的是 object 的 方法 <code>methods</code> ,而不是 object 的类型.<br>换言之如果一个类型 A 实现了 <code>run()</code> 和 <code>eat()</code> 的方法(即实现了行为接口)就可以通过接口类型调用这个方法,<strong>不需要知道类型是什么</strong>.</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPoint</span> &#123;
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-comment">// p1: 实现了 IPoint 接口的对象,即有 x,y 两个 parameter</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addPoints</span>(<span class="hljs-params">p1: IPoint, p2: IPoint</span>): <span class="hljs-title class_">IPoint</span> &#123;
  <span class="hljs-keyword">var</span> x = p1.<span class="hljs-property">x</span> + p2.<span class="hljs-property">x</span>
  <span class="hljs-keyword">var</span> y = p1.<span class="hljs-property">y</span> + p2.<span class="hljs-property">y</span>
  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y &#125;
&#125;

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">var</span> newPoint = <span class="hljs-title function_">addPoints</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">4</span> &#125;, &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> &#125;)

<span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">var</span> newPoint2 = <span class="hljs-title function_">addPoints</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span> &#125;)</code></pre><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间可以解决重复命名的问题.</p><pre><code class="hljs typescript"><span class="hljs-comment">// 定义了一个命名空间 SomeNameSpaceName</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">SomeNameSpaceName</span> &#123;
  <span class="hljs-comment">// export 用于在外部导入 SomeNameSpaceName 中的类和接口</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISomeInterfaceName</span> &#123;&#125;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClassName</span> &#123;&#125;
&#125;</code></pre><h2 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h2><ol><li>可以更改的组织代码</li><li>模块在自身的作用域执行,定义在模块里面的变量、函数和类在外部是不可见的,除非使用 <code>export</code> 导出,并在外部使用 <code>import</code> 导入.</li></ol><p>SomeInterFace.ts</p><pre><code class="hljs typescript"><span class="hljs-comment">// 使用 export 导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SomeInterface</span> &#123;
  <span class="hljs-comment">// 代码部分</span>
&#125;</code></pre><p>mian.ts</p><pre><code class="hljs typescript"><span class="hljs-comment">// 使用 import 导入</span>
<span class="hljs-keyword">import</span> someInterfaceRef = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./SomeInterface&quot;</span>)</code></pre><p>使用 tsc 编译代码:</p><pre><code class="hljs typescript">tsc --<span class="hljs-variable language_">module</span> amd main.<span class="hljs-property">ts</span>
<span class="hljs-comment">// 或者</span>
tsc --<span class="hljs-variable language_">module</span> commonjs <span class="hljs-title class_">TestShape</span>.<span class="hljs-property">ts</span></code></pre><h2 id="生成器-迭代器"><a href="#生成器-迭代器" class="headerlink" title="生成器 迭代器"></a>生成器 迭代器</h2><p>手写一个生成器,使用 <code>function*</code> 标记为<strong>生成器</strong></p><pre><code class="hljs typescript"><span class="hljs-comment">// 生成器</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">generator</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello&quot;</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;hyy&quot;</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">123</span>
  <span class="hljs-keyword">yield</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hyy&quot;</span> &#125;
&#125;

<span class="hljs-keyword">const</span> girls = <span class="hljs-title function_">generator</span>()

<span class="hljs-comment">// done 表示是否迭代完成</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(girls.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123; value: Promise &#123; &#x27;hello&#x27; &#125;, done: false &#125;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(girls.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123; value: &#x27;hyy&#x27;, done: false &#125;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(girls.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123; value: 123, done: false &#125;</span></code></pre><p>迭代器:</p><p><strong>es6 新增的数据类型 set map argument</strong></p><pre><code class="hljs typescript"><span class="hljs-comment">// es6 新增的数据类型</span>
<span class="hljs-comment">// set 元组</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">set</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]) <span class="hljs-comment">// 无序不重复 自动去重</span>
<span class="hljs-comment">// map 映射 对象 字典</span>
<span class="hljs-comment">// 和 object 不同的的是 key 可以是任意类型, object 的 key 只能是字符串</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hyy&quot;</span>)
map.<span class="hljs-title function_">set</span>(arr, <span class="hljs-string">&quot;hyy&quot;</span>)

<span class="hljs-keyword">function</span> <span class="hljs-title function_">args</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>) <span class="hljs-comment">// arguments 是一个类数组</span>
&#125;
<span class="hljs-keyword">let</span> lst = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;div&quot;</span>) <span class="hljs-comment">// 类数组</span></code></pre><p>以上类数组 他们都有迭代器 <code>Symbol.iterator</code>,所以可以使用迭代器来遍历他们:</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">each</span> = (<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt; &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">iterator</span>: <span class="hljs-built_in">any</span> = value[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()
    <span class="hljs-keyword">let</span> <span class="hljs-attr">next</span>: <span class="hljs-built_in">any</span> = &#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;
    <span class="hljs-keyword">while</span> (!next.<span class="hljs-property">done</span>) &#123;
        next = iterator.<span class="hljs-title function_">next</span>()
        <span class="hljs-keyword">if</span> (!next.<span class="hljs-property">done</span>) &#123;
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(next.<span class="hljs-property">value</span>) <span class="hljs-comment">// current next value</span>
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 迭代器的语法糖 for of</span>
<span class="hljs-comment">// object 不能使用 for of, 因为 object 没有 Symbol.iterator 迭代器</span>
<span class="hljs-comment">// object 使用  `key for in object` 遍历</span>
<span class="hljs-comment">// 或者 `[key, value] for of Object.entries(obj)`</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> arr) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
&#125;

<span class="hljs-comment">// 解构 底层原理也是调用 Symbol.iterator</span>
<span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> copy = [...arr] <span class="hljs-comment">// 拷贝数组</span>
<span class="hljs-keyword">let</span> [first, …rest] = arr <span class="hljs-comment">// 解构赋值</span>

<span class="hljs-comment">// 对象支持 for of</span>
<span class="hljs-keyword">let</span> obj = &#123;
    <span class="hljs-attr">max</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">current</span>: <span class="hljs-number">0</span>,
    <span class="hljs-comment">// 手动实现一个迭代器</span>
    <span class="hljs-comment">// 返回一个有 next 方法的对象</span>
    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;
        <span class="hljs-keyword">return</span> &#123;
            <span class="hljs-attr">max</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>,
            <span class="hljs-attr">current</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>,
            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>) &#123;
                    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;
                &#125;
            &#125;,
        &#125;
    &#125;,
&#125;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> obj) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
&#125;

<span class="hljs-comment">// 对象也可以解构</span>
<span class="hljs-keyword">let</span> &#123; max, current &#125; = obj
</code></pre><h2 id="泛型-generic"><a href="#泛型-generic" class="headerlink" title="泛型 generic"></a>泛型 generic</h2><p>根据传入的参数,动态定义 function 内部的类型,T 相当于一个占位符号.</p><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> echo&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;
  <span class="hljs-keyword">return</span> arg
&#125;
echo&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)

<span class="hljs-keyword">type</span> A&lt;T&gt; = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | T
<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: A&lt;<span class="hljs-built_in">boolean</span>&gt; = <span class="hljs-literal">true</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;T&gt; &#123;
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">data</span>: T
&#125;
<span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">Data</span>&lt;<span class="hljs-built_in">string</span>[]&gt; = &#123;
  <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">data</span>: [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]
&#125;

<span class="hljs-comment">// 泛型支持设置默认值 多个值</span>
<span class="hljs-keyword">function</span> add&lt;T = <span class="hljs-built_in">number</span>, K = <span class="hljs-built_in">number</span>&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: K): <span class="hljs-title class_">Array</span>&lt;T | K&gt; &#123;
  <span class="hljs-keyword">return</span> [a, b]
&#125;
<span class="hljs-title function_">add</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)</code></pre><p>应用:封装一个 <code>XMLHttpRequest</code> ,使用 <strong>generic</strong> 定义返回的类型,这样在 then 接收的时候就能自动提示类型.</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> axios = &#123;
  get&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;T&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
      <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()
      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>)
      xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;
          <span class="hljs-comment">// return response</span>
          <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>))
        &#125;
      &#125;
      xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>)
    &#125;)
  &#125;
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span> &#123;
  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>
&#125;

axios.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">Data</span>&gt;(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/todos/1&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">code</span>)
&#125;)</code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>用于控制泛型的范围,在类型后面跟一个 extands 再跟一个约束的类型</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Len</span> &#123;
  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-comment">// 约束泛型 T 要有 length attribute</span>
<span class="hljs-keyword">function</span> fn&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Len</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>)
  <span class="hljs-keyword">return</span> arg
&#125;

<span class="hljs-title function_">fn</span>(<span class="hljs-string">&quot;123&quot;</span>)
<span class="hljs-title function_">fn</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-title function_">fn</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> &#125;)
<span class="hljs-title function_">fn</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// error</span></code></pre><p>keyof 读取对象的所有属性名 实现安全的对象访问:</p><pre><code class="hljs typescript"><span class="hljs-comment">// keyof 读取对象的所有属性名 实现安全的对象访问</span>

<span class="hljs-keyword">let</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;wf&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
  <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;famale&quot;</span>
&#125;

<span class="hljs-comment">// 获取对象的所有属性名的 Union type</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ObjKey</span> = keyof <span class="hljs-keyword">typeof</span> obj

<span class="hljs-keyword">function</span> objPick&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K): T[K] &#123;
  <span class="hljs-keyword">return</span> obj[key]
&#125;

<span class="hljs-title function_">objPick</span>(obj, <span class="hljs-string">&quot;name&quot;</span>)</code></pre><p>keyof 的高级用法,将 interface 的 key 变可选</p><pre><code class="hljs typescript"><span class="hljs-comment">// keyof 的高级用法</span>
<span class="hljs-comment">// 将 interface 的 key 变可选</span>

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span> &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Option</span> = &#123;
  [K <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Data</span>]?: <span class="hljs-title class_">Data</span>[K]
&#125;
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Option</span>&lt;<span class="hljs-title class_">Data</span>&gt;</code></pre><h2 id="tsconfig-json-配置文件"><a href="#tsconfig-json-配置文件" class="headerlink" title="tsconfig.json 配置文件"></a>tsconfig.json 配置文件</h2><p>通过 <code>tsc --init</code> 生成.</p><p>tsconfig.json</p><pre><code class="hljs json"><span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;incremental&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// TS编译器在第一次编译之后会生成一个存储编译信息的文件,第二次编译会在第一次的基础上进行增量编译,可以提高编译的速度</span>
  <span class="hljs-attr">&quot;tsBuildInfoFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./buildFile&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 增量编译文件的存储位置</span>
  <span class="hljs-attr">&quot;diagnostics&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 打印诊断信息</span>
  <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES5&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 目标语言的版本</span>
  <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CommonJS&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成代码的模板标准</span>
  <span class="hljs-attr">&quot;outFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./app.js&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 将多个相互依赖的文件生成一个文件,可以用在AMD模块中,即开启时应设置&quot;module&quot;: &quot;AMD&quot;,</span>
  <span class="hljs-attr">&quot;lib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;DOM&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ES2015&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ScriptHost&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;ES2019.Array&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// TS需要引用的库,即声明文件,es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性,通常都需要配置,如es8的数组新特性需要引入&quot;ES2019.Array&quot;,</span>
  <span class="hljs-attr">&quot;allowJS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 允许编译器编译JS,JSX文件</span>
  <span class="hljs-attr">&quot;checkJs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 允许在JS文件中报错,通常与allowJS一起使用</span>
  <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定输出目录</span>
  <span class="hljs-attr">&quot;rootDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定输出文件目录(用于输出),用于控制输出目录结构</span>
  <span class="hljs-attr">&quot;declaration&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成声明文件,开启后会自动生成声明文件</span>
  <span class="hljs-attr">&quot;declarationDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./file&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定生成声明文件存放目录</span>
  <span class="hljs-attr">&quot;emitDeclarationOnly&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 只生成声明文件,而不会生成js文件</span>
  <span class="hljs-attr">&quot;sourceMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成目标文件的sourceMap文件</span>
  <span class="hljs-attr">&quot;inlineSourceMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成目标文件的inline SourceMap,inline SourceMap会包含在生成的js文件中</span>
  <span class="hljs-attr">&quot;declarationMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 为声明文件生成sourceMap</span>
  <span class="hljs-attr">&quot;typeRoots&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 声明文件目录,默认时node_modules/@types</span>
  <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 加载的声明文件包</span>
  <span class="hljs-attr">&quot;removeComments&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 删除注释</span>
  <span class="hljs-attr">&quot;noEmit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 不输出文件,即编译后不会生成任何js文件</span>
  <span class="hljs-attr">&quot;noEmitOnError&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 发送错误时不输出任何文件</span>
  <span class="hljs-attr">&quot;noEmitHelpers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 不生成helper函数,减小体积,需要额外安装,常配合importHelpers一起使用</span>
  <span class="hljs-attr">&quot;importHelpers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 通过tslib引入helper函数,文件必须是模块</span>
  <span class="hljs-attr">&quot;downlevelIteration&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 降级迭代器实现,如果目标源是es3/5,那么迭代器会有降级的实现</span>
  <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 开启所有严格的类型检查</span>
  <span class="hljs-attr">&quot;alwaysStrict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 在代码中注入 &#x27;use strict&#x27;</span>
  <span class="hljs-attr">&quot;noImplicitAny&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 不允许隐式的any类型</span>
  <span class="hljs-attr">&quot;strictNullChecks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 不允许把null、undefined赋值给其他类型的变量</span>
  <span class="hljs-attr">&quot;strictFunctionTypes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 不允许函数参数双向协变</span>
  <span class="hljs-attr">&quot;strictPropertyInitialization&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 类的实例属性必须初始化</span>
  <span class="hljs-attr">&quot;strictBindCallApply&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 严格的bind/call/apply检查</span>
  <span class="hljs-attr">&quot;noImplicitThis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 不允许this有隐式的any类型</span>
  <span class="hljs-attr">&quot;noUnusedLocals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 检查只声明、未使用的局部变量(只提示不报错)</span>
  <span class="hljs-attr">&quot;noUnusedParameters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 检查未使用的函数参数(只提示不报错)</span>
  <span class="hljs-attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 防止switch语句贯穿(即如果没有break语句后面不会执行)</span>
  <span class="hljs-attr">&quot;noImplicitReturns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//每个分支都会有返回值</span>
  <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 允许export=导出,由import from 导入</span>
  <span class="hljs-attr">&quot;allowUmdGlobalAccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 允许在模块中全局变量的方式访问umd模块</span>
  <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 模块解析策略,ts默认用node的解析策略,即相对的方式导入</span>
  <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 解析非相对模块的基地址,默认是当前目录</span>
  <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 路径映射,相对于baseUrl</span>
    <span class="hljs-comment">// 如使用jq时不想使用默认版本,而需要手动指定版本,可进行如下配置</span>
    <span class="hljs-attr">&quot;jquery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node_modules/jquery/dist/jquery.min.js&quot;</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;rootDirs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;out&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 将多个目录放在一个虚拟目录下,用于运行时,即编译后引入文件的位置可能发生变化,这也设置可以虚拟src和out在同一个目录下,不用再去改变路径也不会报错</span>
  <span class="hljs-attr">&quot;listEmittedFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 打印输出文件</span>
  <span class="hljs-attr">&quot;listFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-comment">// 打印编译的文件(包括引用的声明文件)</span>
<span class="hljs-punctuation">&#125;</span>

<span class="hljs-comment">// 指定一个匹配列表(属于自动指定该路径下的所有ts相关文件)</span>
<span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
   <span class="hljs-string">&quot;src/**/*&quot;</span>
<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
<span class="hljs-comment">// 指定一个排除列表(include的反向操作)</span>
 <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
   <span class="hljs-string">&quot;demo.ts&quot;</span>
<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
<span class="hljs-comment">// 指定哪些文件使用该配置(属于手动一个个指定文件)</span>
 <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
   <span class="hljs-string">&quot;demo.ts&quot;</span>
<span class="hljs-punctuation">]</span></code></pre><h2 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h2><p>编程中,无法避免 <strong>同名全局变量</strong>(global variable)造成的污染 pollution,namespace 避免这个问题的出现.相当于闭包,把函数的变量隔离出来.</p><p><code>namespace</code> 支持:嵌套、抽离、导出、简化、合并</p><pre><code class="hljs typescript"><span class="hljs-comment">// namespace 命名空间</span>
<span class="hljs-comment">// 嵌套 抽离 导出 简化 合并</span>

<span class="hljs-comment">// namespace 所有的东西包括 variable 和 function 必须要 export 导出才能访问</span>
<span class="hljs-comment">// 同名 namespace 会合并</span>
<span class="hljs-comment">// 支持把整个 namespace export 导出</span>
<span class="hljs-comment">// 导入简写</span>
<span class="hljs-keyword">import</span> a=<span class="hljs-title class_">Test</span>.<span class="hljs-property">fn</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vue&#x27;</span>
<span class="hljs-title function_">a</span>()

<span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Test</span> &#123;
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> A &#123;
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>
        <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fn&quot;</span>)
        &#125;
    &#125;
&#125;</code></pre><p>应用场景:跨端项目,同一个功能,不同的 platform 有不同的实现,同一个 function 名字相同,可以用 namespace 划分不同平台的实现.</p><pre><code class="hljs typescript"><span class="hljs-keyword">namespace</span> ios &#123;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">pushNotification</span> = (<span class="hljs-params">msg: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">type</span>: <span class="hljs-built_in">number</span></span>) =&gt; &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;IOS pushNotification&quot;</span>)
  &#125;
&#125;

<span class="hljs-keyword">namespace</span> android &#123;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">pushNotification</span> = (<span class="hljs-params">msg: <span class="hljs-built_in">string</span></span>) =&gt; &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Android pushNotification&quot;</span>)
  &#125;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">callPhone</span> = (<span class="hljs-params">phone: <span class="hljs-built_in">string</span></span>) =&gt; &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Android callPhone&quot;</span>)
  &#125;
&#125;</code></pre><h2 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h2><p>三斜线指令是包含单个 XML 标签的单行注释.注释的内容会做为编译器指令使用.</p><p>三斜线指令 <strong>仅可放在包含它的文件的最顶端</strong>.</p><p><code>///&lt;reference path＝＂…&quot;/&gt;</code></p><p>指令是三斜线指令中最常见的一种.它用于声明文件间的依赖.三斜线引用<strong>告诉编译器在编译过程中要引入的额外的文件</strong>.</p><p>也可以把它理解能 import,它可以告诉编译器在 **编译过程中要引入的额外的文件.**、</p><p>也可以引用声明 declare 文件:<code>/// &lt;reference type=&quot;node.d.ts&quot;&gt;</code></p><h2 id="声明文件-declare-d-ts"><a href="#声明文件-declare-d-ts" class="headerlink" title="声明文件 declare d.ts"></a>声明文件 declare d.ts</h2><p>初始化一个项目</p><pre><code class="hljs shell">tsc --init
npm init // generate package.json</code></pre><p>当使用第三方库时,我们需要引用它的声明文件,才能获得对应的代码补全、接口提示等功能.声明文件不包含具体实现,只是一个类型 hint.</p><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> 声明全局变量
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> 声明全局方法
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> 声明全局类
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">enum</span> 声明全局枚举类型
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> 声明(含有子属性的)全局对象
interface 和 type 声明全局类型
/// &lt;reference /&gt; 三斜线指令</code></pre><p>一些老的库都是用 js ,要另外安装对应的 <code>d.ts</code> 声明库才能使用 ts 的语法提示:</p><pre><code class="hljs shell">npm install @types/node -D</code></pre><p>手动编写 declare 文件:</p><p>index.ts</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
<span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/api&quot;</span>, router)
router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/list&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  res.<span class="hljs-title function_">json</span>(&#123;
    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>
  &#125;)
&#125;)

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9001</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9001</span>)
&#125;)</code></pre><p>express.d.ts</p><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;express&quot;</span> &#123;
  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Router</span> &#123;
    <span class="hljs-title function_">get</span>(<span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">cb</span>: <span class="hljs-function">(<span class="hljs-params">req: <span class="hljs-built_in">any</span>, res: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>
  &#125;
  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">App</span> &#123;
    <span class="hljs-title function_">use</span>(<span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">router</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span>
    <span class="hljs-title function_">listen</span>(<span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>, cb?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>
  &#125;
  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Express</span> &#123;
    (): <span class="hljs-title class_">App</span>
  &#125;
  <span class="hljs-keyword">const</span> <span class="hljs-attr">express</span>: <span class="hljs-title class_">Express</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> express
&#125;</code></pre><h2 id="Mixins-混入"><a href="#Mixins-混入" class="headerlink" title="Mixins 混入"></a>Mixins 混入</h2><h3 id="Object-混入"><a href="#Object-混入" class="headerlink" title="Object 混入"></a>Object 混入</h3><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Name</span> &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
&#125;
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Age</span> &#123;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sex</span> &#123;
  <span class="hljs-attr">sex</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-keyword">let</span> <span class="hljs-attr">people1</span>: <span class="hljs-title class_">Name</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小满&quot;</span> &#125;
<span class="hljs-keyword">let</span> <span class="hljs-attr">people2</span>: <span class="hljs-title class_">Age</span> = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;
<span class="hljs-keyword">let</span> <span class="hljs-attr">people3</span>: <span class="hljs-title class_">Sex</span> = &#123; <span class="hljs-attr">sex</span>: <span class="hljs-number">1</span> &#125;

<span class="hljs-comment">// ES6 新方法 Object.assign 浅拷贝 只能脱离第一层引用</span>
<span class="hljs-keyword">const</span> people = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(people1, people2, people3)
<span class="hljs-comment">// ES6 对象解构 浅拷贝 只能脱离第一层引用</span>
<span class="hljs-keyword">const</span> people = &#123; ...people1, ...people2, ...people3 &#125;
<span class="hljs-comment">// ES6 深拷贝 结构克隆</span>
<span class="hljs-title function_">structedClone</span>(a)</code></pre><h3 id="Class-类的混入"><a href="#Class-类的混入" class="headerlink" title="Class 类的混入"></a>Class 类的混入</h3><p>一般用于 Plugins 依赖注入,类似 <code>app=MixinsPlugin(app)</code>:</p><p>ref: <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/mixins.html">TypeScript: Documentation - Mixins</a></p><pre><code class="hljs typescript"><span class="hljs-comment">// class mixin</span>

<span class="hljs-comment">// app</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">APP</span> &#123;
    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;run&quot;</span>)
    &#125;
&#125;

<span class="hljs-comment">// plugin</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Loger</span> &#123;
    <span class="hljs-title function_">log</span>(<span class="hljs-params">msg: <span class="hljs-built_in">string</span></span>) &#123;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)
    &#125;
&#125;

<span class="hljs-comment">// plugin</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HTML</span> &#123;
    <span class="hljs-title function_">render</span>(<span class="hljs-params">HTML: <span class="hljs-built_in">string</span></span>) &#123;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>, <span class="hljs-variable constant_">HTML</span>)
    &#125;
&#125;

<span class="hljs-comment">// 将APP类注入 Loger 和 HTML 类</span>

<span class="hljs-comment">// 写一个类约束,为构造函数可以被new</span>
<span class="hljs-comment">// 类是对象的构造器</span>
<span class="hljs-comment">// type Constructor&lt;T extends object&gt; = new (…args: any[]) =&gt; T</span>
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span>&lt;T = &#123;&#125;&gt; = <span class="hljs-keyword">new</span> (…<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; T

<span class="hljs-comment">// 需要返回一个新的类,混入上面的3个类</span>
<span class="hljs-comment">// Mixins may not declare private/protected properties 混入不能声明私有/受保护的属性</span>
<span class="hljs-keyword">function</span> pluginMinxin&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Constructor</span>&lt;<span class="hljs-variable constant_">APP</span>&gt;&gt;(<span class="hljs-title class_">Base</span>: T) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Base</span> &#123;
        <span class="hljs-keyword">private</span> <span class="hljs-title class_">Loger</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Loger</span>()
        <span class="hljs-keyword">private</span> <span class="hljs-variable constant_">HTML</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">HTML</span>()
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">…args: <span class="hljs-built_in">any</span>[]</span>) &#123;
            <span class="hljs-variable language_">super</span>(…args)
        &#125;
        <span class="hljs-comment">// 写混入的方法</span>
        <span class="hljs-title function_">run</span>(): <span class="hljs-built_in">void</span> &#123;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">Loger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;run&quot;</span>)
        &#125;
        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">Loger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;render&quot;</span>)
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">HTML</span>.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;render&quot;</span>)
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">const</span> mixins = <span class="hljs-title function_">pluginMinxin</span>(<span class="hljs-variable constant_">APP</span>) <span class="hljs-comment">// 将类 mixin 返回混合后的类</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title function_">mixins</span>() <span class="hljs-comment">// 实例化 mixin 后的类</span>
app.<span class="hljs-title function_">run</span>()</code></pre><h2 id="JS-原型链-JS-prototype-chain"><a href="#JS-原型链-JS-prototype-chain" class="headerlink" title="JS 原型链 (JS prototype chain)"></a>JS 原型链 (JS prototype chain)</h2><p>好像不是 TS 的知识,但为了更好的理解原理我放到这里来了.</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果一个函数用 <code>new xxx()</code> 的方式调用,这个函数就称为<strong>构造函数</strong>,相当于 ES6 中的 <code>class</code> 语法糖.<br>在构造函数中的 this 原先是 null,可以在函数内部通过 <code>this.xx</code> 的方式赋予 <code>value</code> 和 <code>method</code>,new 这个函数返回的就是 this 这个对象.</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">People</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) &#123;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">say</span> = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> say she had just turned <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> y.o.`</span>)
  &#125;
&#125;

<span class="hljs-keyword">let</span> girl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()
girl.<span class="hljs-title function_">say</span>()</code></pre><p>使用 class 语法糖:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>() &#123;
 <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>:<span class="hljs-built_in">string</span> = name
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>:<span class="hljs-built_in">number</span> = age
 &#125;
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">say</span>():<span class="hljs-built_in">void</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> say she had just turned <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> y.o.`</span>)
 &#125;
&#125;

<span class="hljs-keyword">let</span> girl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()
girl.<span class="hljs-title function_">say</span>()</code></pre><h3 id="prototype-Attribute"><a href="#prototype-Attribute" class="headerlink" title="prototype Attribute"></a><code>prototype</code> Attribute</h3><p><code>prototype</code> 是 <strong>构造函数</strong>、<strong>class 类</strong>,独有的一个 <strong>对象</strong>.<code>prototype</code> 是 <strong>函数才会有的属性</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;
<span class="hljs-comment">// Note: prototype 函数内置的属性</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Kevin&quot;</span>
<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()
<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>) <span class="hljs-comment">// Kevin</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>) <span class="hljs-comment">// Kevin</span></code></pre><p>函数的 prototype 属性指向了一个 <strong>原型对象</strong>,这个对象正是调用该构造函数而创建的 <strong>实例</strong> 的原型,也就是这个例子中的 person1 和 person2 的原型.</p><p>那什么是原型呢?你可以这样理解:每一个 JavaScript 对象 (null 除外) 在创建的时候就会与之关联另一个对象,这个对象就是我们所说的 <strong>原型</strong>,每一个对象都会从原型 “ 继承 “ 属性.</p><h3 id="proto-Attribute"><a href="#proto-Attribute" class="headerlink" title="__proto__ Attribute"></a><code>__proto__</code> Attribute</h3><p><code>__proto__</code> 这是每一个 JavaScript <strong>对象</strong> (除了 null ) 都具有的一个属性,叫 <strong>proto</strong>,这个属性会指向该对象的原型.</p><p><code>__proto__</code> 被称为 <strong>对象</strong> 的 <strong>隐式原型</strong>,对应的是构造函数(类)的 <code>prototype</code> 原型<strong>对象</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;
<span class="hljs-comment">// 实例化构造函数(类)返回对象</span>
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()
<span class="hljs-comment">// 对象的 __proto__ 属性指向构造函数(类)的 prototype</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span></code></pre><p><img src="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-1.png&webp=true" class="lazy" data-srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-1.png&webp=true" srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/loading.gif"></p><h3 id="Constructor-构造器"><a href="#Constructor-构造器" class="headerlink" title="Constructor 构造器"></a>Constructor 构造器</h3><p>每个原型对象都有一个 <strong>constructor</strong> 属性指向关联的构造函数.</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>) <span class="hljs-comment">// true</span></code></pre><p><img src="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-2.png&webp=true" class="lazy" data-srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-2.png&webp=true" srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/loading.gif"><br>综上:</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;

<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 一个ES5的方法 `Object.getPrototypeOf()`, 可以获得对象的原型</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span></code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>构造函数(类)的原型对象也是一个对象 <strong>object</strong>,所以他也具有 <code>__proto__</code> 隐式原型属性,指向 object 对象的构造函数(类)的原型对象 <code>Object.prototype</code> .</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// 构造函数(类)的 **原型对象**</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// 原型对象的隐式原型 指向 Object.prototype</span></code></pre><p>所以对象的隐式原型的原型对象构成一条原型链:</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params">name</span>)&#123;
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
&#125;

<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;hyy&quot;</span>)
<span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
<span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>

obj &#123;
 <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>
 <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;
  <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>
  <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;
   <span class="hljs-attr">__proto__</span>:<span class="hljs-literal">null</span> <span class="hljs-comment">// 原型链顶层</span>
  &#125;
 &#125;
&#125;</code></pre><p>对象寻找数值,是原型链从下到上一直找到原型链顶端,用 <strong>冒泡</strong> 的方式查找的.</p><p><img src="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-3.png&webp=true" class="lazy" data-srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/JS/TypeScript-fast-start-3.png&webp=true" srcset="https://api.whaleluo.top/onedrive/file/?path=/PicStorage/blog/loading.gif" alt="TypeScript-fast-start-3.png"></p><h2 id="【Experiment】装饰器-Decorator"><a href="#【Experiment】装饰器-Decorator" class="headerlink" title="【Experiment】装饰器 Decorator"></a>【Experiment】装饰器 Decorator</h2><p>在 tsconfig.json 启动 experiment 实验功能:</p><pre><code class="hljs js"><span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,
<span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>,</code></pre><h3 id="Class-decorator"><a href="#Class-decorator" class="headerlink" title="Class decorator"></a>Class decorator</h3><p>类装饰器,可以在不修改类的情况下,通过操作类(构造函数)的原型对象 <code>prototype</code> 向类添加 method 和 attribute.</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">watcher</span>: <span class="hljs-title class_">ClassDecorator</span> = <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) =&gt;</span> &#123;
  <span class="hljs-comment">// target 是构造函数(类)</span>
  target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getParams</span> = &lt;T&gt;(<span class="hljs-attr">params</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> params
  &#125;
&#125;

<span class="hljs-meta">@watcher</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;
&#125;

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((a <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-title function_">getParams</span>(<span class="hljs-string">&quot;123&quot;</span>))
<span class="hljs-comment">// 装饰器其实就是一个语法糖,本质上是</span>
<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">watcher</span>(A) <span class="hljs-comment">// 将源对象放入装饰器函数</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">wrapper</span>() <span class="hljs-comment">// 返回装饰过后的构造函数</span></code></pre><p>decorator factory 装饰器工厂:允许往装饰器内传参,也就是一个高阶函数闭包,返回一个 <code>ClassDecorator</code></p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> watcher = (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">ClassDecorator</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) =&gt;</span> &#123;
    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getParams</span> = &lt;T&gt;(<span class="hljs-attr">params</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> &#123;
      <span class="hljs-keyword">return</span> params
    &#125;
    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getOptions</span> = (): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> &#123;
      <span class="hljs-keyword">return</span> name
    &#125;
  &#125;
&#125;

<span class="hljs-meta">@watcher</span>(<span class="hljs-string">&quot;name&quot;</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;
&#125;

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((a <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-title function_">getOptions</span>(<span class="hljs-string">&quot;123&quot;</span>))</code></pre><h3 id="Method-decorator-方法装饰器"><a href="#Method-decorator-方法装饰器" class="headerlink" title="Method decorator 方法装饰器"></a>Method decorator 方法装饰器</h3><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">met</span>: <span class="hljs-title class_">MethodDecorator</span> = <span class="hljs-function">(<span class="hljs-params">target, key, descriptor</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 接收三个参数</span>
  <span class="hljs-comment">// 1. static method -&gt; 类的构造函数 methods -&gt; 类的原型对象 prototype</span>
  <span class="hljs-comment">// 2. 成员的名字</span>
  <span class="hljs-comment">// 3. 成员的属性描述符</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;
  <span class="hljs-meta">@met</span>
  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">string</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;小满&quot;</span>
  &#125;
&#125;

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()</code></pre><p>返回的参数:可以在 <code>descriptor</code> 更改 value 的数值,达到直接改传参的目的.</p><pre><code class="hljs json"><span class="hljs-punctuation">[</span>
  <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
  &#x27;setParasm&#x27;<span class="hljs-punctuation">,</span>
  <span class="hljs-punctuation">&#123;</span>
    value<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>Function<span class="hljs-punctuation">:</span> setParasm<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    writable<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    enumerable<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
    configurable<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">]</span></code></pre><h2 id="通过-Rollup-构建-TS-项目"><a href="#通过-Rollup-构建-TS-项目" class="headerlink" title="通过 Rollup 构建 TS 项目"></a>通过 Rollup 构建 TS 项目</h2><pre><code class="hljs shell">npm init -y # Generate package.json
tsc --init # Generate tsconfig.json
npm i rollup -g</code></pre><h2 id="TS-实现发布订阅模式"><a href="#TS-实现发布订阅模式" class="headerlink" title="TS 实现发布订阅模式"></a>TS 实现发布订阅模式</h2><p>发布订阅模式于类似 mqtt 物联网,在前端中 <code>addEventListener</code> 和 <code>vue eventBus</code> 也是发布订阅模式.</p><p>发布订阅模式有:发布者、订阅者、调度者</p><h2 id="ES6-新类型-weakMap-weakSet-set-map"><a href="#ES6-新类型-weakMap-weakSet-set-map" class="headerlink" title="ES6 新类型 weakMap weakSet set map"></a>ES6 新类型 weakMap weakSet set map</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合是由一组无序且唯一 (即不能重复) 的项组成的,可以想象成集合是一个既没有重复元素,也没有顺序概念的数组.</p><ol><li><p>attribute</p><ul><li>size: 返回 set 数据结构的数据长度</li></ul></li><li><p>methods</p><ul><li>add(value):添加某个值,返回 Set 结构本身.</li><li>delete(value):删除某个值,返回一个布尔值,表示删除是否成功.</li><li>has(value):返回一个布尔值,表示该值是否为 Set 的成员.</li><li>clear():清除所有成员,无返回值.</li></ul></li></ol><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">set</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>)
set.<span class="hljs-title function_">has</span>(<span class="hljs-number">5</span>)
set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">5</span>)
set.<span class="hljs-property">size</span> <span class="hljs-comment">//4</span></code></pre><p>数组去重:</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> arr = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>])]

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">//[ 1, 2, 3, 4, 5 ]</span></code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>它类似于对象,也是<strong>键值对</strong> (key-value) 的集合,但是 key 的 type 不限于 string,各种类型的值(包括 <strong>object</strong> 等 <strong>引用类型</strong>)都可以当作 key,是一种更完善的 Hash 结构实现.如果你需要”<strong>键值对</strong>“的数据结构,Map 比 Object 更合适.</p><p>操作方法同 set</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小满&quot;</span> &#125;
<span class="hljs-keyword">let</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">object</span>, <span class="hljs-title class_">Function</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()

<span class="hljs-comment">// methods</span>
map.<span class="hljs-title function_">set</span>(obj, <span class="hljs-function">() =&gt;</span> <span class="hljs-number">123</span>)
map.<span class="hljs-title function_">get</span>(obj)
map.<span class="hljs-title function_">has</span>(obj)
map.<span class="hljs-title function_">delete</span>(obj)
map.<span class="hljs-property">size</span></code></pre><h3 id="WeakSet-WeakMap"><a href="#WeakSet-WeakMap" class="headerlink" title="WeakSet WeakMap"></a>WeakSet WeakMap</h3><p>weak: adj. 弱的,weakSet 和 weakMap 的键都是<strong>弱引用</strong>,<strong>不会计入垃圾回收</strong>.</p><p>Javascript V8 引擎 GC 是通过 <strong>计数引用</strong> 进行清除的.</p><p>首先 obj 引用了这个对象 +1,aahph 也引用了 + 1,wmap 也引用了,但是不会 + 1,因为他是弱引用,不会计入垃圾回收,因此 obj 和 aahph 释放了该引用 weakMap 也会随着消失的,但是有个问题你会发现控制台能输出,值是取不到的.</p><p>因为 V8 的 GC 回收是需要一定时间的,需要延长到 最少 200ms weakMap 才会回收,为了避免这个问题 weakMap 不允许取键值,也不允许遍历,同理 weakSet 也一样.</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-built_in">any</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hyy 自残&quot;</span> &#125; <span class="hljs-comment">// 引用计数 +1</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">aahph</span>: <span class="hljs-built_in">any</span> = obj <span class="hljs-comment">// 引用计数 +2</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">wmap</span>: <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-built_in">object</span>, <span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>() <span class="hljs-comment">// 弱引用 weak</span>

wmap.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&quot;Finland&quot;</span>) <span class="hljs-comment">// WeakMap 的 key 是弱引用,所以 obj 不会计数,obj 当前引用计数为 2</span>

obj = <span class="hljs-literal">null</span> <span class="hljs-comment">// 对象置空,引用 -1</span>
aahph = <span class="hljs-literal">null</span> <span class="hljs-comment">// 对象置空,引用 -1</span>

<span class="hljs-comment">//v8 GC 不稳定 最少200ms</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wmap)
&#125;, <span class="hljs-number">500</span>)</code></pre><h2 id="Function-函数的二义性-箭头函数"><a href="#Function-函数的二义性-箭头函数" class="headerlink" title="Function 函数的二义性 箭头函数"></a>Function 函数的二义性 箭头函数</h2><p>一个函数有两种意义:1. 作为一个普通函数调用 2. 作为对象的构造函数 object construct function</p><p>开发者标准:如果一个<strong>普通函数开头大写</strong>,declare 声明这个函数就是对象构造函数.</p><pre><code class="hljs javascript"><span class="hljs-comment">// 函数的二义性</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-comment">// 函数内的 this 指向它自身</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;hyy&quot;</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">say</span> = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;function object say hyy&quot;</span>)
  &#125;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;function log&quot;</span>)
&#125;

<span class="hljs-comment">// 作为函数调用</span>
<span class="hljs-title function_">fn</span>()
<span class="hljs-comment">// 作为构造函数 实例化 作为对象</span>
fnObject = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>()
fnObject.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;hyy&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fnObject)
<span class="hljs-comment">// output:</span>
<span class="hljs-comment">// fn &#123;name: &#x27;hyy&#x27;, say: ƒ&#125;</span>
<span class="hljs-comment">// name: &quot;hyy&quot;</span>
<span class="hljs-comment">// say: () =&gt; &#123; console.log(&quot;function object say hyy&quot;) &#125;</span>
<span class="hljs-comment">// constructor: ƒ fn()</span>
<span class="hljs-comment">// [[Prototype]]: Object // 对象的隐式原型</span></code></pre><p>在 ts 中,如果需要构建对象,可以使用 class 定义一个类,通过 new 实例化类来拿到类实例化后的对象:</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> extands <span class="hljs-title class_">Object</span> &#123;
 <span class="hljs-title function_">construct</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>) &#123;
  <span class="hljs-comment">// 构造函数</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name <span class="hljs-comment">// 类 attribute</span>
 &#125;
 <span class="hljs-comment">// 类方法 methods</span>
 <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>)
 &#125;
 <span class="hljs-comment">// 原型对象</span>
 <span class="hljs-attr">prototype</span>:&#123;
  <span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &#123; <span class="hljs-comment">// 隐式原型</span>
   <span class="hljs-attr">__proto__</span>: <span class="hljs-literal">null</span>
  &#125;
 &#125;
&#125;

vue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(<span class="hljs-string">&quot;hyy&quot;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vue)
<span class="hljs-comment">// &#123;name:&quot;hyy&quot;, say: ƒ&#125;</span></code></pre><h3 id="箭头函数-Arrow-Function"><a href="#箭头函数-Arrow-Function" class="headerlink" title="箭头函数 Arrow Function"></a>箭头函数 Arrow Function</h3><p>如果想要消除函数的<strong>二义性</strong>需要使用 <strong>箭头函数</strong> <code>const fn = (x, y)=&gt; x+y</code></p><p><strong>this</strong> 指向的不同:</p><ul><li>普通 function 定义的函数 <strong>this 指向它自身</strong>.</li><li>箭头函数 <strong>this 是指向外面环境</strong>的,所以箭头函数本身无法去创建属性.</li></ul><p>箭头函数没有 <strong>prototype</strong> 原型对象,所以它不能被 new 成为对象构造函数.</p><pre><code class="hljs typescript"><span class="hljs-comment">// Arrow Function</span>
<span class="hljs-comment">// this 为静态 (static), 由定义时所在的上下文决定</span>
<span class="hljs-comment">// this 指向外面的环境, 在 browser 中 this 是 windows</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)
&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn) <span class="hljs-comment">// 没有 prototype</span>

<span class="hljs-comment">// Function declaration</span>
<span class="hljs-comment">// this 为动态 (dynamic), 由调用方式决定</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)
&#125;

fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// 有 prototype</span>
<span class="hljs-comment">// 使用 bind 改变 this 指向</span>
fn.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hyy&quot;</span> &#125;)()
<span class="hljs-comment">// 包装在 object 中 / wrapping in object 也可以改变 this 指向</span>
obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj name&quot;</span>,
  <span class="hljs-attr">fn</span>: fn
&#125;
obj.<span class="hljs-title function_">fn</span>() <span class="hljs-comment">// this 指向 obj</span></code></pre><p>箭头函数与 this 绑定:</p><p><strong>Note</strong>: 箭头函数(Arrow Functions) 和 普通函数 (Function Declarations) (Function Expressions) 在 this 的处理上有一个很大的不同:</p><ul><li>普通函数: this 的值是在 <strong>运行时根据调用方式动态确定的</strong> .比如在对象方法中, this 通常指向调用该方法的对象.</li><li>箭头函数: 箭头函数 <strong>没有自己的 this 绑定</strong>, 它会捕获其 <strong>定义时所在上下文</strong> 的 this 值,作为自己的 this.这意味着箭头函数的 this 是静态的,不会根据调用方式改变.</li></ul><h2 id="TS-进阶代理-反射-proxy-Reflect"><a href="#TS-进阶代理-反射-proxy-Reflect" class="headerlink" title="TS 进阶代理&amp;反射 proxy &amp; Reflect"></a>TS 进阶代理&amp;反射 proxy &amp; Reflect</h2><p><strong>Proxy</strong>  对象用于创建一个对象的代理,从而实现基本操作的拦截和自定义(如属性查找、赋值、枚举、函数调用等).</p><p>Vue3 正是通过 <strong>Proxy</strong> 代理对象实现页面的响应式的.</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>
&#125;

<span class="hljs-comment">// 返回一个 proxy 对象</span>
<span class="hljs-comment">// 传入:</span>
<span class="hljs-comment">// target 目标对象,可以是任何类型的对象,包括原生数组,函数</span>
<span class="hljs-comment">// handler 一个以 func 作为 attribute 的 object</span>
<span class="hljs-comment">// 定义了在操作 proxy 对象时的行为,例如 get set</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">proxy</span> = (<span class="hljs-params"><span class="hljs-built_in">object</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">any</span></span>) =&gt; &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-built_in">object</span>, &#123;
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`get key======&gt;<span class="hljs-subst">$&#123;key&#125;</span>`</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver)
    &#125;,

    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value, receiver</span>) &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`set key======&gt;<span class="hljs-subst">$&#123;key&#125;</span>`</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value, receiver)
    &#125;
  &#125;)
&#125;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">logAccess</span> = (<span class="hljs-params"><span class="hljs-built_in">object</span>: Person, key: <span class="hljs-string">&quot;name&quot;</span> | <span class="hljs-string">&quot;age&quot;</span> | <span class="hljs-string">&quot;text&quot;</span></span>) =&gt; &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-built_in">object</span>, key)
&#125;

<span class="hljs-comment">// 使用 keyof + generics 泛型优化</span>

<span class="hljs-keyword">const</span> logAccess = &lt;T&gt;(<span class="hljs-attr">object</span>: T, <span class="hljs-attr">key</span>: keyof T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-built_in">object</span>, key)
&#125;

<span class="hljs-keyword">let</span> <span class="hljs-attr">man</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-title function_">logAccess</span>(
  &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hyy&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;刚满18岁&quot;</span>
  &#125;,
  <span class="hljs-string">&quot;age&quot;</span>
)

man.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(man)</code></pre><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>与大多数全局对象不同 <code>Reflect</code> 并非一个构造函数,所以不能通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new 运算符</a> 对其进行调用.<br>要将 <code>Reflect</code> 对象作为一个函数来调用.<code>Reflect</code> 的所有属性和方法都是静态的(就像 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math" title="Math">Math</a> 对象)</p><p>API:</p><p>Reflect.get 方法查找并返回 target 对象的 name 属性,如果没有该属性返回 undefined</p><pre><code class="hljs javascript"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, name, receiver)</code></pre><p>Reflect.set 方法设置 target 对象的 name 属性等于 value.</p><pre><code class="hljs javascript"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, name, value, receiver)</code></pre><h3 id="实现-mobx-observer-观察者模式"><a href="#实现-mobx-observer-观察者模式" class="headerlink" title="实现 mobx observer 观察者模式"></a>实现 mobx observer 观察者模式</h3><pre><code class="hljs javascript"><span class="hljs-comment">// func set</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Function</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()

<span class="hljs-comment">// add func in func set</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">autorun</span> = (<span class="hljs-params">cb: <span class="hljs-built_in">Function</span></span>) =&gt; &#123;
    <span class="hljs-keyword">if</span> (cb) &#123;
        list.<span class="hljs-title function_">add</span>(cb)
    &#125;
&#125;

<span class="hljs-keyword">const</span> observable = &lt;T <span class="hljs-keyword">extends</span> object&gt;<span class="hljs-function">(<span class="hljs-params">params: T</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(params, &#123;
        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;
            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)
            <span class="hljs-comment">// run funcs in set when object call set function.</span>
            list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list)
            <span class="hljs-keyword">return</span> result
        &#125;
    &#125;)
&#125;

<span class="hljs-keyword">const</span> person = <span class="hljs-title function_">observable</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;光头强&quot;</span>, <span class="hljs-attr">attr</span>: <span class="hljs-string">&quot;惹我光头强&quot;</span> &#125;)

<span class="hljs-title function_">autorun</span>(<span class="hljs-function">()=&gt;</span>&#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;熊熊变绵🐏&#x27;</span>)
&#125;)

<span class="hljs-comment">// console.log(&quot;我变化了&quot;) when proxy object was changed.</span>
person.<span class="hljs-property">attr</span> = <span class="hljs-string">&#x27;揍你没商量&#x27;</span></code></pre><h2 id="Type-Guards-类型守卫"><a href="#Type-Guards-类型守卫" class="headerlink" title="Type Guards 类型守卫"></a>Type Guards 类型守卫</h2><p>在 TypeScript 中,类型守卫(<code>Type Guards</code>)是一种用于在 <strong>运行时检查类型</strong> 的机制.它们允许你在代码中执行特定的检查,以确定变量的类型,并在需要时执行相应的操作.</p><h3 id="Typeof-类型收缩"><a href="#Typeof-类型收缩" class="headerlink" title="Typeof 类型收缩"></a>Typeof 类型收缩</h3><p>声明一个函数可以接受任意类型,并返回一个 boolean,只筛选出字符串类型,进行类型收缩.</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> isString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">any</span>): <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&quot;string&quot;</span>
&#125;

<span class="hljs-comment">// typeof returns a type represented(vt. 表现) as string</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;Hello&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str) <span class="hljs-comment">// 输出: &quot;string&quot;</span>

<span class="hljs-keyword">const</span> num = <span class="hljs-number">42</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num) <span class="hljs-comment">// 输出: &quot;number&quot;</span>

<span class="hljs-keyword">const</span> bool = <span class="hljs-literal">true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> bool) <span class="hljs-comment">// 输出: &quot;boolean&quot;</span></code></pre><p>typeof 只能返回有限的字符串类型,包括 “string”、”number”、”boolean”、”symbol”、”undefined” 和 “object”.对于函数、数组、null 等类型,typeof 也会返回 “object”.因此,typeof 对于复杂类型和自定义类型的判断是有限的.</p><h3 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h3><p>使用 instanceof 类型守卫可以 <strong>检查一个对象是否是特定类的实例</strong>.</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> isArr = (<span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-built_in">number</span> | <span class="hljs-function"><span class="hljs-params">unknow</span> =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;
    value.<span class="hljs-property">length</span>
  &#125;
&#125;</code></pre><p><code>instanceof</code> 操作符用于<strong>检查一个对象是否是某个类的实例</strong>.它通过 <strong>检查对象的原型链</strong> 来确定对象是否由指定的类创建.</p><p><code>instanceof</code> 操作符主要用于检查对象是否是特定类的实例,它 <strong>无法检查基本类型</strong>.此外,它也<strong>无法检查对象是通过字面量创建</strong>的,因为字面量对象没有显式的构造函数.</p><p>The left-hand side of an ‘instanceof’ expression must be of type <strong>‘any’</strong>, an <strong>object type</strong> or a <strong>type parameter</strong>.<br>‘instanceof’ 表达式的左侧必须是 ‘any’ 类型,对象类型或类型参数.</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
  &#125;
&#125;

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>) <span class="hljs-comment">// 输出: true</span>

<span class="hljs-keyword">const</span> obj = &#123;&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>) <span class="hljs-comment">// 输出: false</span>

<span class="hljs-keyword">const</span> num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-number">12</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 无法判断字面量</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">num2</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((num2 <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) <span class="hljs-comment">// false</span></code></pre><h3 id="Custom-Guard-自定义守卫"><a href="#Custom-Guard-自定义守卫" class="headerlink" title="Custom Guard 自定义守卫"></a>Custom Guard 自定义守卫</h3><p>实现一个函数支持任意类型:</p><ol><li>如果是对象,就检查里面的属性,</li><li>如果里面的属性是 number 就取两位,如果是 string 就去除左右空格</li><li>如果是函数就执行</li></ol><p>编写代码时,需要用到 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">类型谓语 (type predicate)</a> 才能拥有良好的 type hint.</p><pre><code class="hljs typescript"><span class="hljs-comment">// use type predicate</span>
<span class="hljs-keyword">const</span> isString = (<span class="hljs-attr">str</span>: <span class="hljs-built_in">any</span>): str is <span class="hljs-built_in">string</span> =&gt; <span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&quot;string&quot;</span>
<span class="hljs-keyword">const</span> isNumber = (<span class="hljs-attr">num</span>: <span class="hljs-built_in">any</span>): num is <span class="hljs-built_in">number</span> =&gt; <span class="hljs-keyword">typeof</span> num === <span class="hljs-string">&quot;number&quot;</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isFn</span> = (<span class="hljs-params">fn: <span class="hljs-built_in">any</span></span>) =&gt; <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&quot;function&quot;</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isObj</span> = (<span class="hljs-params">obj: <span class="hljs-built_in">any</span></span>) =&gt; (&#123;&#125;).<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&quot;[object Object]&quot;</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt; &#123;
  <span class="hljs-keyword">let</span> value
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObj</span>(data)) &#123;
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;
      value = data[key]
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isString</span>(value)) &#123;
        data[key] = value.<span class="hljs-title function_">trim</span>()
      &#125;
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumber</span>(value)) &#123;
        data[key] = value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)
      &#125;
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFn</span>(value)) &#123;
        <span class="hljs-comment">// 当函数被单独调用时(例如 value()),</span>
        <span class="hljs-comment">// 函数内部的 this 会指向全局对象(在浏览器环境下是 window)</span>
        <span class="hljs-comment">// value()</span>
        data[key]()
      &#125;
    &#125;)
  &#125;
&#125;
<span class="hljs-keyword">const</span> obj = &#123;
  <span class="hljs-attr">a</span>: <span class="hljs-number">100.22222</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&quot; test  &quot;</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>
  &#125;
&#125;

<span class="hljs-title function_">fn</span>(obj)</code></pre><h2 id="Type-compatible-kəmˈpaetəbl-类型兼容"><a href="#Type-compatible-kəmˈpaetəbl-类型兼容" class="headerlink" title="Type compatible[&#x2F;kəmˈpætəbl&#x2F;] 类型兼容"></a>Type compatible[&#x2F;kəmˈpætəbl&#x2F;] 类型兼容</h2><p>类型兼容,就是用于确定一个类型 <strong>是否能赋值给其他的类型</strong>.TS 中的类型兼容性是基于 <strong>结构类型</strong> 的(也就是形状 shape),如果 A 要兼容 B,那么 A 至少具有 B 相同的属性.</p><h3 id="型变-协变-逆变-Duck-Type-鸭子类型"><a href="#型变-协变-逆变-Duck-Type-鸭子类型" class="headerlink" title="型变 (协变&#x2F;逆变) &amp; Duck Type 鸭子类型"></a>型变 (协变&#x2F;逆变) &amp; Duck Type 鸭子类型</h3><blockquote><p>什么是鸭子类型?<br>一只鸟 走路像鸭子 ,游泳也像,做什么都像,那么这只鸟就可以成为鸭子类型.<br>– duck type</p></blockquote><p>A B 两个类型完全不同但是可以赋值并无报错,B 类型充当 A 类型的子类型,当子类型里面的属性满足 A 类型就可以进行赋值,也就是说不能少可以多,这就是协变.</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;
    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>
    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span>
&#125;

<span class="hljs-comment">// 相当于 B 继承自 A</span>
<span class="hljs-keyword">interface</span> B extands A &#123;
    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>
    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span>
    <span class="hljs-attr">sex</span>:<span class="hljs-built_in">string</span>
&#125;

<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: A = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hyy&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
&#125;

<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: B = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;yyh&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;女&quot;</span>
&#125;

a = b</code></pre><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>TypeScript 给 JavaScript 添加了一套静态类型系统,是为了保证类型安全的,也就是保证变量只能赋同类型的值,对象只能访问它有的属性、方法.这是类型检查做的事情,遇到类型安全问题会在编译时报错.</p><p>子类型是可以赋值给父类型的变量的,可以完全当成父类型来使用,也就是”型变(variant)”(类型改变).</p><p>这种”型变”分为两种,一种是子类型可以赋值给父类型,叫做协变(covariant),一种是父类型可以赋值给子类型,叫做逆变(contravariant).</p><p>对于 <strong>字面量类型</strong> 采用 <strong>协变</strong> 的变换规则,即 子类型 &#x3D;&gt; 父类型, 看下面,因为 a 具备 string 的可能,没办法直接赋值给 b.但 b 可以赋值给 a, 子类型可以赋值给父类类型, 这就是协变. covariant (variant [&#x2F;‘veərɪənt&#x2F;] n. 变体 adj. 不同的)</p><pre><code class="hljs typescript"><span class="hljs-comment">// parent</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">parent</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>
<span class="hljs-comment">// child</span>
<span class="hljs-comment">// Error: a may be string</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">child</span>: <span class="hljs-built_in">number</span> = parent

<span class="hljs-comment">// correct</span>
<span class="hljs-keyword">const</span> parent = child</code></pre><p>而对于 <strong>函数的参数类型</strong>,采用完全相反的规则,即<strong>逆变 (contravariant)</strong>,允许父类型赋值给子类型,因为函数中是以父类型进行的约束,赋值一个限制更明确的子类型反而会造成意料之外的问题.</p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">parent</span> = (<span class="hljs-params">c: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) =&gt; &#123;...&#125;
<span class="hljs-keyword">let</span> <span class="hljs-title function_">child</span> = (<span class="hljs-params">c: <span class="hljs-built_in">number</span></span>) =&gt; &#123;...&#125;

<span class="hljs-comment">// correct</span>
child = parent
<span class="hljs-comment">// error</span>
parent = child
</code></pre><p>协变和逆变在类型体操的时候会常常出现.当然不论是协变还是逆变,它们首先得是 <strong>型变</strong>.型变都是针对父子类型来说的,非父子类型自然就不会型变也就是不变(invariant).ts 中父子类型的判定是按照<strong>结构</strong> 来看的,更具体的那个是子类型.</p><p>开启双向协变</p><p>tsconfig strictFunctionTypes 设置为 false 支持双向协变 fna fnb 随便可以来回赋值</p><h2 id="TS-泛型工具"><a href="#TS-泛型工具" class="headerlink" title="TS 泛型工具"></a>TS 泛型工具</h2><p><strong>泛型工具</strong> 是一组预定义的泛型类型和操作符,用于<strong>操作和转换类型</strong>.它们可以帮助我们编写更灵活、更通用的代码,并提高代码的可读性和可维护性.</p><h3 id="Partial-adj-局部的-和-Required-adj-必须的"><a href="#Partial-adj-局部的-和-Required-adj-必须的" class="headerlink" title="Partial(adj. 局部的) 和 Required(adj. 必须的)"></a>Partial(adj. 局部的) 和 Required(adj. 必须的)</h3><p><code>Partial</code>  是一个泛型类型,用于将一个类型的所有属性变为可选.<br>与之相反,<code>Required</code>  是一个泛型类型,用于将一个类型的所有属性变为必选</p><pre><code class="hljs typescript"><span class="hljs-comment">// Partial: makes all attributes of a type optional</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-keyword">type</span> test = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">User</span>&gt;
<span class="hljs-comment">// 转换完成之后的结果</span>
<span class="hljs-keyword">type</span> test = &#123;
  name?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>
  age?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>
&#125;

<span class="hljs-comment">// 原理</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">PratialUser</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;
  [P <span class="hljs-keyword">in</span> K]?: T[P]
&#125;

<span class="hljs-comment">// Required: makes all attributes of a type required</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;
  name?: <span class="hljs-built_in">string</span>
  age?: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-comment">// 原理</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomRequired</span>&lt;T&gt; = &#123;
  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P]
&#125;

<span class="hljs-keyword">type</span> test = <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">User</span>&gt;
<span class="hljs-keyword">type</span> test2 = <span class="hljs-title class_">CustomRequired</span>&lt;<span class="hljs-title class_">User</span>&gt;

<span class="hljs-comment">// 结果</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
&#125;</code></pre><h3 id="Pick-选取-和-Exclude-排除"><a href="#Pick-选取-和-Exclude-排除" class="headerlink" title="Pick(选取) 和 Exclude(排除)"></a>Pick(选取) 和 Exclude(排除)</h3><p><code>Pick</code> 用于从一个类型中选取指定的属性.<br><code>Exclude</code>  是一个类型操作符,用于从一个类型的属性集合中排除指定的属性.</p><pre><code class="hljs typescript"><span class="hljs-comment">// pick: Used to select the specified property from a type</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;
  name?: <span class="hljs-built_in">string</span>
  age?: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-comment">// 原理</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CoustomPick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;
  [P <span class="hljs-keyword">in</span> K]: T[P]
&#125;

<span class="hljs-keyword">type</span> test = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&quot;age&quot;</span>&gt;

<span class="hljs-comment">// 结果</span>
<span class="hljs-keyword">type</span> test = &#123;
  age?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>
&#125;

<span class="hljs-comment">// Exclude: Used to exclude a specified property from a type&#x27;s property collection</span>

<span class="hljs-comment">// 原理</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomExclude</span>&lt;T, K&gt; = T <span class="hljs-keyword">extends</span> K ? <span class="hljs-built_in">never</span> : T
<span class="hljs-keyword">type</span> test = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span>&gt;

<span class="hljs-comment">// 结果</span>
<span class="hljs-keyword">type</span> test = <span class="hljs-string">&quot;c&quot;</span></code></pre><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><p>用于创建一个新类型,该新类型从原始类型中排除指定的属性.</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;
  address?: <span class="hljs-built_in">string</span>
  name?: <span class="hljs-built_in">string</span>
  age?: <span class="hljs-built_in">number</span>
&#125;
<span class="hljs-comment">// 原理</span>
<span class="hljs-keyword">type</span> coustomOmit&lt;T, K&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;
<span class="hljs-keyword">type</span> test = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&quot;age&quot;</span>&gt;

<span class="hljs-comment">// 结果</span>
<span class="hljs-keyword">type</span> test = &#123;
  address?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>
  name?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>
&#125;</code></pre><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p><strong>约束一个 object 对象的 key,value.</strong></p><p><code>Record</code> 工具类型接收两个泛型参数 K 和 T,其中:</p><ul><li>K 表示创建的新对象需要具有哪些属性,属性可以只有一个,也可以有多个,多个属性时采用 “ 联合类型 “ 的写法.</li><li>T 表示对象属性的类型.</li></ul><pre><code class="hljs typescript"><span class="hljs-comment">// record is used to constrain(v. 约束) the key and value of an object.</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Key</span> = <span class="hljs-string">&quot;c&quot;</span> | <span class="hljs-string">&quot;x&quot;</span> | <span class="hljs-string">&quot;k&quot;</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Value</span> = <span class="hljs-string">&quot;唱&quot;</span> | <span class="hljs-string">&quot;跳&quot;</span> | <span class="hljs-string">&quot;rap&quot;</span> | <span class="hljs-string">&quot;篮球&quot;</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Key</span>, <span class="hljs-title class_">Value</span>&gt; = &#123;
  <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;唱&quot;</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-string">&quot;跳&quot;</span>,
  <span class="hljs-attr">k</span>: <span class="hljs-string">&quot;rap&quot;</span>
&#125;

<span class="hljs-comment">// 原理</span>
<span class="hljs-comment">// 对象的key 只能是symbol string number 那么keyof any正好获取这三个类型</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomRecord</span>&lt;K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = &#123;
  [P <span class="hljs-keyword">in</span> K]: T
&#125;

<span class="hljs-comment">// 支持嵌套约束</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">CustomRecord</span>&lt;<span class="hljs-title class_">Key</span>, <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Key</span>, <span class="hljs-title class_">Value</span>&gt;&gt; = &#123;
  <span class="hljs-attr">c</span>: &#123;
    <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;唱&quot;</span>,
    <span class="hljs-attr">x</span>: <span class="hljs-string">&quot;跳&quot;</span>,
    <span class="hljs-attr">k</span>: <span class="hljs-string">&quot;rap&quot;</span>
  &#125;,
  <span class="hljs-attr">x</span>: &#123;
    <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;唱&quot;</span>,
    <span class="hljs-attr">x</span>: <span class="hljs-string">&quot;跳&quot;</span>,
    <span class="hljs-attr">k</span>: <span class="hljs-string">&quot;rap&quot;</span>
  &#125;,
  <span class="hljs-attr">k</span>: &#123;
    <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;唱&quot;</span>,
    <span class="hljs-attr">x</span>: <span class="hljs-string">&quot;跳&quot;</span>,
    <span class="hljs-attr">k</span>: <span class="hljs-string">&quot;rap&quot;</span>
  &#125;
&#125;</code></pre><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p>这个工具主要适用于函数,能够提取函数所返回的类型.</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;sad&quot;</span>]

<span class="hljs-keyword">type</span> num = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> fn&gt;
<span class="hljs-comment">// type num = (string | number)[]</span>

<span class="hljs-comment">// 原理</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomFn</span>&lt;F <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt; = F <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer <span class="hljs-title class_">Res</span>
  ? <span class="hljs-title class_">Res</span>
  : <span class="hljs-built_in">never</span></code></pre><h2 id="类型体操"><a href="#类型体操" class="headerlink" title="类型体操"></a>类型体操</h2><p><strong>类型编程中类型才是一等公民,我们并不能直接传入一个变量或是函数</strong>.需要通过 <code>typeof</code> <code>infer</code> 将值转换为类型才可.</p><h3 id="Extands-扩展"><a href="#Extands-扩展" class="headerlink" title="Extands (扩展)"></a>Extands (扩展)</h3><p>extends 关键词它可以保证某个参数<strong>至少具备某个类型</strong>, 也就是子类型是父类型的延伸, 扩展.</p><p>e.g. <code>arr extends unknown[]</code> 意思就是 arr 至少需要满足 <code>unknown[]</code> 的类型, <code>arr</code> 是 <code>unknown[]</code> 类型的延伸, 扩展.</p><h3 id="Infer-类型推断"><a href="#Infer-类型推断" class="headerlink" title="Infer 类型推断"></a>Infer 类型推断</h3><p>infer 关键词只能用于 extends 右侧,他们两个需要联动来使用,它的作用是可以完成<strong>类型的推</strong>导,我们知道在 ts 类型编程中,<strong>类型是一等公民</strong>,而不使用 infer 的时候,restArr 是无法被推导成一个类型的.</p><p>简单来说,在类型编程我们就可以使用 <code>yy extends xx&lt;infer xxx&gt; ? xxx : never</code> 的方式,提取出和 yy 相关的类型,比如这个例子中的去除第一个元素后,剩下的数组类型.</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> shiftArr&lt;arr extands <span class="hljs-built_in">unknown</span>[]&gt; = arr extand [<span class="hljs-built_in">unknown</span>, ...infer restArr] ? restArr : <span class="hljs-built_in">never</span>;

<span class="hljs-keyword">type</span> footArr = shiftArr&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&gt;
<span class="hljs-comment">// footArr = [2, 3]</span></code></pre><h3 id="类型条件判断"><a href="#类型条件判断" class="headerlink" title="类型条件判断"></a>类型条件判断</h3><p>在上面提到 extends 可以用来限制参数的类型,extends 关键词它可以保证某个参数<strong>至少具备某个类型</strong>,同样地,我们也可以将 extends 与 <strong>三元符</strong> 来结合,达到类 if 的作用.</p><p>以上面的代码为例,<code>arr extends [unknown, …infer restArr] ? restArr : never</code> 可以理解成,arr 可以按照 <code>[unknown, …infer restArr]</code> 来解析吗?如果可以的得到有效值的话,就返回 restArr, 反之返回 never.</p><h3 id="never-从不-unknown-未知-any-任意-对对碰"><a href="#never-从不-unknown-未知-any-任意-对对碰" class="headerlink" title="never(从不) unknown(未知) any(任意) 对对碰"></a>never(从不) unknown(未知) any(任意) 对对碰</h3><p>在 ts 中,<code>never</code> 表示 <strong>永远不可能存在的值</strong>, <strong>永远不能取得任何值的地方</strong>, 这个类型兜底了所有我们预料之外的情况,并且可以在用户触发这种场景的时候提供编译报错进行报警. 通常在类型编程中,遇到我们 <strong>预料之外</strong> 不知道该如何对应的值时(对应 null), 应该去使用 <code>never</code>.</p><p><code>unknown</code> 则是 <strong>可以取得任何值</strong>,但是不知道类型的地方.</p><p><code>any</code> 大家都很熟悉,使用它将 <strong>丧失所有的类型检查</strong>, 如果不考虑维护性, 做完就跑路, 大可以将 typescript 写成 anyscript.</p><h3 id="映射类型-Map-Type"><a href="#映射类型-Map-Type" class="headerlink" title="映射类型 (Map Type)"></a>映射类型 (Map Type)</h3><p>在 TypeScript 中对象、class 对应的类型是 <strong>索引类型</strong>(Index Type),映射类型可以用于修改索引类型,也就是将一个集合映射到另一个集合中,比如下面的例子,我们通过定义 MapType 作为映射类型,就可以很轻松地将一系列对象转化成我们需要的类型.</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapType</span>&lt;T&gt; = &#123;
  [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T]: [T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>]]
&#125;

<span class="hljs-keyword">type</span> res = <span class="hljs-title class_">MapType</span>&lt;&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;&gt;
<span class="hljs-comment">// res = &#123;a: [1, 1], b: [2, 2]&#125;</span></code></pre><h3 id="类型提取-Type-Extraction"><a href="#类型提取-Type-Extraction" class="headerlink" title="类型提取 (Type Extraction)"></a>类型提取 (Type Extraction)</h3><p>使用 <code>泛型 (generics) / infer (类型推断) / extands</code> 结合. 这个是类型编程中最为常用的技巧.</p><p>提取函数的返回值和参数类型</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> getFuncParams&lt;func <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt; = func <span class="hljs-keyword">extends</span> (
  ...<span class="hljs-attr">parmas</span>: infer params
) =&gt; <span class="hljs-built_in">unknown</span>
  ? params
  : <span class="hljs-built_in">never</span>

<span class="hljs-keyword">type</span> getFuncReturnType&lt;func <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt; = func <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer res
  ? res
  : <span class="hljs-built_in">never</span>

<span class="hljs-keyword">const</span> func = (<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;111&quot;</span>
&#125;

<span class="hljs-keyword">type</span> params = getFuncParams&lt;<span class="hljs-keyword">typeof</span> func&gt;
<span class="hljs-comment">// type params = [a: string, b: number]</span>

<span class="hljs-keyword">type</span> res = getFuncReturnType&lt;<span class="hljs-keyword">typeof</span> func&gt;
<span class="hljs-comment">// type res = string</span></code></pre><h3 id="递归处理-recursion-processing"><a href="#递归处理-recursion-processing" class="headerlink" title="递归处理 (recursion processing)"></a>递归处理 (recursion processing)</h3><p>类型编程所提供的能力并不完全等同于一个普通的编程语言,它是不支持循环的,对于一些需要循环的场景我们不能通过单次类型提取或是直接处理得到我们需要的结果.虽然不支持循环,但是 ts 的类型编程可以<strong>支持递归的实现</strong>,通过这种方式我们也可以处理这一类复杂场景.</p><p>如何深度(即也要处理子对象)将一个对象的属性转换为 readonly?</p><p>涉及到两个知识点,一个是 <strong>映射类型 (Map type)</strong>,另一个就是 <strong>递归 (Recursion)</strong>,需要先遍历对象的所有 key,并将每个 key 转化为 readonly,对应 key 映射的 value 我们需要做一个判断,如果这个 value 对应 object 类型,那么我们就对这个 value 再执行一遍我们定义的这个类型函数,反之,直接返回.</p><p>需要注意的是,这里额外加上了 <code>T extends any</code>,是为了触发对 <strong>完整类型</strong> 的计算,ts 只会 <strong>对用到的类型展开计算</strong>,所以不加的话,后续的 <code>readonly</code> 会由 <code>deepReadonly</code> 代替,而不是深度计算.</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> deepTransformToReadonly&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>
  ? &#123;
      <span class="hljs-keyword">readonly</span> [key <span class="hljs-keyword">in</span> keyof T]: T[key] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>
        ? deepTransformToReadonly&lt;T[key]&gt;
        : T[key]
    &#125;
  : <span class="hljs-built_in">never</span>

<span class="hljs-keyword">const</span> nestedObj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">c</span>: &#123; <span class="hljs-attr">c1</span>: <span class="hljs-string">&quot;c1&quot;</span>, <span class="hljs-attr">c2</span>: <span class="hljs-number">1</span> &#125; &#125;

<span class="hljs-keyword">type</span> nestedObjType = deepTransformToReadonly&lt;<span class="hljs-keyword">typeof</span> nestedObj&gt;

<span class="hljs-comment">// no T extands any</span>
<span class="hljs-comment">// type nestedObjType = &#123;</span>
<span class="hljs-comment">//     readonly a: string;</span>
<span class="hljs-comment">//     readonly b: number;</span>
<span class="hljs-comment">//     readonly c: deepTransformToReadonly&lt;&#123;</span>
<span class="hljs-comment">//         c1: string;</span>
<span class="hljs-comment">//         c2: number;</span>
<span class="hljs-comment">//     &#125;&gt;;</span>
<span class="hljs-comment">// &#125;</span>

<span class="hljs-comment">// add T extands any</span>
<span class="hljs-comment">// type nestedObjType = &#123;</span>
<span class="hljs-comment">//     readonly a: string;</span>
<span class="hljs-comment">//     readonly b: number;</span>
<span class="hljs-comment">//     readonly c: &#123;</span>
<span class="hljs-comment">//         readonly c1: string;</span>
<span class="hljs-comment">//         readonly c2: number;</span>
<span class="hljs-comment">//     &#125;;</span>
<span class="hljs-comment">// &#125;</span></code></pre><p>递归获取多层 Promise 的返回值.</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> getPromise&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer valueType&gt;
  ? valueType <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">unknown</span>&gt;
    ? getPromise&lt;valueType&gt;
    : valueType
  : <span class="hljs-built_in">never</span>;

<span class="hljs-keyword">type</span> test = getPromise&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt;&gt;
<span class="hljs-comment">// type test = boolean</span></code></pre><p>递归反转数组, 每次我们反转一个元素和剩下的数组序列,然后对剩下的数组序列执行同样的操作即可.</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReverseArray</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt; = T <span class="hljs-keyword">extends</span> [infer first, ...infer rest]
  ? [...<span class="hljs-title class_">ReverseArray</span>&lt;rest&gt;, first]
  : T

<span class="hljs-keyword">type</span> reversedArray = <span class="hljs-title class_">ReverseArray</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&gt;
<span class="hljs-comment">// type reversedArray = [4, 3, 2, 1]</span></code></pre><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至此,我应该了解了 <code>TypeScript</code> 这个语言的大概,继续学习 Vue 去了.</p><p>对于 TypeScript,它是一个很有价值,甚至能对 Pure JavaScript 应用于大型项目中缺陷进行有效弥补的超类.如果遇到阻塞的类型就使用 any,项目的劣化程度只会越来越严重,甚至 typeScript 也会形同虚设.好好地学习一下 typeScript 和类型编程是有意义的.</p></div><div class="post__license"><p><strong>Author: </strong>WhaleFall</p><p><strong>Permalink: </strong><a href="https://www.whaleluo.top/javascript/typescript-fast-start/">https://www.whaleluo.top/javascript/typescript-fast-start/</a></p><strong><p>文章默认使用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议进行许可，使用时请注意遵守协议。</p></strong></div><div class="post-footer__meta"><p>updated at 2023-09-01</p></div><div class="post-entry__tags"><a href="/tags/Vue/" class="post-tags__link button"># Vue</a><a href="/tags/TypeScript/" class="post-tags__link button"># TypeScript</a><a href="/tags/TS/" class="post-tags__link button"># TS</a><a href="/tags/Javascript/" class="post-tags__link button"># Javascript</a></div></article><div class="nav"><div class="nav__prev"><a href="/python/python-database-orm-tutorial/" class="nav__link"><div><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg></div><div><div class="nav__label">Previous Post</div><div class="nav__title">Python database 数据库 ORM 框架</div></div></a></div><div class="nav__next"><a href="/javascript/vue-tutorial/" class="nav__link"><div><div class="nav__label">Next Post</div><div class="nav__title">Vue3 正式学习笔记</div></div><div><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg></div></a></div></div><div class="post__comments post__with-toc content-card" id="comment"><h4>Comments</h4><div id="gitalk-container"></div></div></main><footer class="footer"><a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32"><path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path></svg> </a><span id="busuanzi_container_site_uv" hidden><span></span> <span id="busuanzi_value_site_uv"></span> <span>Viewers</span> <span>|</span> </span><span id="busuanzi_container_site_pv" hidden><span></span> <span id="busuanzi_value_site_pv"></span> <span>Views</span></span><p class="footer-copyright">Copyright © 2018&nbsp;-&nbsp;2024 <a href="/">😊落落のBlog😊</a></p><p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p></footer></div><script defer src="https://api.whaleluo.top/file/?url=https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script><script>window.lazyLoadOptions={elements_selector:".lazy",threshold:0}</script><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "e052e3fc47004feab6ae8122cfeec660"}'></script><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }</script><script>function loadComment() {
            let e, i;
            (e = document.createElement("script")).src = 'https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js',
            document.body.appendChild(e);
            e.onload = () => {
                var gitalk = new Gitalk({
                    clientID: 'b2fd920dada050fed5b3',
                    clientSecret: '5c847cefe7df2df634886eafa178877899404378',
                    repo: 'WhaleFell.github.io',
                    owner: 'WhaleFell',
                    admin: 'WhaleFell',
                    id: window.location.pathname,
                    distractionFreeMode: false
                });
                gitalk.render('gitalk-container');
            };
            (i = document.createElement("link")).rel = "stylesheet",
            i.href = 'https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css',
            document.head.appendChild(i);
        }
    
        var runningOnBrowser = typeof window !== "undefined";
        var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
        var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
    
        setTimeout(function () {
            if (!isBot && supportsIntersectionObserver) {
                var comment_observer = new IntersectionObserver(function(entries) {
                    if (entries[0].isIntersecting) {
                        loadComment();
                        comment_observer.disconnect();
                    }
                }, { threshold: [0] });
                comment_observer.observe(document.getElementById('comment'));
            } else {
                loadComment();
            }
        }, 1);</script></body></html>